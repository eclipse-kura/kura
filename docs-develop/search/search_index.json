{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Eclipse Kura\u2122 Documentation The emergence of an Internet of Thing (IoT) service gateway model running modern software stacks, operating on the edge of an IoT deployment as an aggregator and controller, has opened up the possibility of enabling enterprise level technologies to IoT gateways. Advanced software frameworks, which abstract and isolate the developer from the complexity of the hardware and the networking sub-systems, re-define the development and re-usability of integrated hardware and software solutions. Eclipse Kura is an Eclipse IoT project that provides a platform for building IoT gateways. It is a smart application container that enables remote management of such gateways and provides a wide range of APIs for allowing you to write and deploy your own IoT application. Kura runs on top of the Java Virtual Machine (JVM) and leverages OSGi, a dynamic component system for Java, to simplify the process of writing reusable software building blocks. Kura APIs offer easy access to the underlying hardware including serial ports, GPS, watchdog, USB, GPIOs, I2C, etc. It also offer OSGI bundle to simplify the management of network configurations, the communication with IoT servers, and the remote management of the gateway. Kura components are designed as configurable OSGi Declarative Service exposing service API and raising events. While several Kura components are in pure Java, others are invoked through JNI and have a dependency on the Linux operating system. Kura comes with the following services: I/O Services Serial port access through javax.comm 2.0 API or OSGi I/O connection USB access and events through javax.usb, HID API, custom extensions Bluetooth access through javax.bluetooth or OSGi I/O connection Position Service for GPS information from an NMEA stream Clock Service for the synchronization of the system clock Kura API for GPIO/PWM/I2C/SPI access Data Services Store and forward functionality for the telemetry data collected by the gateway and published to remote servers. Policy-driven publishing system, which abstracts the application developer from the complexity of the network layer and the publishing protocol used. Eclipse Paho and its MQTT client provide the default messaging library used. Cloud Services Easy to use API layer for IoT application to communicate with a remote server. In addition to simple publish/subscribe, the Cloud Service API simplifies the implementation of more complex interaction flows like request/response or remote resource management. Allow for a single connection to a remote server to be shared across more than one application in the gateway providing the necessary topic partitioning. Configuration Service Leverage the OSGi specifications ConfigurationAdmin and MetaType to provide a snapshot service to import/export the configuration of all registered services in the container. Remote Management Allow for remote management of the IoT applications installed in Kura including their deployment, upgrade and configuration management. The Remote Management service relies on the Configuration Service and the Cloud Service. Networking Provide API for introspects and configure the network interfaces available in the gateway like Ethernet, Wifi, and Cellular modems. Watchdog Service Register critical components to the Watchdog Service, which will force a system reset through the hardware watchdog when a problem is detected. Web administration interface Offer a web-based management console running within the Kura container to manage the gateway. Drivers and Assets A unified model is introduced to simplify the communication with the devices attached to the gateway. The Driver encapsulates the communication protocol and its configuration parameters, while the Asset, which is generic across Drivers, models the information data channels towards the device. When an Asset is created, a Mirror of the device is automatically available for on-demand read and writes via Java APIs or via Cloud through remote messages. Wires Offers modular and visual data flow programming tool to define data collection and processing pipelines at the edge by simply selecting components from a palette and wiring them together. This way users can, for example, configure an Asset, periodically acquire data from its channels, store them in the gateway, filter or aggregate them using powerful SQL queries, and send the results to the Cloud. The Eclipse Kura Marketplace is a repository from which additional Wires components can be installed into your Kura runtime with a simple drag-and-drop.","title":"Home"},{"location":"#welcome-to-the-eclipse-kuratm-documentation","text":"The emergence of an Internet of Thing (IoT) service gateway model running modern software stacks, operating on the edge of an IoT deployment as an aggregator and controller, has opened up the possibility of enabling enterprise level technologies to IoT gateways. Advanced software frameworks, which abstract and isolate the developer from the complexity of the hardware and the networking sub-systems, re-define the development and re-usability of integrated hardware and software solutions. Eclipse Kura is an Eclipse IoT project that provides a platform for building IoT gateways. It is a smart application container that enables remote management of such gateways and provides a wide range of APIs for allowing you to write and deploy your own IoT application. Kura runs on top of the Java Virtual Machine (JVM) and leverages OSGi, a dynamic component system for Java, to simplify the process of writing reusable software building blocks. Kura APIs offer easy access to the underlying hardware including serial ports, GPS, watchdog, USB, GPIOs, I2C, etc. It also offer OSGI bundle to simplify the management of network configurations, the communication with IoT servers, and the remote management of the gateway. Kura components are designed as configurable OSGi Declarative Service exposing service API and raising events. While several Kura components are in pure Java, others are invoked through JNI and have a dependency on the Linux operating system. Kura comes with the following services: I/O Services Serial port access through javax.comm 2.0 API or OSGi I/O connection USB access and events through javax.usb, HID API, custom extensions Bluetooth access through javax.bluetooth or OSGi I/O connection Position Service for GPS information from an NMEA stream Clock Service for the synchronization of the system clock Kura API for GPIO/PWM/I2C/SPI access Data Services Store and forward functionality for the telemetry data collected by the gateway and published to remote servers. Policy-driven publishing system, which abstracts the application developer from the complexity of the network layer and the publishing protocol used. Eclipse Paho and its MQTT client provide the default messaging library used. Cloud Services Easy to use API layer for IoT application to communicate with a remote server. In addition to simple publish/subscribe, the Cloud Service API simplifies the implementation of more complex interaction flows like request/response or remote resource management. Allow for a single connection to a remote server to be shared across more than one application in the gateway providing the necessary topic partitioning. Configuration Service Leverage the OSGi specifications ConfigurationAdmin and MetaType to provide a snapshot service to import/export the configuration of all registered services in the container. Remote Management Allow for remote management of the IoT applications installed in Kura including their deployment, upgrade and configuration management. The Remote Management service relies on the Configuration Service and the Cloud Service. Networking Provide API for introspects and configure the network interfaces available in the gateway like Ethernet, Wifi, and Cellular modems. Watchdog Service Register critical components to the Watchdog Service, which will force a system reset through the hardware watchdog when a problem is detected. Web administration interface Offer a web-based management console running within the Kura container to manage the gateway. Drivers and Assets A unified model is introduced to simplify the communication with the devices attached to the gateway. The Driver encapsulates the communication protocol and its configuration parameters, while the Asset, which is generic across Drivers, models the information data channels towards the device. When an Asset is created, a Mirror of the device is automatically available for on-demand read and writes via Java APIs or via Cloud through remote messages. Wires Offers modular and visual data flow programming tool to define data collection and processing pipelines at the edge by simply selecting components from a palette and wiring them together. This way users can, for example, configure an Asset, periodically acquire data from its channels, store them in the gateway, filter or aggregate them using powerful SQL queries, and send the results to the Cloud. The Eclipse Kura Marketplace is a repository from which additional Wires components can be installed into your Kura runtime with a simple drag-and-drop.","title":"Welcome to the Eclipse Kura\u2122 Documentation"},{"location":"admin/application-management/","text":"Application Management Package Installation After developing your application and generating a deployment package that contains the bundles to be deployed (refer to the Development section for more information), you may install it on the gateway using the Packages option in the System area of the Kura Gateway Administration Console as shown below. The package installation section of the UI Upon a successful installation, the new component appears in the Services list (shown as the BluetoothLE example in these screen captures). Its configuration may be modified according to the defined parameters as shown the BluetoothLe display that follows. Installation from Eclipse Marketplace\u2122 The application and components in the Eclipse Marketplace\u2122 can be easily installed in Kura dragging the Install button directly to the gray area in the Packages tab, as shown below. Package Signature Once the selected application deployment package (dp) file is installed, it will be listed in the Packages page and detailed with the name of the deployment package, the version and the signature status. The value of the signature field can be true if all the bundles contained in the deployment package are digitally signed, or false if at least one of the bundles is not signed.","title":"Application Management"},{"location":"admin/application-management/#application-management","text":"","title":"Application Management"},{"location":"admin/application-management/#package-installation","text":"After developing your application and generating a deployment package that contains the bundles to be deployed (refer to the Development section for more information), you may install it on the gateway using the Packages option in the System area of the Kura Gateway Administration Console as shown below. The package installation section of the UI Upon a successful installation, the new component appears in the Services list (shown as the BluetoothLE example in these screen captures). Its configuration may be modified according to the defined parameters as shown the BluetoothLe display that follows.","title":"Package Installation"},{"location":"admin/application-management/#installation-from-eclipse-marketplacetm","text":"The application and components in the Eclipse Marketplace\u2122 can be easily installed in Kura dragging the Install button directly to the gray area in the Packages tab, as shown below.","title":"Installation from Eclipse Marketplace\u2122"},{"location":"admin/application-management/#package-signature","text":"Once the selected application deployment package (dp) file is installed, it will be listed in the Packages page and detailed with the name of the deployment package, the version and the signature status. The value of the signature field can be true if all the bundles contained in the deployment package are digitally signed, or false if at least one of the bundles is not signed.","title":"Package Signature"},{"location":"admin/directory-layout/","text":"Directory Layout This section describes the default Kura directory layout that is created upon installation. The default installation directory is as follows: /opt/eclipse The kura sub-directory is a logical link on the actual Kura release directory: kura -> /opt/eclipse/kura_3.0.0_raspberry-pi-2 kura_3.0.0_raspberry-pi-2 Kura File Structure The idea behind the Kura file and folder structure is to separate user and framework configuration files, that is files that can be modified by the user to customize Kura behavior and files that are used by Kura to persist configurations. Moreover, some files are generated at runtime by Kura (i.e. database) and they are kept in specific folders. The user directory contains the files that can be modified by the user (i.e. the configuration for the logging or custom kura properties), while the framework folder keeps the configuration files used by Kura and that shouldn't be modified by the user. The data directory is used to persist files that are generated by Kura. Finally, the plugins folder contains all the jar files needed by Kura. All of the Kura files are located within /opt/eclipse/kura folder using the structure shown in the following table: Directory Description bin Scripts that start Kura. data Data files generated by Kura at runtime. data/persistence Embedded Database files. data/packages Deployment package files that are not part of the standard ESF framework, but are installed at a later time (see Application Management ). framework Configuration data for Kura framework. The user shouldn't directly modify these files. log Log file from the latest Kura installation. plugins All of the libraries and Kura specific jar files needed for the framework execution. user Configuration files generated by the user or by Kura at runtime. These files can be modified by the user to customize the Kura behavior. user/snapshots XML snapshot files; up to 10 successive configurations including the original (see Snapshot Management ). user/security Files used by Kura to configure security. .data Backup files needed to restore factory configuration. Log Files Kura regularly updates two log files in the /var/log directory: /var/log/kura-console.log - stores the standard console output of the application. This log file contains the eventual errors that are thrown upon ESF startup. /var/log/kura.log - stores all of the logging information from ESF bundles. The logger levels are defined in the log4j.xml configuration file as shown below: /opt/eclpse/kura/user/log4j.xml The default logger level in this file is set to INFO. This level may be modified for the whole application or for a specific package as shown in the following example: <Loggers> <Logger name=\"org.eclipse\" level=\"info\" additivity=\"false\"> <AppenderRef ref=\"RollingFile\"/> </Logger> <Logger name=\"org.eclipse.kura.net.admin\" level=\"debug\" additivity=\"false\"> <AppenderRef ref=\"RollingFile\"/> </Logger> <Root level=\"info\"> <AppenderRef ref=\"RollingFile\"/> </Root> </Loggers> In this example, the logger level is set to DEBUG only for the net.admin bundle. Additionally, more specific, properties may be defined as required for your particular logging needs. The logger levels are hierarchical, so that those in a deeper level of the hierarchy will apply; otherwise, the more general logger level will override them. Once the logger levels are modified as needed and the log4j.xml configuration file is saved, Kura automatically loads the new configuration. By default Kura checks the file every 30 seconds.","title":"Directory Layout"},{"location":"admin/directory-layout/#directory-layout","text":"This section describes the default Kura directory layout that is created upon installation. The default installation directory is as follows: /opt/eclipse The kura sub-directory is a logical link on the actual Kura release directory: kura -> /opt/eclipse/kura_3.0.0_raspberry-pi-2 kura_3.0.0_raspberry-pi-2","title":"Directory Layout"},{"location":"admin/directory-layout/#kura-file-structure","text":"The idea behind the Kura file and folder structure is to separate user and framework configuration files, that is files that can be modified by the user to customize Kura behavior and files that are used by Kura to persist configurations. Moreover, some files are generated at runtime by Kura (i.e. database) and they are kept in specific folders. The user directory contains the files that can be modified by the user (i.e. the configuration for the logging or custom kura properties), while the framework folder keeps the configuration files used by Kura and that shouldn't be modified by the user. The data directory is used to persist files that are generated by Kura. Finally, the plugins folder contains all the jar files needed by Kura. All of the Kura files are located within /opt/eclipse/kura folder using the structure shown in the following table: Directory Description bin Scripts that start Kura. data Data files generated by Kura at runtime. data/persistence Embedded Database files. data/packages Deployment package files that are not part of the standard ESF framework, but are installed at a later time (see Application Management ). framework Configuration data for Kura framework. The user shouldn't directly modify these files. log Log file from the latest Kura installation. plugins All of the libraries and Kura specific jar files needed for the framework execution. user Configuration files generated by the user or by Kura at runtime. These files can be modified by the user to customize the Kura behavior. user/snapshots XML snapshot files; up to 10 successive configurations including the original (see Snapshot Management ). user/security Files used by Kura to configure security. .data Backup files needed to restore factory configuration.","title":"Kura File Structure"},{"location":"admin/directory-layout/#log-files","text":"Kura regularly updates two log files in the /var/log directory: /var/log/kura-console.log - stores the standard console output of the application. This log file contains the eventual errors that are thrown upon ESF startup. /var/log/kura.log - stores all of the logging information from ESF bundles. The logger levels are defined in the log4j.xml configuration file as shown below: /opt/eclpse/kura/user/log4j.xml The default logger level in this file is set to INFO. This level may be modified for the whole application or for a specific package as shown in the following example: <Loggers> <Logger name=\"org.eclipse\" level=\"info\" additivity=\"false\"> <AppenderRef ref=\"RollingFile\"/> </Logger> <Logger name=\"org.eclipse.kura.net.admin\" level=\"debug\" additivity=\"false\"> <AppenderRef ref=\"RollingFile\"/> </Logger> <Root level=\"info\"> <AppenderRef ref=\"RollingFile\"/> </Root> </Loggers> In this example, the logger level is set to DEBUG only for the net.admin bundle. Additionally, more specific, properties may be defined as required for your particular logging needs. The logger levels are hierarchical, so that those in a deeper level of the hierarchy will apply; otherwise, the more general logger level will override them. Once the logger levels are modified as needed and the log4j.xml configuration file is saved, Kura automatically loads the new configuration. By default Kura checks the file every 30 seconds.","title":"Log Files"},{"location":"admin/keys-and-certificates/","text":"Keys and Certificates The framework manages directly different key pairs and trusted certificates from different keystores. To simplify the management of such complex objects, the framework provides a dedicated section of its Administrative Web UI, a set of REST APIs for local management and a request handler (KEYS-V1) for cloud remote interaction. Web UI The Certificates List tab in the Security section of the Web UI provides a simple way for the user to get the list of all the managed keys and certificates of the framework: The page allows the user to add a new Keypair or trusted certificate or to delete an existing element. Every key pair or trusted certificate is listed by its alias, identified by the corresponding type and further identified by the keystore that is managing that element. If the user needs to add a new entry to one of the managed KeystoreService instances, can click on the Add button on the top left part of the page. The user will be guided through a process that will allow to identify the type of entry to add: It can be either a: Private/Public Key Pair Trusted Certificate If the user decides to add a key pair, then the wizard will provide a page like the following: Here the user can specify: Key Store : the KeystoreService instance that will store and maintain the key pair Storage Alias : the alias that will be used to identify the key pair Private Key : the private key part of the key pair Certificate : the public key part of the key pair After clicking on the Apply button, the new entry will be stored in the selected Keystore and listed along the other entries managed by the framework. The following cryptographic algorithms are supported for Key Pairs: RSA DSA Instead, if the user wants to load a Trusted Certificate, the Ui will change as follows: Here the user can specify: Key Store : the KeystoreService instance that will store and maintain the trusted certificate Storage Alias : the alias that will be used to identify the trusted certificate Certificate : the trusted certificate The following cryptographic algorithms are supported for Trusted Certificates: RSA DSA EC REST APIs The org.eclipse.kura.core.keystore bundle exposes a REST endpoint under the /services/keystores path. The ESF REST APIs for Keys and Certificates support the following calls and are allowed to any user with rest.keystores permission. Method Path Roles Allowed Encoding Request Parameters Description GET / keystores JSON None Returns the list of all the KeystoreService instances. GET /entries keystores JSON None Returns the list of all the entries managed by the KeystoreService instances. GET /entries?keystoreServicePid={keystoreServicePid} keystores JSON keystoreServicePid Returns the list of all the entries managed by the specified KeystoreService instance. GET /entries?alias={alias} keystores JSON alias Returns the list of all the entries specified by the defined alias and managed in all the available KeystoreService instances in the framework. GET /entries/entry?keystoreServicePid={keystoreServicePid}&alias={alias} keystores JSON keystoreServicePid and alias Returns the entry identified by the specified keystoreServicePid and alias. POST /entries/csr keystores JSON The reference to the key pair in a specified KeystoreService instance that will be used to generate the CSR. The request has to be associated with additional parameters that identify the algorithm used to compute and sign the CSR and the DN or the corresponding public key that needs to be countersigned. Generates a CSR for the specified key pair in the specified KeystoreService instance, based on the parameters provided in the request POST /entries/certificate keystores JSON The reference to the KeystoreService instance and the alias that will be used for storage. A type filed identifies the type of key that needs to be managed. This request allows the user to upload a TrustedCertificate. POST /entries/keypair keystores JSON To generate a new KeyPair directly in the device, the request format need to follow the references in the following paragraphs This request allows the user to generate a new KeyPair into the device. DELETE /entries keystores JSON A JSON identifying the resource to delete. The format of the request is described in in one of the following sections Deletes the entry in the specified KeystoreService instance List All the KeystoreServices Request URL : https:/<gateway-ip>/services/keystores Response [ { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.SSLKeystore\" , \"type\" : \"jks\" , \"size\" : 4 }, { \"keystoreServicePid\" : \"org.eclipse.kura.crypto.CryptoService\" , \"type\" : \"jks\" , \"size\" : 3 }, { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"type\" : \"jks\" , \"size\" : 1 }, { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.DMKeystore\" , \"type\" : \"jks\" , \"size\" : 1 } ] Get all the Managed Entries Request URL : https:/<gateway-ip>/services/keystores/entries Response [ { \"subjectDN\" : \"OU=Go Daddy Class 2 Certification Authority, O=\\\"The Go Daddy Group, Inc.\\\", C=US\" , \"issuer\" : \"OU=Go Daddy Class 2 Certification Authority,O=The Go Daddy Group\\\\, Inc.,C=US\" , \"startDate\" : \"Tue, 29 Jun 2004 17:06:20 GMT\" , \"expirationDate\" : \"Thu, 29 Jun 2034 17:06:20 GMT\" , \"algorithm\" : \"SHA1withRSA\" , \"size\" : 2048 , \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.SSLKeystore\" , \"alias\" : \"ca-godaddyclass2ca\" , \"type\" : \"TRUSTED_CERTIFICATE\" }, { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ] Get All the Entries by KeystoreService Request URL : https:/<gateway-ip>/services/keystores/entries?keystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore Response [ { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ] Get All the Entries by Alias Request URL : https:/<gateway-ip>/services/keystores/entries?alias=localhost Response [ { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ] Get Specific Entry Request URL : https:/<gateway-ip>/services/keystores/entries/entry?keystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore&alias=localhost Response { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } Get the CSR for a KeyPair Request URL : https:/<gateway-ip>/services/keystores/entries/csrkeystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore&alias=localhost Request Body: { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"signatureAlgorithm\" : \"SHA256withRSA\" , \"attributes\" : \"CN=Kura, OU=IoT, O=Eclipse, C=US\" } Store Trusted Certificate Request URL : https:/<gateway-ip>/services/keystores/entries/certificate Request Body: { \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"myCertTest99\" , \"certificate\" : \"-----BEGIN CERTIFICATE----- MIIDdzCCAl+gAwIBAgIEQsO0gDANBgkqhkiG9w0BAQsFADBsMRAwDgYDVQQGEwdV bmtub3duMRAwDgYDVQQIEwdVbmtub3duMRAwDgYDVQQHEwdVbmtub3duMRAwDgYD VQQKEwdVbmtub3duMRAwDgYDVQQLEwdVbmtub3duMRAwDgYDVQQDEwdVbmtub3du MB4XDTIxMDQxNDA4MDIyOFoXDTIxMDcxMzA4MDIyOFowbDEQMA4GA1UEBhMHVW5r bm93bjEQMA4GA1UECBMHVW5rbm93bjEQMA4GA1UEBxMHVW5rbm93bjEQMA4GA1UE ChMHVW5rbm93bjEQMA4GA1UECxMHVW5rbm93bjEQMA4GA1UEAxMHVW5rbm93bjCC ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJSWJDxu8UNC4JGOgK31WCvz NKy2ONH+jTVKnBY7Ckb1hljJY0sKO55aG1HNDfkev2lJTsPIz0nJjNsqBvB1flvf r6XVCxdN0yxvU5g9SpRxE/iiPX0Qt7463OfzyKW97haJrrhF005RHYNcORMY/Phj hFDnZhtAwpbQLzq2UuIZ7okJsx0IgRbjH71ZZuvYCqG7Ct/bp1D7w3tT7gTbIKYH ppQyG9rJDEh9+cr9Hyk8Gz7aAbPT/wMH+/vXDjH2j/M1Tmed0ajuGCJumaTQ4eHs 9xW3B3ugycb6e7Osl/4ESRO5RQL1k2GBONv10OrKDoZ5b66xwSJmC/w3BRWQ1cMC AwEAAaMhMB8wHQYDVR0OBBYEFPospETb5HNeD/DmS9mwt+v/AYq/MA0GCSqGSIb3 DQEBCwUAA4IBAQBxMe1xQVQKt36A5qVlEZyxI9eb6eQRlYzorOgP2tFaOsvDPpRI CALhPmxgQl/5QvKFfCXKoxWj1Spg4sF6fJp6jhSjLpmChS9lf5fRaWS20/pxIddM 10diq3r6HxLKSxCYK7Pf5scOeZquvwfo8Kxye01bvCMFf1s1K3ZEZszk5Oo2MnWU U22YnXfZm1C0h2WMUcou35A7CeVAHPWI0Rvefojv1qYlQScJOkCN5lO6C/1qvRhq nDQdQN/m1HQbpfh2DD6F33nBjkyLQyMRF8uMnspLrLLj8lecSTJZO4fGJOaIXh3O 44da9A02FAf5nRRQpwP2x/4IZ5RTRBzrqbqD -----END CERTIFICATE-----\" } Generate KeyPair Request URL : https:/<gateway-ip>/services/keystores/entries/keypair Request Body: { \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"keypair1\" , \"algorithm\" : \"RSA\" , \"size\" : 1024 , \"signatureAlgorithm\" : \"SHA256WithRSA\" , \"attributes\" : \"CN=Kura, OU=IoT, O=Eclipse, C=US\" } Delete Entry Request URL : https:/<gateway-ip>/services/keystores/entries Request Body: { \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"mycerttestec\" } KEYS-V1 Request Handler Mapping the previously defined REST APIs, the framework exposed to the remote cloud platforms a request handler named KEYS-V1 that allows the remote user to list and manage the keystores, the keys and the certificates in the framework. The request handler exposes also the capability to generate on the edge a CSR that can be countersigned remotely by a trusted CA. More details on the KEYS-V1 format are available in the MQTT Namespace page.","title":"Keys and Certificates"},{"location":"admin/keys-and-certificates/#keys-and-certificates","text":"The framework manages directly different key pairs and trusted certificates from different keystores. To simplify the management of such complex objects, the framework provides a dedicated section of its Administrative Web UI, a set of REST APIs for local management and a request handler (KEYS-V1) for cloud remote interaction.","title":"Keys and Certificates"},{"location":"admin/keys-and-certificates/#web-ui","text":"The Certificates List tab in the Security section of the Web UI provides a simple way for the user to get the list of all the managed keys and certificates of the framework: The page allows the user to add a new Keypair or trusted certificate or to delete an existing element. Every key pair or trusted certificate is listed by its alias, identified by the corresponding type and further identified by the keystore that is managing that element. If the user needs to add a new entry to one of the managed KeystoreService instances, can click on the Add button on the top left part of the page. The user will be guided through a process that will allow to identify the type of entry to add: It can be either a: Private/Public Key Pair Trusted Certificate If the user decides to add a key pair, then the wizard will provide a page like the following: Here the user can specify: Key Store : the KeystoreService instance that will store and maintain the key pair Storage Alias : the alias that will be used to identify the key pair Private Key : the private key part of the key pair Certificate : the public key part of the key pair After clicking on the Apply button, the new entry will be stored in the selected Keystore and listed along the other entries managed by the framework. The following cryptographic algorithms are supported for Key Pairs: RSA DSA Instead, if the user wants to load a Trusted Certificate, the Ui will change as follows: Here the user can specify: Key Store : the KeystoreService instance that will store and maintain the trusted certificate Storage Alias : the alias that will be used to identify the trusted certificate Certificate : the trusted certificate The following cryptographic algorithms are supported for Trusted Certificates: RSA DSA EC","title":"Web UI"},{"location":"admin/keys-and-certificates/#rest-apis","text":"The org.eclipse.kura.core.keystore bundle exposes a REST endpoint under the /services/keystores path. The ESF REST APIs for Keys and Certificates support the following calls and are allowed to any user with rest.keystores permission. Method Path Roles Allowed Encoding Request Parameters Description GET / keystores JSON None Returns the list of all the KeystoreService instances. GET /entries keystores JSON None Returns the list of all the entries managed by the KeystoreService instances. GET /entries?keystoreServicePid={keystoreServicePid} keystores JSON keystoreServicePid Returns the list of all the entries managed by the specified KeystoreService instance. GET /entries?alias={alias} keystores JSON alias Returns the list of all the entries specified by the defined alias and managed in all the available KeystoreService instances in the framework. GET /entries/entry?keystoreServicePid={keystoreServicePid}&alias={alias} keystores JSON keystoreServicePid and alias Returns the entry identified by the specified keystoreServicePid and alias. POST /entries/csr keystores JSON The reference to the key pair in a specified KeystoreService instance that will be used to generate the CSR. The request has to be associated with additional parameters that identify the algorithm used to compute and sign the CSR and the DN or the corresponding public key that needs to be countersigned. Generates a CSR for the specified key pair in the specified KeystoreService instance, based on the parameters provided in the request POST /entries/certificate keystores JSON The reference to the KeystoreService instance and the alias that will be used for storage. A type filed identifies the type of key that needs to be managed. This request allows the user to upload a TrustedCertificate. POST /entries/keypair keystores JSON To generate a new KeyPair directly in the device, the request format need to follow the references in the following paragraphs This request allows the user to generate a new KeyPair into the device. DELETE /entries keystores JSON A JSON identifying the resource to delete. The format of the request is described in in one of the following sections Deletes the entry in the specified KeystoreService instance","title":"REST APIs"},{"location":"admin/keys-and-certificates/#list-all-the-keystoreservices","text":"","title":"List All the KeystoreServices"},{"location":"admin/keys-and-certificates/#request","text":"URL : https:/<gateway-ip>/services/keystores","title":"Request"},{"location":"admin/keys-and-certificates/#response","text":"[ { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.SSLKeystore\" , \"type\" : \"jks\" , \"size\" : 4 }, { \"keystoreServicePid\" : \"org.eclipse.kura.crypto.CryptoService\" , \"type\" : \"jks\" , \"size\" : 3 }, { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"type\" : \"jks\" , \"size\" : 1 }, { \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.DMKeystore\" , \"type\" : \"jks\" , \"size\" : 1 } ]","title":"Response"},{"location":"admin/keys-and-certificates/#get-all-the-managed-entries","text":"","title":"Get all the Managed Entries"},{"location":"admin/keys-and-certificates/#request_1","text":"URL : https:/<gateway-ip>/services/keystores/entries","title":"Request"},{"location":"admin/keys-and-certificates/#response_1","text":"[ { \"subjectDN\" : \"OU=Go Daddy Class 2 Certification Authority, O=\\\"The Go Daddy Group, Inc.\\\", C=US\" , \"issuer\" : \"OU=Go Daddy Class 2 Certification Authority,O=The Go Daddy Group\\\\, Inc.,C=US\" , \"startDate\" : \"Tue, 29 Jun 2004 17:06:20 GMT\" , \"expirationDate\" : \"Thu, 29 Jun 2034 17:06:20 GMT\" , \"algorithm\" : \"SHA1withRSA\" , \"size\" : 2048 , \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.SSLKeystore\" , \"alias\" : \"ca-godaddyclass2ca\" , \"type\" : \"TRUSTED_CERTIFICATE\" }, { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ]","title":"Response"},{"location":"admin/keys-and-certificates/#get-all-the-entries-by-keystoreservice","text":"","title":"Get All the Entries by KeystoreService"},{"location":"admin/keys-and-certificates/#request_2","text":"URL : https:/<gateway-ip>/services/keystores/entries?keystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore","title":"Request"},{"location":"admin/keys-and-certificates/#response_2","text":"[ { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ]","title":"Response"},{"location":"admin/keys-and-certificates/#get-all-the-entries-by-alias","text":"","title":"Get All the Entries by Alias"},{"location":"admin/keys-and-certificates/#request_3","text":"URL : https:/<gateway-ip>/services/keystores/entries?alias=localhost","title":"Request"},{"location":"admin/keys-and-certificates/#response_3","text":"[ { \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" } ]","title":"Response"},{"location":"admin/keys-and-certificates/#get-specific-entry","text":"","title":"Get Specific Entry"},{"location":"admin/keys-and-certificates/#request_4","text":"URL : https:/<gateway-ip>/services/keystores/entries/entry?keystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore&alias=localhost","title":"Request"},{"location":"admin/keys-and-certificates/#response_4","text":"{ \"algorithm\" : \"RSA\" , \"size\" : 4096 , \"certificateChain\" : [ \"-----BEGIN CERTIFICATE-----\\nMIIFkTCCA3mgAwIBAgIECtXoiDANBgkqhkiG9w0BAQsFADBZMQswCQYDVQQGEwJJ\\nVDELMAkGA1UECBMCVUQxDjAMBgNVBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVj\\naDEMMAoGA1UECxMDRVNGMQwwCgYDVQQDEwNFU0YwHhcNMjEwNDIyMTUxNTU1WhcN\\nMjQwMTE3MTUxNTU1WjBZMQswCQYDVQQGEwJJVDELMAkGA1UECBMCVUQxDjAMBgNV\\nBAcTBUFtYXJvMREwDwYDVQQKEwhFdXJvdGVjaDEMMAoGA1UECxMDRVNGMQwwCgYD\\nVQQDEwNFU0YwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7iZ3fHUQa\\nTPgnvSxGZK4f6MZYfLclD74yqaCCWAztNxPQoiBoSPGdsBGBLNeFbwY0Yzg3qwXw\\nYvgzLJmoXV9rSix7LgXPzsSYfUGfu7PeYTy5bG9X2UVyw9LloUM5DKnw++5F7Xy7\\nF0KQQi0z6/HbbPkZ2aGyNRtMCTh1iAGy3gDh/mMnjpUYuoq1luoX1x6I77X0C+NP\\nTxldVYrTeQiswItAHZmkK1R8AYedbFBgjDuTrfRODxBwESn4kQSMLJ8yHYDRm8S6\\ngVz5LdkcM48UiV5hhF+bCD3UvYA00ZgZm2oOG1ONchYrE7pJr7eQVCYaXkS1lALB\\nKaVJzn03wiLJJv1FYLmGt5J/MwfqyCtBTLlieEVfwnxFCkymtews6SYK32e9q/uJ\\nfcdpWH7tOoarnAf7j5mE84rRU3HqzghK0bMxntfrSH3t18ZUt1/4Qx78WfiM1Te3\\nJtnWBqUNJtX6lgT8IxTWwyEqD183tyKIo8hPGyeJrzWA5RL5hYF5rCNTWzqz5Upi\\n0b/YI5K09+Rn8XmEzzaWjFq5zu6/WpqwPRA8kc2RAEA2scnOT+3yl9Lof/M7BrfL\\nMdjVOZ4MfXgl/fhFyd16AObXuZRUIeiWowKtEiNaiUn8paLDxG+LNV7p5wEQCZZI\\n+MsXMMp6G8Te4yILLCcGov7OkO2wx4GPWQIDAQABo2EwXzAxBgNVHSUEKjAoBggr\\nBgEFBQcDAQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDCDALBgNVHQ8EBAMC\\nAvwwHQYDVR0OBBYEFKM5PlHoe8qFC6w0quGacazGWE/LMA0GCSqGSIb3DQEBCwUA\\nA4ICAQBvpXmbS9LN8n0A+uq+tM3CNtF3YotWRbQHIGJAFTvdq3003W3CVdmykFc8\\n9Kz8PoY1swBJms7GKjQLkqgTHoq6jU/cIXw+CoLQWmvAugva5C1u/5AHJZqTC06J\\nGZyn1Z9N5Lp0XcgogEyhxdbkHniv7jvcmbCurQijZc9nsd5St7e1pT0Co7KKI6Ff\\nODdVP6kZYBzKo4t20tATdAZJ8t7YHNKNq7ZVs1ej9oYUmmQieNXuE4UoHe5hzVQw\\n567cNHWcTHJoyPve03TSQV91wp5rRUKZm2p0WtFNuv22f5p5sQmttsJltzHCgTwE\\nK0j6qYKnXiq+EQs0A3uF9uiIB/KEDLjxscstqsQGFCFOmjA3GSbmJiKCnss3HkNn\\naknT7XCV6tqgDOfPnNzbWJODjYZ+V0DyNY5uqkG2cyREm/qGbH1kLEXhqdWbKqEs\\nsdW6x8p0ImTaPuRl3XEmXbolavIq+FTtOSz8vW1PsdD3quO6krrwiQMXKv1ZMjup\\nDGIZZ4hUUhN84efjlZyoFRvPRvZ8YvjjrHXLij0vcRxndlicevwl5ezlm0LBOpsT\\nkI2uWrbSbxlue/XdgwFCbN0+mXX88fGj6cjhpvd/xnwHaDHfSG9UoU149LJb6ZIZ\\nru+07QriQQxK8V7AdPr6bhmKPxbbFenvSQmsmgjAY93qtanbNg==\\n-----END CERTIFICATE-----\" ], \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"type\" : \"PRIVATE_KEY\" }","title":"Response"},{"location":"admin/keys-and-certificates/#get-the-csr-for-a-keypair","text":"","title":"Get the CSR for a KeyPair"},{"location":"admin/keys-and-certificates/#request_5","text":"URL : https:/<gateway-ip>/services/keystores/entries/csrkeystoreServicePid=org.eclipse.kura.core.keystore.HttpsKeystore&alias=localhost","title":"Request"},{"location":"admin/keys-and-certificates/#request-body","text":"{ \"keystoreServicePid\" : \"org.eclipse.kura.core.keystore.HttpsKeystore\" , \"alias\" : \"localhost\" , \"signatureAlgorithm\" : \"SHA256withRSA\" , \"attributes\" : \"CN=Kura, OU=IoT, O=Eclipse, C=US\" }","title":"Request Body:"},{"location":"admin/keys-and-certificates/#store-trusted-certificate","text":"","title":"Store Trusted Certificate"},{"location":"admin/keys-and-certificates/#request_6","text":"URL : https:/<gateway-ip>/services/keystores/entries/certificate","title":"Request"},{"location":"admin/keys-and-certificates/#request-body_1","text":"{ \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"myCertTest99\" , \"certificate\" : \"-----BEGIN CERTIFICATE----- MIIDdzCCAl+gAwIBAgIEQsO0gDANBgkqhkiG9w0BAQsFADBsMRAwDgYDVQQGEwdV bmtub3duMRAwDgYDVQQIEwdVbmtub3duMRAwDgYDVQQHEwdVbmtub3duMRAwDgYD VQQKEwdVbmtub3duMRAwDgYDVQQLEwdVbmtub3duMRAwDgYDVQQDEwdVbmtub3du MB4XDTIxMDQxNDA4MDIyOFoXDTIxMDcxMzA4MDIyOFowbDEQMA4GA1UEBhMHVW5r bm93bjEQMA4GA1UECBMHVW5rbm93bjEQMA4GA1UEBxMHVW5rbm93bjEQMA4GA1UE ChMHVW5rbm93bjEQMA4GA1UECxMHVW5rbm93bjEQMA4GA1UEAxMHVW5rbm93bjCC ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJSWJDxu8UNC4JGOgK31WCvz NKy2ONH+jTVKnBY7Ckb1hljJY0sKO55aG1HNDfkev2lJTsPIz0nJjNsqBvB1flvf r6XVCxdN0yxvU5g9SpRxE/iiPX0Qt7463OfzyKW97haJrrhF005RHYNcORMY/Phj hFDnZhtAwpbQLzq2UuIZ7okJsx0IgRbjH71ZZuvYCqG7Ct/bp1D7w3tT7gTbIKYH ppQyG9rJDEh9+cr9Hyk8Gz7aAbPT/wMH+/vXDjH2j/M1Tmed0ajuGCJumaTQ4eHs 9xW3B3ugycb6e7Osl/4ESRO5RQL1k2GBONv10OrKDoZ5b66xwSJmC/w3BRWQ1cMC AwEAAaMhMB8wHQYDVR0OBBYEFPospETb5HNeD/DmS9mwt+v/AYq/MA0GCSqGSIb3 DQEBCwUAA4IBAQBxMe1xQVQKt36A5qVlEZyxI9eb6eQRlYzorOgP2tFaOsvDPpRI CALhPmxgQl/5QvKFfCXKoxWj1Spg4sF6fJp6jhSjLpmChS9lf5fRaWS20/pxIddM 10diq3r6HxLKSxCYK7Pf5scOeZquvwfo8Kxye01bvCMFf1s1K3ZEZszk5Oo2MnWU U22YnXfZm1C0h2WMUcou35A7CeVAHPWI0Rvefojv1qYlQScJOkCN5lO6C/1qvRhq nDQdQN/m1HQbpfh2DD6F33nBjkyLQyMRF8uMnspLrLLj8lecSTJZO4fGJOaIXh3O 44da9A02FAf5nRRQpwP2x/4IZ5RTRBzrqbqD -----END CERTIFICATE-----\" }","title":"Request Body:"},{"location":"admin/keys-and-certificates/#generate-keypair","text":"","title":"Generate KeyPair"},{"location":"admin/keys-and-certificates/#request_7","text":"URL : https:/<gateway-ip>/services/keystores/entries/keypair","title":"Request"},{"location":"admin/keys-and-certificates/#request-body_2","text":"{ \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"keypair1\" , \"algorithm\" : \"RSA\" , \"size\" : 1024 , \"signatureAlgorithm\" : \"SHA256WithRSA\" , \"attributes\" : \"CN=Kura, OU=IoT, O=Eclipse, C=US\" }","title":"Request Body:"},{"location":"admin/keys-and-certificates/#delete-entry","text":"","title":"Delete Entry"},{"location":"admin/keys-and-certificates/#request_8","text":"URL : https:/<gateway-ip>/services/keystores/entries","title":"Request"},{"location":"admin/keys-and-certificates/#request-body_3","text":"{ \"keystoreServicePid\" : \"MyKeystore\" , \"alias\" : \"mycerttestec\" }","title":"Request Body:"},{"location":"admin/keys-and-certificates/#keys-v1-request-handler","text":"Mapping the previously defined REST APIs, the framework exposed to the remote cloud platforms a request handler named KEYS-V1 that allows the remote user to list and manage the keystores, the keys and the certificates in the framework. The request handler exposes also the capability to generate on the edge a CSR that can be countersigned remotely by a trusted CA. More details on the KEYS-V1 format are available in the MQTT Namespace page.","title":"KEYS-V1 Request Handler"},{"location":"admin/keystore-management/","text":"Keystores Management The framework manages different types of cryptographic keys and certificates. In order to simplify the interaction with those objects, Kura provides a KeystoreService API and a specific section in the Web UI that lists all the available KeystoreService instances. From the Security section, a user with Security permissions can access the Keystore Configuration section. A list of all the framework managed keystores will be available to the user with the Service PID that will be used by other components to reference the selected keystore. Associated to the Service PID, the UI shows the Factory PID that identifies the specific KeystoreService API implementation that is providing the service to the framework. In order to modify the configuration of a specific keystore service instance, the user can select one of the available rows, obtaining the corresponding keystore service configuration. For the org.eclipse.kura.core.keystore.KeystoreServiceImpl factory, the user can customise the following options: Keystore Path : identifies the path in the filesystem. The value should reference an existing keystore. The value cannot be empty. Keystore Password : the corresponding keystore password Randomize Password : a boolean flag that allows the user to specify if the keystore password needs to be randomised at the next framework boot. If set true, the framework will try to access the identified keystore and randomise the password. The new password will be persisted in the framework snapshot. Once successfully randomised, the flag will be automatically set to false by the framework.","title":"Keystores Management"},{"location":"admin/keystore-management/#keystores-management","text":"The framework manages different types of cryptographic keys and certificates. In order to simplify the interaction with those objects, Kura provides a KeystoreService API and a specific section in the Web UI that lists all the available KeystoreService instances. From the Security section, a user with Security permissions can access the Keystore Configuration section. A list of all the framework managed keystores will be available to the user with the Service PID that will be used by other components to reference the selected keystore. Associated to the Service PID, the UI shows the Factory PID that identifies the specific KeystoreService API implementation that is providing the service to the framework. In order to modify the configuration of a specific keystore service instance, the user can select one of the available rows, obtaining the corresponding keystore service configuration. For the org.eclipse.kura.core.keystore.KeystoreServiceImpl factory, the user can customise the following options: Keystore Path : identifies the path in the filesystem. The value should reference an existing keystore. The value cannot be empty. Keystore Password : the corresponding keystore password Randomize Password : a boolean flag that allows the user to specify if the keystore password needs to be randomised at the next framework boot. If set true, the framework will try to access the identified keystore and randomise the password. The new password will be persisted in the framework snapshot. Once successfully randomised, the flag will be automatically set to false by the framework.","title":"Keystores Management"},{"location":"admin/remote-management-with-ec/","text":"Remote Management with Everyware Cloud Built-in Services Management This section describes the remote management of devices running Kura via Everyware Cloud Console. The Everyware Cloud Console provides the administration tools used for the management of the built-in services exposed by Kura. To remotely manage a device running Kura through the Everyware Cloud Console, select the desired device from the Devices Table of the console and open the Configuration tab as shown in the screen capture below. Please refer to the Built-in Services section for a description of the available Services and their configuration parameters. Installation of a New Application As described in Application Management , a new application embedded in a deployment package can be deployed and configured using Everyware Cloud Console. To do so, select a connected device and click on the Packages tab. Then, click on Install/Upgrade . The Install New Package window opens allowing the deployment package to be installed from a local disk ( File ) or from a distant URL ( URL ) as shown in the screen capture below. Once installed, the new application parameters may be modified in the same way as the Built-in Services. Click on the Configuration tab to see the service that corresponds to your application. Snapshots As described in Snapshot Management , the overall Kura configuration, including the new installed applications, is stored in a snapshot xml file. The Everyware Cloud Console also provides options to Download , Upload and Apply , or Rollback snapshots as shown in the screen capture below. Remote Command Execution from Everyware Cloud Console The Everyware Cloud Console provides the ability to run system commands directly on the device. Refer to Command Service for details on how to configure this service in Kura. It is also possible to send a script to execute using the File option of the Command tab in Everyware Cloud Console as shown in the screen capture below. This script must be compressed into a zip file with the eventual associated resource files. Once the file is selected, click Execute . The zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered.","title":"Remote Management with Everyware Cloud"},{"location":"admin/remote-management-with-ec/#remote-management-with-everyware-cloud","text":"","title":"Remote Management with Everyware Cloud"},{"location":"admin/remote-management-with-ec/#built-in-services-management","text":"This section describes the remote management of devices running Kura via Everyware Cloud Console. The Everyware Cloud Console provides the administration tools used for the management of the built-in services exposed by Kura. To remotely manage a device running Kura through the Everyware Cloud Console, select the desired device from the Devices Table of the console and open the Configuration tab as shown in the screen capture below. Please refer to the Built-in Services section for a description of the available Services and their configuration parameters.","title":"Built-in Services Management"},{"location":"admin/remote-management-with-ec/#installation-of-a-new-application","text":"As described in Application Management , a new application embedded in a deployment package can be deployed and configured using Everyware Cloud Console. To do so, select a connected device and click on the Packages tab. Then, click on Install/Upgrade . The Install New Package window opens allowing the deployment package to be installed from a local disk ( File ) or from a distant URL ( URL ) as shown in the screen capture below. Once installed, the new application parameters may be modified in the same way as the Built-in Services. Click on the Configuration tab to see the service that corresponds to your application.","title":"Installation of a New Application"},{"location":"admin/remote-management-with-ec/#snapshots","text":"As described in Snapshot Management , the overall Kura configuration, including the new installed applications, is stored in a snapshot xml file. The Everyware Cloud Console also provides options to Download , Upload and Apply , or Rollback snapshots as shown in the screen capture below.","title":"Snapshots"},{"location":"admin/remote-management-with-ec/#remote-command-execution-from-everyware-cloud-console","text":"The Everyware Cloud Console provides the ability to run system commands directly on the device. Refer to Command Service for details on how to configure this service in Kura. It is also possible to send a script to execute using the File option of the Command tab in Everyware Cloud Console as shown in the screen capture below. This script must be compressed into a zip file with the eventual associated resource files. Once the file is selected, click Execute . The zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered.","title":"Remote Command Execution from Everyware Cloud Console"},{"location":"admin/remote-management-with-kapua/","text":"Remote Management with Eclipse Kapua Built-in Services Management This section describes the remote management of devices running Kura via Eclipse Kapua Console. The Eclipse Kapua Web Console provides the administration tools used for the management of the built-in services exposed by Kura. To remotely manage a device running Kura through the Eclipse Kapua Web Console, select the desired device from the Devices Table of the console and open the Configuration tab as shown in the screen capture below. Please refer to the Built-in Services section for a description of the available Services and their configuration parameters. Installation of a New Application As described in Application Management , a new application embedded in a deployment package can be deployed and configured using Eclipse Kapua Console. To do so, select a connected device and click on the Packages tab. Then, click on Install/Upgrade . The Install New Package window opens allowing the deployment package to be installed from an URL as shown in the screen capture below. Once installed, the new application parameters may be modified in the same way as the Built-in Services. Click on the Configuration tab to see the service that corresponds to your application. Snapshots As described in Snapshot Management , the overall Kura configuration, including the new installed applications, is stored in a snapshot xml file. The Eclipse Kapua Console also provides options to Download , Upload and Apply , or Rollback snapshots as shown in the screen capture below. Remote Command Execution from Eclipse Kapua Web Console The Eclipse Kapua Console provides the ability to run system commands directly on the device. Refer to Command Service for details on how to configure this service in Kura. It is also possible to send a script to execute using the File option of the Command tab in Eclipse Kapua Console as shown in the screen capture below. This script must be compressed into a zip file with the eventual associated resource files. Once the file is selected, click Execute . The zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered.","title":"Remote Management with Eclipse Kapua"},{"location":"admin/remote-management-with-kapua/#remote-management-with-eclipse-kapua","text":"","title":"Remote Management with Eclipse Kapua"},{"location":"admin/remote-management-with-kapua/#built-in-services-management","text":"This section describes the remote management of devices running Kura via Eclipse Kapua Console. The Eclipse Kapua Web Console provides the administration tools used for the management of the built-in services exposed by Kura. To remotely manage a device running Kura through the Eclipse Kapua Web Console, select the desired device from the Devices Table of the console and open the Configuration tab as shown in the screen capture below. Please refer to the Built-in Services section for a description of the available Services and their configuration parameters.","title":"Built-in Services Management"},{"location":"admin/remote-management-with-kapua/#installation-of-a-new-application","text":"As described in Application Management , a new application embedded in a deployment package can be deployed and configured using Eclipse Kapua Console. To do so, select a connected device and click on the Packages tab. Then, click on Install/Upgrade . The Install New Package window opens allowing the deployment package to be installed from an URL as shown in the screen capture below. Once installed, the new application parameters may be modified in the same way as the Built-in Services. Click on the Configuration tab to see the service that corresponds to your application.","title":"Installation of a New Application"},{"location":"admin/remote-management-with-kapua/#snapshots","text":"As described in Snapshot Management , the overall Kura configuration, including the new installed applications, is stored in a snapshot xml file. The Eclipse Kapua Console also provides options to Download , Upload and Apply , or Rollback snapshots as shown in the screen capture below.","title":"Snapshots"},{"location":"admin/remote-management-with-kapua/#remote-command-execution-from-eclipse-kapua-web-console","text":"The Eclipse Kapua Console provides the ability to run system commands directly on the device. Refer to Command Service for details on how to configure this service in Kura. It is also possible to send a script to execute using the File option of the Command tab in Eclipse Kapua Console as shown in the screen capture below. This script must be compressed into a zip file with the eventual associated resource files. Once the file is selected, click Execute . The zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered.","title":"Remote Command Execution from Eclipse Kapua Web Console"},{"location":"admin/snapshot-management/","text":"Snapshot Management The overall configuration of Kura is stored in an XML file called a snapshot. This file includes all of the parameters for every service running in Kura. The original configuration file is named snapshot_0.xml . This section describes how snapshots may be used. Each time a configuration change is made to one of the Kura components, a new XML file is created using the naming convention snapshot_[time as a long integer].xml . The nine most recent snapshots are saved, as well as the original snapshot 0. How to Access Snapshots To display snapshots using the Gateway Administration Console , select Settings from the System area, and then click on the Snapshots tab. The following three operations are available: Download , Upload and Apply , and Rollback . How to Use Snapshots Download The Download option provides the ability to save a snapshot XML file onto your computer. This file may then be edited, uploaded back to the device, or transferred to another equivalent device. Upload and Apply The Upload and Apply option provides the ability to import an XML file from your computer and upload it onto the device. This function updates every service in Kura with the parameters defined in the XML file. Carefully select the file to be uploaded. An incorrect file may crash Kura and make it unresponsive. Rollback The Rollback option provides the ability to restore the system to a previous configuration.","title":"Snapshots Management"},{"location":"admin/snapshot-management/#snapshot-management","text":"The overall configuration of Kura is stored in an XML file called a snapshot. This file includes all of the parameters for every service running in Kura. The original configuration file is named snapshot_0.xml . This section describes how snapshots may be used. Each time a configuration change is made to one of the Kura components, a new XML file is created using the naming convention snapshot_[time as a long integer].xml . The nine most recent snapshots are saved, as well as the original snapshot 0.","title":"Snapshot Management"},{"location":"admin/snapshot-management/#how-to-access-snapshots","text":"To display snapshots using the Gateway Administration Console , select Settings from the System area, and then click on the Snapshots tab. The following three operations are available: Download , Upload and Apply , and Rollback .","title":"How to Access Snapshots"},{"location":"admin/snapshot-management/#how-to-use-snapshots","text":"","title":"How to Use Snapshots"},{"location":"admin/snapshot-management/#download","text":"The Download option provides the ability to save a snapshot XML file onto your computer. This file may then be edited, uploaded back to the device, or transferred to another equivalent device.","title":"Download"},{"location":"admin/snapshot-management/#upload-and-apply","text":"The Upload and Apply option provides the ability to import an XML file from your computer and upload it onto the device. This function updates every service in Kura with the parameters defined in the XML file. Carefully select the file to be uploaded. An incorrect file may crash Kura and make it unresponsive.","title":"Upload and Apply"},{"location":"admin/snapshot-management/#rollback","text":"The Rollback option provides the ability to restore the system to a previous configuration.","title":"Rollback"},{"location":"builtin/activemq-artemis-broker-service/","text":"ActiveMQ Artemis Broker Service Apart from using the simple ActiveMQ Artemis MQTT instance available in the Simple Artemis MQTT Broker Service this service allows user to configure, in a more detailed way, the characteristics of the ActiveMQ Artemis broker instance running in Eclipse Kura. This service exposes the following configuration parameters: Enabled - (Required) - Enables the broker instance Broker XML - Broker XML configuration. An empty broker configuration will disable the broker. Required protocols - A comma separated list of all required protocol factories (e.g. AMQP or MQTT) User configuration - (Required) - User configuration in the format: user=password|role1,role2,... Default user name - The name of the default user Please refer to the official documentation for more details on how to configure the ActiveMQ broker service. Service Usage Example Setting the Broker XML field as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration xmlns= \"urn:activemq\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \" urn:activemq https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-server/src/main/resources/schema/artemis-server.xsd urn:activemq:core https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-server/src/main/resources/schema/artemis-configuration.xsd urn:activemq:jms https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-jms-server/src/main/resources/schema/artemis-jms.xsd \" > <core xmlns= \"urn:activemq:core\" > <persistence-enabled> false </persistence-enabled> <acceptors> <acceptor name= \"netty-acceptor\" > tcp://localhost:61616 </acceptor> <acceptor name= \"amqp-acceptor\" > tcp://localhost:5672?protocols=AMQP </acceptor> <acceptor name= \"mqtt-acceptor\" > tcp://localhost:1883?protocols=MQTT </acceptor> </acceptors> <resolve-protocols> false </resolve-protocols> <security-settings> <!-- WARNING: this is only for testing and completely insecure --> <security-setting match= \"#\" > <permission type= \"createDurableQueue\" roles= \"guest\" /> <permission type= \"deleteDurableQueue\" roles= \"guest\" /> <permission type= \"createNonDurableQueue\" roles= \"guest\" /> <permission type= \"deleteNonDurableQueue\" roles= \"guest\" /> <permission type= \"consume\" roles= \"guest\" /> <permission type= \"send\" roles= \"guest\" /> </security-setting> </security-settings> </core> <jms xmlns= \"urn:activemq:jms\" > <topic name= \"TEST.T.1\" /> </jms> </configuration> the User configuration to guest=test12|guest while setting the Default user name to guest will determine that the TCP ports 1883, 5672 and 61616 are now open (you can verify that via netstat -antup ). Configuring the MqttDataTransport in System -> Cloud Services -> MqttDataTransport to use: broker-url - mqtt://localhost:1883 username - guest password - test12 Clicking on the Connect button will result in a successful connection of Kura cloud service to the Apache ActiveMQ Artemis MQTT broker. Note: The XML configuration above only allows connections originating from the gateway itself. In order to allow external connection the bind URLs specified using the acceptor tag must be modified by specifying an externally accessible address instead of localhost . If the bind address is set to 0.0.0.0 , the broker will listen on all available addresses.","title":"ActiveMQ Artemis Broker Service"},{"location":"builtin/activemq-artemis-broker-service/#activemq-artemis-broker-service","text":"Apart from using the simple ActiveMQ Artemis MQTT instance available in the Simple Artemis MQTT Broker Service this service allows user to configure, in a more detailed way, the characteristics of the ActiveMQ Artemis broker instance running in Eclipse Kura. This service exposes the following configuration parameters: Enabled - (Required) - Enables the broker instance Broker XML - Broker XML configuration. An empty broker configuration will disable the broker. Required protocols - A comma separated list of all required protocol factories (e.g. AMQP or MQTT) User configuration - (Required) - User configuration in the format: user=password|role1,role2,... Default user name - The name of the default user Please refer to the official documentation for more details on how to configure the ActiveMQ broker service.","title":"ActiveMQ Artemis Broker Service"},{"location":"builtin/activemq-artemis-broker-service/#service-usage-example","text":"Setting the Broker XML field as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration xmlns= \"urn:activemq\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \" urn:activemq https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-server/src/main/resources/schema/artemis-server.xsd urn:activemq:core https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-server/src/main/resources/schema/artemis-configuration.xsd urn:activemq:jms https://raw.githubusercontent.com/apache/activemq-artemis/master/artemis-jms-server/src/main/resources/schema/artemis-jms.xsd \" > <core xmlns= \"urn:activemq:core\" > <persistence-enabled> false </persistence-enabled> <acceptors> <acceptor name= \"netty-acceptor\" > tcp://localhost:61616 </acceptor> <acceptor name= \"amqp-acceptor\" > tcp://localhost:5672?protocols=AMQP </acceptor> <acceptor name= \"mqtt-acceptor\" > tcp://localhost:1883?protocols=MQTT </acceptor> </acceptors> <resolve-protocols> false </resolve-protocols> <security-settings> <!-- WARNING: this is only for testing and completely insecure --> <security-setting match= \"#\" > <permission type= \"createDurableQueue\" roles= \"guest\" /> <permission type= \"deleteDurableQueue\" roles= \"guest\" /> <permission type= \"createNonDurableQueue\" roles= \"guest\" /> <permission type= \"deleteNonDurableQueue\" roles= \"guest\" /> <permission type= \"consume\" roles= \"guest\" /> <permission type= \"send\" roles= \"guest\" /> </security-setting> </security-settings> </core> <jms xmlns= \"urn:activemq:jms\" > <topic name= \"TEST.T.1\" /> </jms> </configuration> the User configuration to guest=test12|guest while setting the Default user name to guest will determine that the TCP ports 1883, 5672 and 61616 are now open (you can verify that via netstat -antup ). Configuring the MqttDataTransport in System -> Cloud Services -> MqttDataTransport to use: broker-url - mqtt://localhost:1883 username - guest password - test12 Clicking on the Connect button will result in a successful connection of Kura cloud service to the Apache ActiveMQ Artemis MQTT broker. Note: The XML configuration above only allows connections originating from the gateway itself. In order to allow external connection the bind URLs specified using the acceptor tag must be modified by specifying an externally accessible address instead of localhost . If the bind address is set to 0.0.0.0 , the broker will listen on all available addresses.","title":"Service Usage Example"},{"location":"builtin/clock-service/","text":"Clock Service The ClockService handles the date and time management of the system. If enabled, it tries to update the system date and time using a Network Time Protocol (NTP) server. NTP can use NTS as authentication mechanism through chrony. To manage the system date and time, select the ClockService option located in the Services area as shown in the screen capture below. The ClockService provides the following configuration parameters: enabled - sets whether or not this service is enabled or disabled. (Required field.) clock.set.hwclock - defines if the hardware clock of the gateway must be synced after the system time is set. If enabled, the service calls the Linux command \"hwclock --utc --systohc\". clock.provider - specifies one among Java NTP client (java-ntp), Linux chrony command (chrony), Linux ntpdate command (ntpd). (Required field.) If chrony-advanced is used, Kura will not change system and/or hardware clock directly, delegating these operations to chrony. clock.ntp.host - sets a valid NTP server host address. clock.ntp.port - sets a valid NTP port number. clock.ntp.timeout - specifies the NTP timeout in milliseconds. clock.ntp.max-retry - defines the number of retries when a sync fails (retry at every minute). Subsequently, the next retry occurs on the next refresh interval. clock.ntp.retry.interval - defines the interval in seconds between each retry when a sync fails. If the clock.ntp.refresh-interval parameter is less than zero, there is no update. If the clock.ntp.refresh-interval parameter is equal to zero, there is only one try at startup. (Required field.) clock.ntp.refresh-interval - defines the frequency (in seconds) at which the service tries to sync the clock. Note that at the start of ESF, when the ClockService is enabled, it tries to sync the clock every minute until it is successful. After a successful sync, this operation is performed at the frequency defined by this parameter. If the value is less than zero, there is no update. If the value is equal to zero, syncs only once at startup. chrony.advanced.config - specifies the content of the chrony configuration file. If this field is left blank, the default system configuration will be used. To obtain the hardware clock synchronization the directive rtcsync could be used. The rtcsync directive provides the hardware clock synchronization made by the linux kernel every 11 minutes. For further information: chrony website Chrony is not available for Rock960 board. Two example configuration are shown below: NTS Secure configuration example ^1 server time.cloudflare.com iburst nts server nts.sth1.ntp.se iburst nts server nts.sth2.ntp.se iburst nts sourcedir /etc/chrony/sources.d driftfile /var/lib/chrony/chrony.drift logdir /var/log/chrony maxupdateskew 100.0 rtcsync makestep 1 3 leapsectz right/UTC If the system clock is wrong there is the possibility of a synchronization failure due the inability to verify the server certificate. To temporary disable the certificate verification the directive nocerttimecheck could be used with a value greater then 0. ^3 Eg: nocerttimecheck 1 Simple configuration example ^2 # Use public NTP servers from the pool.ntp.org project. pool pool.ntp.org iburst # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Allow the system clock to be stepped in the first three updates # if its offset is larger than 1 second. makestep 1.0 3 # Enable kernel synchronization of the real-time clock (RTC). rtcsync","title":"Clock Service"},{"location":"builtin/clock-service/#clock-service","text":"The ClockService handles the date and time management of the system. If enabled, it tries to update the system date and time using a Network Time Protocol (NTP) server. NTP can use NTS as authentication mechanism through chrony. To manage the system date and time, select the ClockService option located in the Services area as shown in the screen capture below. The ClockService provides the following configuration parameters: enabled - sets whether or not this service is enabled or disabled. (Required field.) clock.set.hwclock - defines if the hardware clock of the gateway must be synced after the system time is set. If enabled, the service calls the Linux command \"hwclock --utc --systohc\". clock.provider - specifies one among Java NTP client (java-ntp), Linux chrony command (chrony), Linux ntpdate command (ntpd). (Required field.) If chrony-advanced is used, Kura will not change system and/or hardware clock directly, delegating these operations to chrony. clock.ntp.host - sets a valid NTP server host address. clock.ntp.port - sets a valid NTP port number. clock.ntp.timeout - specifies the NTP timeout in milliseconds. clock.ntp.max-retry - defines the number of retries when a sync fails (retry at every minute). Subsequently, the next retry occurs on the next refresh interval. clock.ntp.retry.interval - defines the interval in seconds between each retry when a sync fails. If the clock.ntp.refresh-interval parameter is less than zero, there is no update. If the clock.ntp.refresh-interval parameter is equal to zero, there is only one try at startup. (Required field.) clock.ntp.refresh-interval - defines the frequency (in seconds) at which the service tries to sync the clock. Note that at the start of ESF, when the ClockService is enabled, it tries to sync the clock every minute until it is successful. After a successful sync, this operation is performed at the frequency defined by this parameter. If the value is less than zero, there is no update. If the value is equal to zero, syncs only once at startup. chrony.advanced.config - specifies the content of the chrony configuration file. If this field is left blank, the default system configuration will be used. To obtain the hardware clock synchronization the directive rtcsync could be used. The rtcsync directive provides the hardware clock synchronization made by the linux kernel every 11 minutes. For further information: chrony website Chrony is not available for Rock960 board. Two example configuration are shown below: NTS Secure configuration example ^1 server time.cloudflare.com iburst nts server nts.sth1.ntp.se iburst nts server nts.sth2.ntp.se iburst nts sourcedir /etc/chrony/sources.d driftfile /var/lib/chrony/chrony.drift logdir /var/log/chrony maxupdateskew 100.0 rtcsync makestep 1 3 leapsectz right/UTC If the system clock is wrong there is the possibility of a synchronization failure due the inability to verify the server certificate. To temporary disable the certificate verification the directive nocerttimecheck could be used with a value greater then 0. ^3 Eg: nocerttimecheck 1 Simple configuration example ^2 # Use public NTP servers from the pool.ntp.org project. pool pool.ntp.org iburst # Record the rate at which the system clock gains/losses time. driftfile /var/lib/chrony/drift # Allow the system clock to be stepped in the first three updates # if its offset is larger than 1 second. makestep 1.0 3 # Enable kernel synchronization of the real-time clock (RTC). rtcsync","title":"Clock Service"},{"location":"builtin/cloudcat/","text":"Cloudcat The CloudCat Service replicates messages published to one CloudService instance to another one, performing the following operations: The service obtains two CloudClients from two different CloudService instances specified in the service configuration. For each CloudClient, the service subscribes to a set of topics specified in the configuration. Message received by the service on one of the two CloudClients will be re-published on the other one. This service allows for example to share an existing cloud connection to external applications using the Artemis broker. An example of this use case will be presented below. Instance creation In order to create an instance of the CloudCat component perform the following steps: Press the + button under Services in the Kura Web UI. Select org.eclipse.kura.misc.cloudcat.CloudCat from the Factory drop down list. Enter a unique name for the new instance in the Name field and press Apply . Service configuration In order to review the configuration of a CloudCat instance, click on the corresponding entry under Services : The following configuration options are available: Relay Enable : Enables or disables the CloudCat instance First/Second Cloud Service PID : These properties specify the Kura Service Pid of the CloudService instances to be used. First/Second CloudClient App ID : The application ID to be used by the CloudCat service on each cloud service. First/Second CloudClient Control Subscriptions : A list of control topics to subscribe to on each CloudClient as a comma separated list of control-app-topic;Qos pairs. First/Second CloudClient Control Subscriptions : A list of data topics to subscribe to on each CloudClient as a comma separated list of data-app-topic;Qos pairs. The CloudCat service will replicate all messages received on each of the control or data topics specified in the configuration to the other CloudClient, the complete topics will have the following structure Data Topics : #account-name/#client-id/#app-id/#data-app-topic Control Topics : #control-topic-prefix/#account-name/#client-id/#app-id/#control-app-topic where: #account-name is the value of the topic.context.account-name configuration property of the MQTTDataTransport instance in use. #client-id is the value of the client-id configuration property of the MQTTDataTransport instance in use, if this parameter is empty, the MAC address of the primary network interface of the device will be used. #control-topic-prefix if the value of the topic.control-prefix configuration property of the CloudService instance in use. #app-id , #data-app-topic , #control-app-topic are obtained from the CloudCat configuration as described above. When a CloudCat instance forwards a message from one CloudClient to another, only the #data-app-topic or #control-app-topic part of the topic is preserved, the remaining parts are translated to match the configuration of the CloudService on which the messages are published. Note: The set of topics specified for data or control topic subscriptions on each CloudService instance should be disjoint. If this condition is not verified, and a CloudCat instance is subscribed to the same topic on each CloudService instance, message loops may occur. Use case example The example below shows how to share a cloud connection managed by Kura with an external javascript application using the embedded Artemis broker and CloudCat: Enable the embedded Artemis broker instance Connect the default CloudService instance to your favorite cloud platform. Enable the Simple Artemis MQTT Broker service by configuring it as follows: Enabled : true MQTT address : 0.0.0.0 MQTT port : 1883 User name : artemis Password of the user : foo (or any other password) Open the MQTT port specified above in the firewall configuration. Connect a CloudService instance to the Artemis broker Navigate to the Cloud Services section of the Web UI Click on the New button and create a new CloudService instance with the org.eclipse.kura.cloud.CloudService-ARTEMIS Cloud Service PID . Configure the new instance as follows: MqttDataTransport-ARTEMIS -> broker-url : mqtt://localhost:1883/ MqttDataTransport-ARTEMIS -> topic.context.account-name : artemis MqttDataTransport-ARTEMIS -> username : artemis MqttDataTransport-ARTEMIS -> password : foo , (or any other password used at step 2) MqttDataTransport-ARTEMIS -> client-id : cloudcat-relay CloudService-ARTEMIS -> encode.gzip : false CloudService-ARTEMIS -> enable.default.subscriptions : false CloudService-ARTEMIS -> birth.cert.policy : Disable publishing CloudService-ARTEMIS -> payload.encoding : Simple JSON DataService-ARTEMIS -> connect.auto-on-startup : true The settings above define a \"raw\" CloudService that uses JSON as payload encoding and does not perform gzip compression. This is intended to use a message format that is easily manageable by an external Javascript application. Default subscriptions and birth certificate publishing can be disabled as these features are not needed when connecting to the embedded Artemis broker. Create and configure a CloudCat instance Create a new CloudCat instance as shown above. Configure the instance as follows: Relay Enable : true First CloudService PID : org.eclipse.kura.cloud.CloudService Second CloudService PID : org.eclipse.kura.cloud.CloudService-ARTEMIS First CloudClient App ID : cloudcat Second CloudClient App ID : external-app First CloudClient Control Subscriptions : leave blank Second CloudClient Control Subscriptions : leave blank First CloudClient Data Subscriptions : in;0 Second CloudClient Data Subscriptions : out;0 Create the external Javascript application Create an HTML file containing the following code: < html > < head > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js\" type = \"text/javascript\" ></ script > </ head > < body > < script > var HOST = 'gateway-ip' var CLIENT_ID = 'external-app' var USER_NAME = 'artemis' var PASSWORD = 'foo' var PUBLISH_TOPIC = USER_NAME + '/cloudcat-relay/external-app/out' var SUBSCRIBE_TOPIC = USER_NAME + '/cloudcat-relay/external-app/in' var PUBLISH_RATE_SECONDS = 10 var log = ( function () { var body = document . getElementsByTagName ( \"body\" )[ 0 ]; return function ( message ) { var paragraph = document . createElement ( 'p' ) paragraph . textContent = message body . appendChild ( paragraph ) } })() var subscribe = function ( topic ) { log ( 'subscribing to ' + topic + '...' ) client . subscribe ( topic , { onSuccess : function () { log ( 'subscribed to ' + topic ) client . onMessageArrived = function ( message ) { log ( 'received message on topic ' + message . destinationName ) log ( 'payload: ' + message . payloadString ) } }, onFailure : log }) } var startPublishing = function ( topic ) { setInterval ( function () { try { client . send ( topic , JSON . stringify ({ metrics : { intMetric : 1 , stringMetric : 'test string' } })) } catch ( err ) { log ( err ) } }, PUBLISH_RATE_SECONDS * 1000 ) } var client = new Paho . MQTT . Client ( HOST , 1883 , '/' , CLIENT_ID ) client . connect ({ timeout : 30 , userName : USER_NAME , password : PASSWORD , useSSL : false , onSuccess : function () { log ( 'connected' ) startPublishing ( PUBLISH_TOPIC ) subscribe ( SUBSCRIBE_TOPIC ) }, onFailure : function ( err ) { log ( 'connection failed' ) log ( JSON . stringify ( err )) } }) </ script > </ body > </ html > Modify the HOST constant in the code by replacing gateway-ip with the IP address of the gateway in use, and then open the created file in a browser. This application uses the Paho javascript MQTT library to connect to the broker instance using WebSocket, the application subscribes to the artemis/cloudcat-relay/external-app/in topic and publishes messages to artemis/cloudcat-relay/external-app/out . The topics above are mapped to the following topics on the device cloud connection by the CloudCat service: Artemis Topic Cloud Topic artemis/cloudcat-relay/external-app/in #account-name/#client-id/cloudcat/in artemis/cloudcat-relay/external-app/out #account-name/#client-id/cloudcat/out Where #account-name and #client-id are the identifiers used on the cloud platform. Messages published by the application can be viewed by using the Web console of the cloud platform used under the #account-name/#client-id/cloudcat/out topic. Messages published on the #account-name/#client-id/cloudcat/in topic on the cloud platform will be received by the CloudCat and then forwarded to the external application that will log them on the browser window.","title":"Cloudcat"},{"location":"builtin/cloudcat/#cloudcat","text":"The CloudCat Service replicates messages published to one CloudService instance to another one, performing the following operations: The service obtains two CloudClients from two different CloudService instances specified in the service configuration. For each CloudClient, the service subscribes to a set of topics specified in the configuration. Message received by the service on one of the two CloudClients will be re-published on the other one. This service allows for example to share an existing cloud connection to external applications using the Artemis broker. An example of this use case will be presented below.","title":"Cloudcat"},{"location":"builtin/cloudcat/#instance-creation","text":"In order to create an instance of the CloudCat component perform the following steps: Press the + button under Services in the Kura Web UI. Select org.eclipse.kura.misc.cloudcat.CloudCat from the Factory drop down list. Enter a unique name for the new instance in the Name field and press Apply .","title":"Instance creation"},{"location":"builtin/cloudcat/#service-configuration","text":"In order to review the configuration of a CloudCat instance, click on the corresponding entry under Services : The following configuration options are available: Relay Enable : Enables or disables the CloudCat instance First/Second Cloud Service PID : These properties specify the Kura Service Pid of the CloudService instances to be used. First/Second CloudClient App ID : The application ID to be used by the CloudCat service on each cloud service. First/Second CloudClient Control Subscriptions : A list of control topics to subscribe to on each CloudClient as a comma separated list of control-app-topic;Qos pairs. First/Second CloudClient Control Subscriptions : A list of data topics to subscribe to on each CloudClient as a comma separated list of data-app-topic;Qos pairs. The CloudCat service will replicate all messages received on each of the control or data topics specified in the configuration to the other CloudClient, the complete topics will have the following structure Data Topics : #account-name/#client-id/#app-id/#data-app-topic Control Topics : #control-topic-prefix/#account-name/#client-id/#app-id/#control-app-topic where: #account-name is the value of the topic.context.account-name configuration property of the MQTTDataTransport instance in use. #client-id is the value of the client-id configuration property of the MQTTDataTransport instance in use, if this parameter is empty, the MAC address of the primary network interface of the device will be used. #control-topic-prefix if the value of the topic.control-prefix configuration property of the CloudService instance in use. #app-id , #data-app-topic , #control-app-topic are obtained from the CloudCat configuration as described above. When a CloudCat instance forwards a message from one CloudClient to another, only the #data-app-topic or #control-app-topic part of the topic is preserved, the remaining parts are translated to match the configuration of the CloudService on which the messages are published. Note: The set of topics specified for data or control topic subscriptions on each CloudService instance should be disjoint. If this condition is not verified, and a CloudCat instance is subscribed to the same topic on each CloudService instance, message loops may occur.","title":"Service configuration"},{"location":"builtin/cloudcat/#use-case-example","text":"The example below shows how to share a cloud connection managed by Kura with an external javascript application using the embedded Artemis broker and CloudCat:","title":"Use case example"},{"location":"builtin/cloudcat/#enable-the-embedded-artemis-broker-instance","text":"Connect the default CloudService instance to your favorite cloud platform. Enable the Simple Artemis MQTT Broker service by configuring it as follows: Enabled : true MQTT address : 0.0.0.0 MQTT port : 1883 User name : artemis Password of the user : foo (or any other password) Open the MQTT port specified above in the firewall configuration.","title":"Enable the embedded Artemis broker instance"},{"location":"builtin/cloudcat/#connect-a-cloudservice-instance-to-the-artemis-broker","text":"Navigate to the Cloud Services section of the Web UI Click on the New button and create a new CloudService instance with the org.eclipse.kura.cloud.CloudService-ARTEMIS Cloud Service PID . Configure the new instance as follows: MqttDataTransport-ARTEMIS -> broker-url : mqtt://localhost:1883/ MqttDataTransport-ARTEMIS -> topic.context.account-name : artemis MqttDataTransport-ARTEMIS -> username : artemis MqttDataTransport-ARTEMIS -> password : foo , (or any other password used at step 2) MqttDataTransport-ARTEMIS -> client-id : cloudcat-relay CloudService-ARTEMIS -> encode.gzip : false CloudService-ARTEMIS -> enable.default.subscriptions : false CloudService-ARTEMIS -> birth.cert.policy : Disable publishing CloudService-ARTEMIS -> payload.encoding : Simple JSON DataService-ARTEMIS -> connect.auto-on-startup : true The settings above define a \"raw\" CloudService that uses JSON as payload encoding and does not perform gzip compression. This is intended to use a message format that is easily manageable by an external Javascript application. Default subscriptions and birth certificate publishing can be disabled as these features are not needed when connecting to the embedded Artemis broker.","title":"Connect a CloudService instance to the Artemis broker"},{"location":"builtin/cloudcat/#create-and-configure-a-cloudcat-instance","text":"Create a new CloudCat instance as shown above. Configure the instance as follows: Relay Enable : true First CloudService PID : org.eclipse.kura.cloud.CloudService Second CloudService PID : org.eclipse.kura.cloud.CloudService-ARTEMIS First CloudClient App ID : cloudcat Second CloudClient App ID : external-app First CloudClient Control Subscriptions : leave blank Second CloudClient Control Subscriptions : leave blank First CloudClient Data Subscriptions : in;0 Second CloudClient Data Subscriptions : out;0","title":"Create and configure a CloudCat instance"},{"location":"builtin/cloudcat/#create-the-external-javascript-application","text":"Create an HTML file containing the following code: < html > < head > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js\" type = \"text/javascript\" ></ script > </ head > < body > < script > var HOST = 'gateway-ip' var CLIENT_ID = 'external-app' var USER_NAME = 'artemis' var PASSWORD = 'foo' var PUBLISH_TOPIC = USER_NAME + '/cloudcat-relay/external-app/out' var SUBSCRIBE_TOPIC = USER_NAME + '/cloudcat-relay/external-app/in' var PUBLISH_RATE_SECONDS = 10 var log = ( function () { var body = document . getElementsByTagName ( \"body\" )[ 0 ]; return function ( message ) { var paragraph = document . createElement ( 'p' ) paragraph . textContent = message body . appendChild ( paragraph ) } })() var subscribe = function ( topic ) { log ( 'subscribing to ' + topic + '...' ) client . subscribe ( topic , { onSuccess : function () { log ( 'subscribed to ' + topic ) client . onMessageArrived = function ( message ) { log ( 'received message on topic ' + message . destinationName ) log ( 'payload: ' + message . payloadString ) } }, onFailure : log }) } var startPublishing = function ( topic ) { setInterval ( function () { try { client . send ( topic , JSON . stringify ({ metrics : { intMetric : 1 , stringMetric : 'test string' } })) } catch ( err ) { log ( err ) } }, PUBLISH_RATE_SECONDS * 1000 ) } var client = new Paho . MQTT . Client ( HOST , 1883 , '/' , CLIENT_ID ) client . connect ({ timeout : 30 , userName : USER_NAME , password : PASSWORD , useSSL : false , onSuccess : function () { log ( 'connected' ) startPublishing ( PUBLISH_TOPIC ) subscribe ( SUBSCRIBE_TOPIC ) }, onFailure : function ( err ) { log ( 'connection failed' ) log ( JSON . stringify ( err )) } }) </ script > </ body > </ html > Modify the HOST constant in the code by replacing gateway-ip with the IP address of the gateway in use, and then open the created file in a browser. This application uses the Paho javascript MQTT library to connect to the broker instance using WebSocket, the application subscribes to the artemis/cloudcat-relay/external-app/in topic and publishes messages to artemis/cloudcat-relay/external-app/out . The topics above are mapped to the following topics on the device cloud connection by the CloudCat service: Artemis Topic Cloud Topic artemis/cloudcat-relay/external-app/in #account-name/#client-id/cloudcat/in artemis/cloudcat-relay/external-app/out #account-name/#client-id/cloudcat/out Where #account-name and #client-id are the identifiers used on the cloud platform. Messages published by the application can be viewed by using the Web console of the cloud platform used under the #account-name/#client-id/cloudcat/out topic. Messages published on the #account-name/#client-id/cloudcat/in topic on the cloud platform will be received by the CloudCat and then forwarded to the external application that will log them on the browser window.","title":"Create the external Javascript application"},{"location":"builtin/command-service/","text":"Command Service The CommandService provides methods for running system commands from the Kura web console or from a cloud platform. Currently it is supported in Everyware Cloud. In the Kura web console, the service is available clicking on the Command tab under the Device section, while for the cloud platform please refer to the official documentation. To run a command simply fill the Execute field with the command and click the Execute button. The service also provides the ability for a script to execute using the File option of the Command tab in the Kura web console or the Everyware Cloud Console. This script must be compressed into a zip file with the eventual, associated resource files. Once the file is selected and Execute is clicked, the zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present in the file. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered. The configuration of the service is in the CommandService tab located in the Services area as shown in the screen capture below. The CommandService provides the following configuration parameters: Command Enable - sets whether this service is enabled or disabled in the cloud platform. (Required field.) Command Password Value - sets a password to protect this service. Command Working Directory - specifies the working directory where the command execution is performed. Command Timeout - sets the timeout (in seconds) for the command execution. Command Environment - supplies a space-separated list of environment variables in the format key=value. Privileged/Unprivileged Command Service Selection - sets the modality of the command service. When set to privileged, the commands are run using the (privileged) user that started Kura, tipically kurad or root . When set to unprivileged, a standard user will run the commands, tipically kura . Only the RaspberryPi profiles support the unprivileged command service. When a command execution is requested in the cloud platform, it sends an MQTT control message to the device requesting that the command be executed. On the device, the Command Service opens a temporary shell in the command.working.directory, sets the command.environment variables (if any), and waits command.timeout seconds to get command response.","title":"Command Service"},{"location":"builtin/command-service/#command-service","text":"The CommandService provides methods for running system commands from the Kura web console or from a cloud platform. Currently it is supported in Everyware Cloud. In the Kura web console, the service is available clicking on the Command tab under the Device section, while for the cloud platform please refer to the official documentation. To run a command simply fill the Execute field with the command and click the Execute button. The service also provides the ability for a script to execute using the File option of the Command tab in the Kura web console or the Everyware Cloud Console. This script must be compressed into a zip file with the eventual, associated resource files. Once the file is selected and Execute is clicked, the zip file is sent embedded in an MQTT message on the device. The Command Service in the device stores the file in /tmp, unzips it, and tries to execute a shell script if one is present in the file. Note that in this case, the Execute parameter cannot be empty; a simple command, such as \"ls -l /tmp\", may be entered. The configuration of the service is in the CommandService tab located in the Services area as shown in the screen capture below. The CommandService provides the following configuration parameters: Command Enable - sets whether this service is enabled or disabled in the cloud platform. (Required field.) Command Password Value - sets a password to protect this service. Command Working Directory - specifies the working directory where the command execution is performed. Command Timeout - sets the timeout (in seconds) for the command execution. Command Environment - supplies a space-separated list of environment variables in the format key=value. Privileged/Unprivileged Command Service Selection - sets the modality of the command service. When set to privileged, the commands are run using the (privileged) user that started Kura, tipically kurad or root . When set to unprivileged, a standard user will run the commands, tipically kura . Only the RaspberryPi profiles support the unprivileged command service. When a command execution is requested in the cloud platform, it sends an MQTT control message to the device requesting that the command be executed. On the device, the Command Service opens a temporary shell in the command.working.directory, sets the command.environment variables (if any), and waits command.timeout seconds to get command response.","title":"Command Service"},{"location":"builtin/container-orchestration-provider/","text":"Container Orchestration Provider What is the Container Orchestration Provider? The Container Orchestration Provider allows Kura to manage Docker. With this tool you can arbitrarily pull and deploy containerized software packages and run them on your gateway. This Service allows the user to create, configure, start, and stop containers all from the browser. The bundle will also restart containers, if the gateway is restarted. The feature is composed of two bundles, one that exposes APIs for container management and one that implements those APIs. This API is exposed so that you can leverage it to implement containerization in your own Kura plugins. How to use the Container Orchestration Provider Before Starting For this bundle to function appropriately, the gateway must a supported container engine installed and running. Currently the only officially supported engine is Docker. Starting the Service To use this service select the ContainerOrchestrationService option located in the Services area. The ContainerOrchestrationService provides the following parameters: - Enabled --activates the service when set to true - Container Engine Host URL --provides a string that tells the service where to find the container engine (best left to the default value). Creating your first container. To create a container, select the + icon (Create a new component) under services . A popup dialogue box will appear. In the field Factory select org.eclipse.kura.container.provider.ContainerInstance from the drop-down. Then, using the Name field, enter the name of the container you wish to create and Finally press submit to create the component. After pressing submit, a new component will be added under the services tab, with the name that was selected in the dialogue. Select this component to finish configuring the container. Configuring the container To begin configuring the container, look under Services and select the item which has the name set in the previous step. Containers may be configured using the following fields: Enabled - When true, the service will create the defined container. When false the API will not create the container or will destroy the container if already running. Image Name - Describes the image that will be used to create the container. Remember to ensure that the selected image supports the architecture of the host machine, or else the container will not be able to start. Image Tag - Describes the version of the image that will be used to create the container. Authentication Registry URL - URL for an alternative registry to pull images from. (If the field is left blank, credentials will be applied to Docker-Hub). Please see the Authenticated Registries section for more information about connecting to different popular registries. Authentication Username - Describes the username to access the registry entered above. Password - Describes the password to access the alternative registry. Image Download Retries - Describes the number of retries the framework will attempt to pull the image before giving up. Image Download Retry Interval - Describes the amount of time the framework will wait before attempting to pull the image again. Image Download Timeout - Describes the amount of time the framework will let the image download before timeout. Internal Ports - This field accepts a comma-separated list of ports that will be internally exposed on the spun-up container. External Ports - This field accepts a comma-separated list of ports that will be externally exposed on the host machine. Privileged Mode - This flag if enabled will give the container root capabilities to all devices on the host system. Please be aware that setting this flag can be dangerous, and must only be used in exceptional situations. Environment Variables (optional) - This field accepts a comma-separated list of environment variables, which will be set inside the container when spun up. Volume Mount (optional) - This field accepts a comma-separated list of system-to-container file mounts. This allows for the container to access files on the host machine. Peripheral Device (optional) - This field accepts a comma-separated list of device paths. This parameter allows for devices to be passed through from the host to the container. Logger Type - This field provides a drop-down selection of supported container logging drivers. Logger Parameters (optional) - This field accepts a comma-separated list of logging parameters. After specifying container parameters, ensure to set Enabled to true and press Apply . The container engine will then pull the respective image, spin up and start the container. If the gateway or the framework are power cycled, and the container and Container Orchestration Service are set to enabled , the framework will automatically start the container again upon startup. Stopping the container Stopping a container will delete it in irreversible way. Please be sure to use only stateless container and/or save their data in external volumes. To stop the container without deleting the component, set the Enabled field to false , and then press Apply . This will delete the running container, but leave this component available for running the container again in the future. If you want to completely remove the container and component, press the Delete button to the top right of the screen, and press Yes on the confirmation dialogue. Container Management Dashboard The Container Orchestration service also provides the user with an intuitive container dashboard. This dashboard shows all containers running on a gateway, including containers created with Kura and those created manually through the command line interface. To utilize this dashboard the org.eclipse.container.orchestration.provider (Container Orchestration Service) must be enabled, and the dashboard can be opened by navigating to Device > Docker Containers . Authenticated Registries The Container Orchestrator provider allows the user to pull images from private and password-protected registries. The following document will provide examples of how to connect to some popular registries. These guides make the following two assumptions. That you have already configured the Container Orchestrator and have a container instance already created. Please see the usage doc, to learn the basics of the orchestrator. That the image you are trying to pull supports the architecture of the gateway. Private Docker-Hub Registries Preparation: have a Docker Hub account (its credentials), and a private image ready to pull. Procedure: Populate the image name field. The username containing the private image must be placed before the image name separated by a forward slash. This is demonstrated below: Image Name: <Docker-Hub username>/<image name> for example eclipse/kura . Populate the credential fields: Authentication Registry URL: This field should be left blank. Authentication Username: Your Docker Hub username. Password: Your Docker Hub password. Amazon Web Services - Elastic Container Registries (AWS-ECR) Preparation: Have access to an Amazon ECR instance. Have the AWS-CLI tool installed and appropriately configured on your computer. Have access to your AWS ECR web console. Procedure: Sign in to your amazon web console, navigate to ECR and identify which container you will like to pull onto the gateway. Copy the URI of the container. This URI will reveal the information required for the following steps. Here is how to decode the URI <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/<image name>:<image tag> . Generating an AWS-ECR access password. Open a terminal window on the machine with aws-cli installed and enter the following command aws ecr get-login-password --region <ecr-region> . Your ECR region can be found by inspecting the container URI string copied in the previous step. This command will return a long string which will be used as the repo password in the gateway. Populating information on the gateway. Image Name: enter the full URI without the tag. <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/<image name> Image Tag: enter only the image tag found at the end of the URI <image tag> Authentication Registry URL: Paste only the part of the URI before the image name <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/ Authentication Username: will be AWS Password: will be the string created in step two. A fully configured container set to pull AWS will look like the following. How to leverage the Container Orchestration Provider API? The Container Orchestration Provider exposes an API that can be leveraged by other framework plugins. The following is an overview of how these APIs work together. ContainerOrchestrationService The ContainerOrchestrationService is used to directly communicate with the running container engine. It exposes methods for listing, creating, and stopping containers. This class utilizes an instantiated ContainerConfiguration object as a parameter for container creation. ContainerConfiguration The ContainerConfiguration class, allows you to define a container to create. Using the embedded builder class, one can define many container-related parameters such as name, image, ports and volume mounts. ContainerInstanceDescriptor The ContainerInstanceDescriptor class is used to describe a container that has already been created. This class contains runtime information such as the ID of the container. ContainerState The ContainerState is a class that exposes an enum of container states tracked by the framework. PasswordRegistryCredentials The PasswordRegistryCredentials class stores password credentials when provisioning a container to pull from an alternative password-protected registry. PasswordRegistryCredentials The PasswordRegistryCredentials class stores password credentials when provisioning a container to pull from an alternative password-protected registry. The Container Orchestration Provider exports an MQTT-Namespace API. This API can be used to manage containers via MQTT requests from external applications such as Everywhere Cloud. Please visit the Remote Gateway Inventory via MQTT documentation for more information.","title":"Container Orchestration Provider"},{"location":"builtin/container-orchestration-provider/#container-orchestration-provider","text":"","title":"Container Orchestration Provider"},{"location":"builtin/container-orchestration-provider/#what-is-the-container-orchestration-provider","text":"The Container Orchestration Provider allows Kura to manage Docker. With this tool you can arbitrarily pull and deploy containerized software packages and run them on your gateway. This Service allows the user to create, configure, start, and stop containers all from the browser. The bundle will also restart containers, if the gateway is restarted. The feature is composed of two bundles, one that exposes APIs for container management and one that implements those APIs. This API is exposed so that you can leverage it to implement containerization in your own Kura plugins.","title":"What is the Container Orchestration Provider?"},{"location":"builtin/container-orchestration-provider/#how-to-use-the-container-orchestration-provider","text":"","title":"How to use the Container Orchestration Provider"},{"location":"builtin/container-orchestration-provider/#before-starting","text":"For this bundle to function appropriately, the gateway must a supported container engine installed and running. Currently the only officially supported engine is Docker.","title":"Before Starting"},{"location":"builtin/container-orchestration-provider/#starting-the-service","text":"To use this service select the ContainerOrchestrationService option located in the Services area. The ContainerOrchestrationService provides the following parameters: - Enabled --activates the service when set to true - Container Engine Host URL --provides a string that tells the service where to find the container engine (best left to the default value).","title":"Starting the Service"},{"location":"builtin/container-orchestration-provider/#creating-your-first-container","text":"To create a container, select the + icon (Create a new component) under services . A popup dialogue box will appear. In the field Factory select org.eclipse.kura.container.provider.ContainerInstance from the drop-down. Then, using the Name field, enter the name of the container you wish to create and Finally press submit to create the component. After pressing submit, a new component will be added under the services tab, with the name that was selected in the dialogue. Select this component to finish configuring the container.","title":"Creating your first container."},{"location":"builtin/container-orchestration-provider/#configuring-the-container","text":"To begin configuring the container, look under Services and select the item which has the name set in the previous step. Containers may be configured using the following fields: Enabled - When true, the service will create the defined container. When false the API will not create the container or will destroy the container if already running. Image Name - Describes the image that will be used to create the container. Remember to ensure that the selected image supports the architecture of the host machine, or else the container will not be able to start. Image Tag - Describes the version of the image that will be used to create the container. Authentication Registry URL - URL for an alternative registry to pull images from. (If the field is left blank, credentials will be applied to Docker-Hub). Please see the Authenticated Registries section for more information about connecting to different popular registries. Authentication Username - Describes the username to access the registry entered above. Password - Describes the password to access the alternative registry. Image Download Retries - Describes the number of retries the framework will attempt to pull the image before giving up. Image Download Retry Interval - Describes the amount of time the framework will wait before attempting to pull the image again. Image Download Timeout - Describes the amount of time the framework will let the image download before timeout. Internal Ports - This field accepts a comma-separated list of ports that will be internally exposed on the spun-up container. External Ports - This field accepts a comma-separated list of ports that will be externally exposed on the host machine. Privileged Mode - This flag if enabled will give the container root capabilities to all devices on the host system. Please be aware that setting this flag can be dangerous, and must only be used in exceptional situations. Environment Variables (optional) - This field accepts a comma-separated list of environment variables, which will be set inside the container when spun up. Volume Mount (optional) - This field accepts a comma-separated list of system-to-container file mounts. This allows for the container to access files on the host machine. Peripheral Device (optional) - This field accepts a comma-separated list of device paths. This parameter allows for devices to be passed through from the host to the container. Logger Type - This field provides a drop-down selection of supported container logging drivers. Logger Parameters (optional) - This field accepts a comma-separated list of logging parameters. After specifying container parameters, ensure to set Enabled to true and press Apply . The container engine will then pull the respective image, spin up and start the container. If the gateway or the framework are power cycled, and the container and Container Orchestration Service are set to enabled , the framework will automatically start the container again upon startup.","title":"Configuring the container"},{"location":"builtin/container-orchestration-provider/#stopping-the-container","text":"Stopping a container will delete it in irreversible way. Please be sure to use only stateless container and/or save their data in external volumes. To stop the container without deleting the component, set the Enabled field to false , and then press Apply . This will delete the running container, but leave this component available for running the container again in the future. If you want to completely remove the container and component, press the Delete button to the top right of the screen, and press Yes on the confirmation dialogue.","title":"Stopping the container"},{"location":"builtin/container-orchestration-provider/#container-management-dashboard","text":"The Container Orchestration service also provides the user with an intuitive container dashboard. This dashboard shows all containers running on a gateway, including containers created with Kura and those created manually through the command line interface. To utilize this dashboard the org.eclipse.container.orchestration.provider (Container Orchestration Service) must be enabled, and the dashboard can be opened by navigating to Device > Docker Containers .","title":"Container Management Dashboard"},{"location":"builtin/container-orchestration-provider/#authenticated-registries","text":"The Container Orchestrator provider allows the user to pull images from private and password-protected registries. The following document will provide examples of how to connect to some popular registries. These guides make the following two assumptions. That you have already configured the Container Orchestrator and have a container instance already created. Please see the usage doc, to learn the basics of the orchestrator. That the image you are trying to pull supports the architecture of the gateway.","title":"Authenticated Registries"},{"location":"builtin/container-orchestration-provider/#private-docker-hub-registries","text":"","title":"Private Docker-Hub Registries"},{"location":"builtin/container-orchestration-provider/#preparation","text":"have a Docker Hub account (its credentials), and a private image ready to pull.","title":"Preparation:"},{"location":"builtin/container-orchestration-provider/#procedure","text":"Populate the image name field. The username containing the private image must be placed before the image name separated by a forward slash. This is demonstrated below: Image Name: <Docker-Hub username>/<image name> for example eclipse/kura . Populate the credential fields: Authentication Registry URL: This field should be left blank. Authentication Username: Your Docker Hub username. Password: Your Docker Hub password.","title":"Procedure:"},{"location":"builtin/container-orchestration-provider/#amazon-web-services-elastic-container-registries-aws-ecr","text":"","title":"Amazon Web Services - Elastic Container Registries (AWS-ECR)"},{"location":"builtin/container-orchestration-provider/#preparation_1","text":"Have access to an Amazon ECR instance. Have the AWS-CLI tool installed and appropriately configured on your computer. Have access to your AWS ECR web console.","title":"Preparation:"},{"location":"builtin/container-orchestration-provider/#procedure_1","text":"Sign in to your amazon web console, navigate to ECR and identify which container you will like to pull onto the gateway. Copy the URI of the container. This URI will reveal the information required for the following steps. Here is how to decode the URI <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/<image name>:<image tag> . Generating an AWS-ECR access password. Open a terminal window on the machine with aws-cli installed and enter the following command aws ecr get-login-password --region <ecr-region> . Your ECR region can be found by inspecting the container URI string copied in the previous step. This command will return a long string which will be used as the repo password in the gateway. Populating information on the gateway. Image Name: enter the full URI without the tag. <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/<image name> Image Tag: enter only the image tag found at the end of the URI <image tag> Authentication Registry URL: Paste only the part of the URI before the image name <identifier>.dkr.ecr.<ecr-region>.amazonaws.com/<directory>/ Authentication Username: will be AWS Password: will be the string created in step two. A fully configured container set to pull AWS will look like the following.","title":"Procedure:"},{"location":"builtin/container-orchestration-provider/#how-to-leverage-the-container-orchestration-provider-api","text":"The Container Orchestration Provider exposes an API that can be leveraged by other framework plugins. The following is an overview of how these APIs work together.","title":"How to leverage the Container Orchestration Provider API?"},{"location":"builtin/container-orchestration-provider/#containerorchestrationservice","text":"The ContainerOrchestrationService is used to directly communicate with the running container engine. It exposes methods for listing, creating, and stopping containers. This class utilizes an instantiated ContainerConfiguration object as a parameter for container creation.","title":"ContainerOrchestrationService"},{"location":"builtin/container-orchestration-provider/#containerconfiguration","text":"The ContainerConfiguration class, allows you to define a container to create. Using the embedded builder class, one can define many container-related parameters such as name, image, ports and volume mounts.","title":"ContainerConfiguration"},{"location":"builtin/container-orchestration-provider/#containerinstancedescriptor","text":"The ContainerInstanceDescriptor class is used to describe a container that has already been created. This class contains runtime information such as the ID of the container.","title":"ContainerInstanceDescriptor"},{"location":"builtin/container-orchestration-provider/#containerstate","text":"The ContainerState is a class that exposes an enum of container states tracked by the framework.","title":"ContainerState"},{"location":"builtin/container-orchestration-provider/#passwordregistrycredentials","text":"The PasswordRegistryCredentials class stores password credentials when provisioning a container to pull from an alternative password-protected registry.","title":"PasswordRegistryCredentials"},{"location":"builtin/container-orchestration-provider/#passwordregistrycredentials_1","text":"The PasswordRegistryCredentials class stores password credentials when provisioning a container to pull from an alternative password-protected registry. The Container Orchestration Provider exports an MQTT-Namespace API. This API can be used to manage containers via MQTT requests from external applications such as Everywhere Cloud. Please visit the Remote Gateway Inventory via MQTT documentation for more information.","title":"PasswordRegistryCredentials"},{"location":"builtin/deployment-service/","text":"Deployment Service The Deployment Service allows user to download files to the gateway and to perform actions on them. In the configuration tab it is possible to specify which is the directory that has to be used to store the downloaded files and the list of actions declared as deployment hooks that will be invoked when a corresponding metric is received with the download request. The configuration requires to specify two parameters: downloads.directory - The directory to be used to store the downloaded files; deployment.hook.associations - The list of DeploymentHook associations in the form <request_type>=<hook_pid> , where <hook_pid> is the Kura Service Pid of a DeploymentHook instance and <request_type> is the value of the request.type metric received with the request.","title":"Deployment Service"},{"location":"builtin/deployment-service/#deployment-service","text":"The Deployment Service allows user to download files to the gateway and to perform actions on them. In the configuration tab it is possible to specify which is the directory that has to be used to store the downloaded files and the list of actions declared as deployment hooks that will be invoked when a corresponding metric is received with the download request. The configuration requires to specify two parameters: downloads.directory - The directory to be used to store the downloaded files; deployment.hook.associations - The list of DeploymentHook associations in the form <request_type>=<hook_pid> , where <hook_pid> is the Kura Service Pid of a DeploymentHook instance and <request_type> is the value of the request.type metric received with the request.","title":"Deployment Service"},{"location":"builtin/h2-database-external-connections/","text":"H2 database: Connecting external applications This document presents several examples on how to access data contained in a H2 server instance managed by Eclipse Kura from external applications such as LibreOffice and Python scripts. Create a test database instance The first step involves creating a test database instance and filling it with some data: As explained here , create a new database instance named TestDb with the following settings: db.connector.url : jdbc:h2:mem:testdb password : password Insert some data in the database, using Kura Wires. Create a Wire Graph as follows, where Timer is a Timer component with default settings and Store is a DB Store component configured to use the DB instance previously created by setting db.service.pid to TestDb . The Timer component will periodically emit a wire envelope containing a property named TIMER whose value is the current timestamp. The store component will create a column with the same name in the WR_data table of the database containing the received timestamps. Start the H2 server, creating a new H2DbServer instance and configuring it to start in TCP mode as follows: db.server.enabled : true db.server.type : TCP db.server.commandline : -tcpPort 9123 -tcpAllowOthers -ifExists Accessing the data An external application can connect to the H2 server in two ways: Using the H2 JDBC Driver : if the server is configured in TCP mode it exposes the data using a H2 specific protocol implemented by the H2 JDBC driver. In order to use this access mode the H2 jar must be available to the external application since it contains the JDBC driver. Using the PostgreSQL network protocol : H2 server also provides an experimental implementation of the PostgreSQL network protocol (see here ). This protocol can be enabled by configuring the server in PG mode. This mode should allow any application that supports the PostgreSQL network protocol to access the database. Access the data using LibreOffice The H2 JDBC Driver can be used to access database data using LibreOffice. The steps below have been tested using LibreOffice 5.3.3.2 on OSX. Import the H2 jar into LibreOffice classpath 1. Download H2 jar 1.4.192 from Maven (https://mvnrepository.com/artifact/com.h2database/h2/1.4.192). 2. Open LibreOffice (any application) and open the preferences window. 3. Select **Advanced** from the side menu under **LibreOffice** and press the **Class Path** button, the following window should appear: ![LibreOffice Classpath]({{ site.baseurl }}/assets/images/database/libreoffice_classpath.png) 1. Click on the **Add Archive** button, select the h2 jar previously downloaded and press **Ok** 2. Exit from LibreOffice. LibreOffice needs a restart to update its classpath. It is important to make sure that the LibreOffice process is terminated before proceeding with the next steps. Connect to the database instance Open LibreOffice Base, the following wizard should appear. Select Connect to an existing database and click next. Set the JDBC driver and DB URL as follows: Datasource URL : jdbc:h2:tcp:<ip-address>:9123/mem:testdb replacing <ip-address> with the address of the device running Kura. JDBC Driver : org.h2.Driver Click on Test Class to make sure that the driver can be loaded successfully. Set the credentials: enter SA in the user name field, check the Password required field and click Test connection . Then enter the password in the Password field when required. Finally click Next . Leave the settings unchanged on the next screen, press Finish and save the database. Make sure that the port 9123 is open on the device firewall before connecting. View database contents: after the previous steps you should see the screen below. Double click on the WR_data table then its contents should be displayed. At this point LibreOffice should have created a Datasource representing the database, so it can be used for importing data from the database to other LibreOffice applications, like Calc. Importing the data in Calc Open Calc, click on View > Data sources and the database file previously saved (in this case test ) should be visible in the top left part of the screen. It should be possible to expand it and find the TESTDB.PUBLIC.WR_data table under Tables . The data from the table can be imported in Calc by dragging and dropping the TESTDB.PUBLIC.WR_data table in an empty cell of the spreadsheet. Access the data using Python This section describes how to access the data previously created using two different Python libraries. It will be assumed that the scripts are created and executed on a Raspberry PI running Raspbian and that the Kura instance hosting the database is running on the same machine. JayDeBeApi The JayDeBeApi library allows to use JDBC drivers from Python. In order to use this library the H2 jar is required, since it contains the needed JDBC driver. Install the pip tool: sudo apt-get install python3-pip Install the jaydebeapi module using pip: sudo pip3 install jaydebeapi Download the H2 jar from Maven Central curl \"http://central.maven.org/maven2/com/h2database/h2/1.4.192/h2-1.4.192.jar\" > h2.jar Create and run the following Python 3 script from the same directory as the H2 jar: import jaydebeapi conn = jaydebeapi . connect ( \"org.h2.Driver\" , # driver class \"jdbc:h2:tcp:localhost:9123/mem:testdb\" , # JDBC url [ \"SA\" , \"password\" ], # credentials \"./h2.jar\" ,) # location of H2 jar try : curs = conn . cursor () # Fetch the last 10 timestamps curs . execute ( \"SELECT TIMER FROM \\\" WR_data \\\" ORDER BY TIMER DESC LIMIT 10\" ) for value in curs . fetchall (): # the values are returned as wrapped java.lang.Long instances # invoke the toString() method to print them print ( value [ 0 ] . toString ()) finally : if curs is not None : curs . close () if conn is not None : conn . close () It should print on the console the latest 10 timestamp values generated by the Timer component. psycopg2 The psycopg2 Python module allows to connect to the server in PostgreSQL mode. Change the H2 Server mode to Postgres: db.server.enabled : true db.server.type : PG db.server.commandline : -pgPort 9123 -pgAllowOthers -ifExists Install the pip tool as in the previous section Install postgresql-server-dev-9.4 package: sudo apt-get install postgresql-server-dev-9.4 Install the psycopg2 module using pip: sudo pip3 install psycopg2 Create and run the following Python 3 script: import psycopg2 conn = psycopg2 . connect ( \"dbname=mem:testdb user=sa password=password host=localhost port=9123\" ) try : curs = conn . cursor () # Fetch the last 10 timestamps curs . execute ( \"SELECT TIMER FROM \\\" WR_data \\\" ORDER BY TIMER DESC LIMIT 10\" ) print ( curs . fetchall ()) finally : if curs is not None : curs . close () if conn is not None : conn . close () It should print on the console the latest 10 timestamp values generated by the Timer component like the previous script.","title":"H2 database - Connecting external applications"},{"location":"builtin/h2-database-external-connections/#h2-database-connecting-external-applications","text":"This document presents several examples on how to access data contained in a H2 server instance managed by Eclipse Kura from external applications such as LibreOffice and Python scripts.","title":"H2 database: Connecting external applications"},{"location":"builtin/h2-database-external-connections/#create-a-test-database-instance","text":"The first step involves creating a test database instance and filling it with some data: As explained here , create a new database instance named TestDb with the following settings: db.connector.url : jdbc:h2:mem:testdb password : password Insert some data in the database, using Kura Wires. Create a Wire Graph as follows, where Timer is a Timer component with default settings and Store is a DB Store component configured to use the DB instance previously created by setting db.service.pid to TestDb . The Timer component will periodically emit a wire envelope containing a property named TIMER whose value is the current timestamp. The store component will create a column with the same name in the WR_data table of the database containing the received timestamps. Start the H2 server, creating a new H2DbServer instance and configuring it to start in TCP mode as follows: db.server.enabled : true db.server.type : TCP db.server.commandline : -tcpPort 9123 -tcpAllowOthers -ifExists","title":"Create a test database instance"},{"location":"builtin/h2-database-external-connections/#accessing-the-data","text":"An external application can connect to the H2 server in two ways: Using the H2 JDBC Driver : if the server is configured in TCP mode it exposes the data using a H2 specific protocol implemented by the H2 JDBC driver. In order to use this access mode the H2 jar must be available to the external application since it contains the JDBC driver. Using the PostgreSQL network protocol : H2 server also provides an experimental implementation of the PostgreSQL network protocol (see here ). This protocol can be enabled by configuring the server in PG mode. This mode should allow any application that supports the PostgreSQL network protocol to access the database.","title":"Accessing the data"},{"location":"builtin/h2-database-external-connections/#access-the-data-using-libreoffice","text":"The H2 JDBC Driver can be used to access database data using LibreOffice. The steps below have been tested using LibreOffice 5.3.3.2 on OSX. Import the H2 jar into LibreOffice classpath 1. Download H2 jar 1.4.192 from Maven (https://mvnrepository.com/artifact/com.h2database/h2/1.4.192). 2. Open LibreOffice (any application) and open the preferences window. 3. Select **Advanced** from the side menu under **LibreOffice** and press the **Class Path** button, the following window should appear: ![LibreOffice Classpath]({{ site.baseurl }}/assets/images/database/libreoffice_classpath.png) 1. Click on the **Add Archive** button, select the h2 jar previously downloaded and press **Ok** 2. Exit from LibreOffice. LibreOffice needs a restart to update its classpath. It is important to make sure that the LibreOffice process is terminated before proceeding with the next steps. Connect to the database instance Open LibreOffice Base, the following wizard should appear. Select Connect to an existing database and click next. Set the JDBC driver and DB URL as follows: Datasource URL : jdbc:h2:tcp:<ip-address>:9123/mem:testdb replacing <ip-address> with the address of the device running Kura. JDBC Driver : org.h2.Driver Click on Test Class to make sure that the driver can be loaded successfully. Set the credentials: enter SA in the user name field, check the Password required field and click Test connection . Then enter the password in the Password field when required. Finally click Next . Leave the settings unchanged on the next screen, press Finish and save the database. Make sure that the port 9123 is open on the device firewall before connecting. View database contents: after the previous steps you should see the screen below. Double click on the WR_data table then its contents should be displayed. At this point LibreOffice should have created a Datasource representing the database, so it can be used for importing data from the database to other LibreOffice applications, like Calc. Importing the data in Calc Open Calc, click on View > Data sources and the database file previously saved (in this case test ) should be visible in the top left part of the screen. It should be possible to expand it and find the TESTDB.PUBLIC.WR_data table under Tables . The data from the table can be imported in Calc by dragging and dropping the TESTDB.PUBLIC.WR_data table in an empty cell of the spreadsheet.","title":"Access the data using LibreOffice"},{"location":"builtin/h2-database-external-connections/#access-the-data-using-python","text":"This section describes how to access the data previously created using two different Python libraries. It will be assumed that the scripts are created and executed on a Raspberry PI running Raspbian and that the Kura instance hosting the database is running on the same machine. JayDeBeApi The JayDeBeApi library allows to use JDBC drivers from Python. In order to use this library the H2 jar is required, since it contains the needed JDBC driver. Install the pip tool: sudo apt-get install python3-pip Install the jaydebeapi module using pip: sudo pip3 install jaydebeapi Download the H2 jar from Maven Central curl \"http://central.maven.org/maven2/com/h2database/h2/1.4.192/h2-1.4.192.jar\" > h2.jar Create and run the following Python 3 script from the same directory as the H2 jar: import jaydebeapi conn = jaydebeapi . connect ( \"org.h2.Driver\" , # driver class \"jdbc:h2:tcp:localhost:9123/mem:testdb\" , # JDBC url [ \"SA\" , \"password\" ], # credentials \"./h2.jar\" ,) # location of H2 jar try : curs = conn . cursor () # Fetch the last 10 timestamps curs . execute ( \"SELECT TIMER FROM \\\" WR_data \\\" ORDER BY TIMER DESC LIMIT 10\" ) for value in curs . fetchall (): # the values are returned as wrapped java.lang.Long instances # invoke the toString() method to print them print ( value [ 0 ] . toString ()) finally : if curs is not None : curs . close () if conn is not None : conn . close () It should print on the console the latest 10 timestamp values generated by the Timer component. psycopg2 The psycopg2 Python module allows to connect to the server in PostgreSQL mode. Change the H2 Server mode to Postgres: db.server.enabled : true db.server.type : PG db.server.commandline : -pgPort 9123 -pgAllowOthers -ifExists Install the pip tool as in the previous section Install postgresql-server-dev-9.4 package: sudo apt-get install postgresql-server-dev-9.4 Install the psycopg2 module using pip: sudo pip3 install psycopg2 Create and run the following Python 3 script: import psycopg2 conn = psycopg2 . connect ( \"dbname=mem:testdb user=sa password=password host=localhost port=9123\" ) try : curs = conn . cursor () # Fetch the last 10 timestamps curs . execute ( \"SELECT TIMER FROM \\\" WR_data \\\" ORDER BY TIMER DESC LIMIT 10\" ) print ( curs . fetchall ()) finally : if curs is not None : curs . close () if conn is not None : conn . close () It should print on the console the latest 10 timestamp values generated by the Timer component like the previous script.","title":"Access the data using Python"},{"location":"builtin/h2-database/","text":"H2 Database: Features and Usage Starting from version 3.1.0, Eclipse Kura includes the H2 database engine . This document provides a description of the main features of the H2 database integrated with Eclipse Kura and gives some basic information about its usage. Supported Features Eclipse Kura supports the following H2 database features: Persistence modes : The H2 implementation currently supports in-memory and file-based database instances. See Persistence Modes for more details. Multiple database instances : It is possible to create and configure multiple database instances from the Kura Web UI, these instances can be selectively consumed by applications. A default database instance is created automatically. TCP Server : The current implementation allows external processes to access the database instances managed by Kura using TCP. This enables the integration of external applications that can share data with Kura components using the database. Web based console : It is possible to start the H2 Web console directly from the Kura Web UI. The console can be used to inspect the database contents and perform arbitrary queries for debug purposes. Basic credential management : The current implementation allows to change the password of the admin DB user from the Kura Web UI. This allows to restrict access to existing database instances. Limitations The following list briefly describes some limitations of the H2 database integrated with Eclipse Kura: Private in-memory instances : Only named in-memory instances are supported (e.g. jdbc:h2:mem:<dbname> , where <dbname> is not the empty string), private instances represented by the jdbc:h2:mem: URL are currently not supported. Remote connections : The current implementation only supports embedded database instances. Connecting to remote instances using the jdbc:h2:tcp:* and jdbc:h2:ssl:* connector URLs is not supported. Changes to database related components The DataService in Eclipse Kura uses the H2 database by default for implementing the message store. However, there is no support for migrating an old HSQLDB database to the new H2. The new H2DbWireRecordFilter and H2DbWireRecordStore Wire components have been added. These components provide the same functionalities offered by the HSQL based DbWireRecordFilter and DbWireRecordStore components, but using the H2 database. The legacy components will continue to be available in order to keep backward compatibility, but will be deprecated since Kura 3.1.0 and should not be used for new installations. Usage Creating a new H2 database instance To create a new H2 database instance, use the following procedure: Open the Kura Web UI press and on the + button in the side menu, under the Services section. A pop-up dialog should appear. Select org.eclipse.kura.core.db.H2DbService from the Factories drop down list, enter an arbitrary name for the new instance and click Apply . An entry for the newly created instance should appear in the side menu under Services , click on it to review its configuration: Change the settings if needed and then click Apply . For more information about the DB URL format see http://www.h2database.com/html/features.html and Persistence Modes . It is not possible to create different DB instances that manage the same DB url. When creating a new instance please make sure that the URL specified in the db.connector.url field is not managed by another instance. Selecting a database instance for existing Kura components A database instance is identified by its Kura service pid . The pid for the default instance is org.eclipse.kura.db.H2DbService , the pid for instances created using the Web UI is the string entered in the Name field at step 2 of the previous section. The built-in Kura components that use database functionalities allow user to specify which instance to use in their configuration. These components are the DataService component of the cloud stack and the H2DbWireRecordFilter and H2DbWireRecordStore wire components. The configuration of each component contains a property that allows specifying the service pid of the desired instance: DataService The pid of the database instance can be specified using the store.db.service.pid field. DbWireRecordFilter The pid of the database instance can be specified using the db.service.pid field. DbWireRecordStore The pid of the database instance can be specified using the db.service.pid field. Enabling the TCP Server The TCP server can be used by creating an H2DbServer instance: Open the Kura Web UI press and on the + button in the side menu, under the Services section. A pop-up dialog should appear. Select org.eclipse.kura.core.db.H2DbServer from the Factories drop down list, enter an arbitrary name for the new instance and click Apply . Click on the name of the new server instance in the left side of the Web Ui. The configuration of the server component will appear: Set the db.server.type field to TCP Review the server options under db.server.commandline , check http://www.h2database.com/javadoc/org/h2/tools/Server.html for more information about the available options. The default settings, -tcpPort 9123 -tcpAllowOthers -ifExists , configure the server to bind on port 9123, to allow connections from any host and to allow access only to existing databases. Set the db.server.enabled to true . The server is now listening on the specified port. Make sure to review the firewall configuration in order to ensure that the server is reachable from the external process. Enabling the Web console In order to enable the H2 Web console, proceed as follows: Create a new H2DbServer instance like in the previous section. Set the db.server.type field to WEB Enter appropriate parameters for the Web server in the db.server.commandline field. An example of valid settings can be -webPort 9123 -webAllowOthers -ifExists . Set the db.server.enabled to true . The server is now listening on the specified port. Make sure to review the firewall configuration in order to ensure that the server is reachable from the external process. Use a browser to access the console. Open the http://<device-ip>:<web-console-port> URL, where <device-ip> is the IP address of the Kura device and <web-console-port> is the port specified at step 3. {:start=\"7\"} 7. Enter the DB URL as specified in the Kura configuration in the JDBC URL field and the credentials. Click on Connect , you should be able to access the console. Changing the password The prerequisite for being able to change the password is that Open the configuration of the desired database instance in the Kura Web UI. Enter the new password in the db.password field. Click Apply . If the H2DbServer instance fails to open a database, it will delete and recreate all database files. This behavior is aimed at preventing potential issues caused by incorrect credentials in the configuration snapshots. It is highly recommended to perform a backup of an existing database before trying to open it using a H2DbService instance and before changing the password. Persistence Modes The H2 database support several levels of persistence modes. In memory An in-memory database instance can be created using the following URL structure: jdbc:h2:mem:<dbname> , where <dbname> is a non-empty string that represents the database name. This configuration is suggested for database instances that are frequently updated. Examples: jdbc:h2:mem:kuradb jdbc:h2:mem:mydb The default database instance is in-memory by default and uses the jdbc:h2:mem:kuradb URL. Most persistent A persistent database instance can be created using the jdbc:h2:file:<dbpath> , where <dbpath> is a non-empty string that represents the database path. If no URL parameters are supplied the database will enable the transaction log by default. The transaction log is used to restore the database to a consistent state after a crash or power failure. This provides good protection against data losses but causes a lot of writes to the storage device, reducing both performance and the lifetime of flash-based storage devices. This configuration is suggested for database instances that are rarely updated. Examples: jdbc:h2:file:/opt/db/mydb Make sure to use absolute paths in the db URL since H2 does not support db paths relative to the working directory. Mostly persistent The transaction log can be disabled by appending the LOG=0 parameter to the DB URL. In this way it is possible to reduce the stress on the underlying storage device and increase performance, at the expense of a higher probability of losing data in case of power failure. In order to reduce the probability of data losses the H2DbService performs periodic checkpoints on the database. A checkpoint forces all pending modifications to be committed to the storage device. The interval in seconds between two consecutive checkpoints can be configured using the db.checkpoint.interval.seconds property. This configuration is suggested for database instances with intermediate update rates. Examples: jdbc:h2:file:/opt/db/mydb;LOG=0 Filesystem tuning The H2 database might become corrupted [1] in case of power failure. In case of file-backed database (e.g. mostly or most persistent), the following database mount options can improve database reliability, reducing the database corruption probability at the expense of reduced performance and lifetime of the flash storage devices: data=journal : From EXT4(5) Linux MAN Page: All data is committed into the journal prior to being written into the main filesystem. This setting only applies to ext3/ext4 filesystems. sync : From mount(8) Linux MAN Page: All I/O to the filesystem should be done synchronously. In case of media with limited number of write cycles (e.g. some flash drives) \"sync\" may cause life-cycle shortening. After some long running tests [1], it appears that the data=journal option alone is enough to reduce corruption probability (no corruption observed during the test). [1] https://github.com/eclipse/kura/issues/2169 In order to apply the options above, perform the following steps: 1 - Edit the /etc/fstab row for the filesystem containing the database file, appending the desired options to the fourth column, using comma as separator. For example on Raspbian an /etc/fstab file with data=journal enabled will look like the following: proc /proc proc defaults 0 0 PARTUUID=3920f25c-01 /boot vfat defaults 0 2 PARTUUID=3920f25c-02 / ext4 defaults,noatime,data=journal 0 1 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 2 - If the database resides on the root filesystem, the data=journal option must be specified in the kernel command line as well, by appending rootflags=data=journal . On Raspbian this can be done by editing the /boot/cmdline.txt file: dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=3920f25c-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait rootflags=data=journal","title":"H2 Database - Features and Usage"},{"location":"builtin/h2-database/#h2-database-features-and-usage","text":"Starting from version 3.1.0, Eclipse Kura includes the H2 database engine . This document provides a description of the main features of the H2 database integrated with Eclipse Kura and gives some basic information about its usage.","title":"H2 Database: Features and Usage"},{"location":"builtin/h2-database/#supported-features","text":"Eclipse Kura supports the following H2 database features: Persistence modes : The H2 implementation currently supports in-memory and file-based database instances. See Persistence Modes for more details. Multiple database instances : It is possible to create and configure multiple database instances from the Kura Web UI, these instances can be selectively consumed by applications. A default database instance is created automatically. TCP Server : The current implementation allows external processes to access the database instances managed by Kura using TCP. This enables the integration of external applications that can share data with Kura components using the database. Web based console : It is possible to start the H2 Web console directly from the Kura Web UI. The console can be used to inspect the database contents and perform arbitrary queries for debug purposes. Basic credential management : The current implementation allows to change the password of the admin DB user from the Kura Web UI. This allows to restrict access to existing database instances.","title":"Supported Features"},{"location":"builtin/h2-database/#limitations","text":"The following list briefly describes some limitations of the H2 database integrated with Eclipse Kura: Private in-memory instances : Only named in-memory instances are supported (e.g. jdbc:h2:mem:<dbname> , where <dbname> is not the empty string), private instances represented by the jdbc:h2:mem: URL are currently not supported. Remote connections : The current implementation only supports embedded database instances. Connecting to remote instances using the jdbc:h2:tcp:* and jdbc:h2:ssl:* connector URLs is not supported.","title":"Limitations"},{"location":"builtin/h2-database/#changes-to-database-related-components","text":"The DataService in Eclipse Kura uses the H2 database by default for implementing the message store. However, there is no support for migrating an old HSQLDB database to the new H2. The new H2DbWireRecordFilter and H2DbWireRecordStore Wire components have been added. These components provide the same functionalities offered by the HSQL based DbWireRecordFilter and DbWireRecordStore components, but using the H2 database. The legacy components will continue to be available in order to keep backward compatibility, but will be deprecated since Kura 3.1.0 and should not be used for new installations.","title":"Changes to database related components"},{"location":"builtin/h2-database/#usage","text":"","title":"Usage"},{"location":"builtin/h2-database/#creating-a-new-h2-database-instance","text":"To create a new H2 database instance, use the following procedure: Open the Kura Web UI press and on the + button in the side menu, under the Services section. A pop-up dialog should appear. Select org.eclipse.kura.core.db.H2DbService from the Factories drop down list, enter an arbitrary name for the new instance and click Apply . An entry for the newly created instance should appear in the side menu under Services , click on it to review its configuration: Change the settings if needed and then click Apply . For more information about the DB URL format see http://www.h2database.com/html/features.html and Persistence Modes . It is not possible to create different DB instances that manage the same DB url. When creating a new instance please make sure that the URL specified in the db.connector.url field is not managed by another instance.","title":"Creating a new H2 database instance"},{"location":"builtin/h2-database/#selecting-a-database-instance-for-existing-kura-components","text":"A database instance is identified by its Kura service pid . The pid for the default instance is org.eclipse.kura.db.H2DbService , the pid for instances created using the Web UI is the string entered in the Name field at step 2 of the previous section. The built-in Kura components that use database functionalities allow user to specify which instance to use in their configuration. These components are the DataService component of the cloud stack and the H2DbWireRecordFilter and H2DbWireRecordStore wire components. The configuration of each component contains a property that allows specifying the service pid of the desired instance: DataService The pid of the database instance can be specified using the store.db.service.pid field. DbWireRecordFilter The pid of the database instance can be specified using the db.service.pid field. DbWireRecordStore The pid of the database instance can be specified using the db.service.pid field.","title":"Selecting a database instance for existing Kura components"},{"location":"builtin/h2-database/#enabling-the-tcp-server","text":"The TCP server can be used by creating an H2DbServer instance: Open the Kura Web UI press and on the + button in the side menu, under the Services section. A pop-up dialog should appear. Select org.eclipse.kura.core.db.H2DbServer from the Factories drop down list, enter an arbitrary name for the new instance and click Apply . Click on the name of the new server instance in the left side of the Web Ui. The configuration of the server component will appear: Set the db.server.type field to TCP Review the server options under db.server.commandline , check http://www.h2database.com/javadoc/org/h2/tools/Server.html for more information about the available options. The default settings, -tcpPort 9123 -tcpAllowOthers -ifExists , configure the server to bind on port 9123, to allow connections from any host and to allow access only to existing databases. Set the db.server.enabled to true . The server is now listening on the specified port. Make sure to review the firewall configuration in order to ensure that the server is reachable from the external process.","title":"Enabling the TCP Server"},{"location":"builtin/h2-database/#enabling-the-web-console","text":"In order to enable the H2 Web console, proceed as follows: Create a new H2DbServer instance like in the previous section. Set the db.server.type field to WEB Enter appropriate parameters for the Web server in the db.server.commandline field. An example of valid settings can be -webPort 9123 -webAllowOthers -ifExists . Set the db.server.enabled to true . The server is now listening on the specified port. Make sure to review the firewall configuration in order to ensure that the server is reachable from the external process. Use a browser to access the console. Open the http://<device-ip>:<web-console-port> URL, where <device-ip> is the IP address of the Kura device and <web-console-port> is the port specified at step 3. {:start=\"7\"} 7. Enter the DB URL as specified in the Kura configuration in the JDBC URL field and the credentials. Click on Connect , you should be able to access the console.","title":"Enabling the Web console"},{"location":"builtin/h2-database/#changing-the-password","text":"The prerequisite for being able to change the password is that Open the configuration of the desired database instance in the Kura Web UI. Enter the new password in the db.password field. Click Apply . If the H2DbServer instance fails to open a database, it will delete and recreate all database files. This behavior is aimed at preventing potential issues caused by incorrect credentials in the configuration snapshots. It is highly recommended to perform a backup of an existing database before trying to open it using a H2DbService instance and before changing the password.","title":"Changing the password"},{"location":"builtin/h2-database/#persistence-modes","text":"The H2 database support several levels of persistence modes.","title":"Persistence Modes"},{"location":"builtin/h2-database/#in-memory","text":"An in-memory database instance can be created using the following URL structure: jdbc:h2:mem:<dbname> , where <dbname> is a non-empty string that represents the database name. This configuration is suggested for database instances that are frequently updated. Examples: jdbc:h2:mem:kuradb jdbc:h2:mem:mydb The default database instance is in-memory by default and uses the jdbc:h2:mem:kuradb URL.","title":"In memory"},{"location":"builtin/h2-database/#most-persistent","text":"A persistent database instance can be created using the jdbc:h2:file:<dbpath> , where <dbpath> is a non-empty string that represents the database path. If no URL parameters are supplied the database will enable the transaction log by default. The transaction log is used to restore the database to a consistent state after a crash or power failure. This provides good protection against data losses but causes a lot of writes to the storage device, reducing both performance and the lifetime of flash-based storage devices. This configuration is suggested for database instances that are rarely updated. Examples: jdbc:h2:file:/opt/db/mydb Make sure to use absolute paths in the db URL since H2 does not support db paths relative to the working directory.","title":"Most persistent"},{"location":"builtin/h2-database/#mostly-persistent","text":"The transaction log can be disabled by appending the LOG=0 parameter to the DB URL. In this way it is possible to reduce the stress on the underlying storage device and increase performance, at the expense of a higher probability of losing data in case of power failure. In order to reduce the probability of data losses the H2DbService performs periodic checkpoints on the database. A checkpoint forces all pending modifications to be committed to the storage device. The interval in seconds between two consecutive checkpoints can be configured using the db.checkpoint.interval.seconds property. This configuration is suggested for database instances with intermediate update rates. Examples: jdbc:h2:file:/opt/db/mydb;LOG=0","title":"Mostly persistent"},{"location":"builtin/h2-database/#filesystem-tuning","text":"The H2 database might become corrupted [1] in case of power failure. In case of file-backed database (e.g. mostly or most persistent), the following database mount options can improve database reliability, reducing the database corruption probability at the expense of reduced performance and lifetime of the flash storage devices: data=journal : From EXT4(5) Linux MAN Page: All data is committed into the journal prior to being written into the main filesystem. This setting only applies to ext3/ext4 filesystems. sync : From mount(8) Linux MAN Page: All I/O to the filesystem should be done synchronously. In case of media with limited number of write cycles (e.g. some flash drives) \"sync\" may cause life-cycle shortening. After some long running tests [1], it appears that the data=journal option alone is enough to reduce corruption probability (no corruption observed during the test). [1] https://github.com/eclipse/kura/issues/2169 In order to apply the options above, perform the following steps: 1 - Edit the /etc/fstab row for the filesystem containing the database file, appending the desired options to the fourth column, using comma as separator. For example on Raspbian an /etc/fstab file with data=journal enabled will look like the following: proc /proc proc defaults 0 0 PARTUUID=3920f25c-01 /boot vfat defaults 0 2 PARTUUID=3920f25c-02 / ext4 defaults,noatime,data=journal 0 1 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 2 - If the database resides on the root filesystem, the data=journal option must be specified in the kernel command line as well, by appending rootflags=data=journal . On Raspbian this can be done by editing the /boot/cmdline.txt file: dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=3920f25c-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait rootflags=data=journal","title":"Filesystem tuning"},{"location":"builtin/intro/","text":"Introduction This section describes the administrative tools available using the Kura Gateway Administration Console . This web interface provides the ability to configure all services and applications that are installed and running on the gateway and is shown in the following screen capture: This section describes the functionality and configuration of the standard services included in Eclipse Kura.","title":"Introduction"},{"location":"builtin/intro/#introduction","text":"This section describes the administrative tools available using the Kura Gateway Administration Console . This web interface provides the ability to configure all services and applications that are installed and running on the gateway and is shown in the following screen capture: This section describes the functionality and configuration of the standard services included in Eclipse Kura.","title":"Introduction"},{"location":"builtin/nvidiatm-triton-server-inference-engine/","text":"Nvidia\u2122 Triton Server inference engine The Nvidia\u2122 Triton Server is an open-source inference service software that enables the user to deploy trained AI models from any framework on GPU or CPU infrastructure. It supports all major frameworks like TensorFlow, TensorRT, PyTorch, ONNX Runtime, and even custom framework backend. With specific backends, it is also possible to run Python scripts, mainly for pre-and post-processing purposes, and exploit the DALI building block for optimized operations. For more detail about the Triton Server, please refer to the official website . The Kura Triton Server component is the implementation of the inference engine APIs and provides methods for interacting with a local or remote Nvidia\u2122 Triton Server. As presented below, the component enables the user to configure a local server running on the gateway or to communicate to an external server to load specific models. The parameters used to configure the Triton Service are the following: Local Nvidia Triton Server : If enabled, a local native Nvidia Triton Server is started on the gateway. In this case, the model repository and backends path are mandatory. Moreover, the server address property is overridden and set to localhost. Be aware that the Triton Server has to be already installed on the system. Nvidia Triton Server address : the address of the Nvidia Triton Server. Nvidia Triton Server ports : the ports used to connect to the server for HTTP, GRPC, and Metrics services. Local model repository path : Only for a local instance, specify the path on the filesystem where the models are stored. Local model decryption password : Only for local instance, specify the password to be used for decrypting models stored in the model repository. If none is specified, models are supposed to be plaintext. Inference Models : a comma-separated list of inference model names that the server will load. The models have to be already present in the filesystem where the server is running. This option simply tells the server to load the given models from a local or remote repository. Local backends path : Only for a local instance, specify the path on the filesystem where the backends are stored. Optional configuration for the local backends : Only for local instance, a semi-colon separated list of configuration for the backends. i.e. tensorflow,version=2;tensorflow,allow-soft-placement=false Timeout (in seconds) for time consuming tasks : Timeout (in seconds) for time consuming tasks like server startup, shutdown or model load. If the task exceeds the timeout, the operation will be terminated with an error. Pay attention on the ports used for communicating with the Triton Server. The default ports are the 8000-8002, but these are tipically used by Kura for debug purposes. Pay attention on the ports used for communicating with the Triton Server. The default ports are the 8000-8002, but these are tipically used by Kura for debug purposes. Nvidia\u2122 Triton Server installation Before running Kura's Triton Server Service, you must install the Triton Inference Server. Here you can find the necessary steps for the two suggested installation methods. Native Triton installation on Jetson devices A release of Triton for JetPack is provided in the tar file in the Triton Inference Server release notes . Full documentation is available here . Installation steps: - Before running the executable you need to install the Runtime Dependencies for Triton . - After doing so you can extract the tar file and run the executable in the bin folder. - It is highly recommended to add the tritonserver executable to your path or symlinking the executable to /usr/local/bin . Triton Docker image installation Before you can use the Triton Docker image you must install Docker . If you plan on using a GPU for inference you must also install the NVIDIA Container Toolkit . Pull the image using the following command. $ docker pull nvcr.io/nvidia/tritonserver:<xx.yy>-py3 Where <xx.yy> is the version of Triton that you want to pull. Triton Server setup The Triton Inference Server serves models from one or more model repositories that are specified when the server is started. The model repository is the directory where you place the models that you want Triton to serve. Be sure to follow the instructions to setup the model repository directory. Further information about an example Triton Server setup can be found in the official documentation . Configuration for a local native Triton Server Requirement : tritonserver executable needs to be available in the path to the kurad user. Be sure to have a working Triton Server installation before configuring the local native Triton Server instance through Kura UI. When the Local Nvidia Triton Server option is set to true, a local instance of the Nvidia\u2122 Triton Server is started on the gateway. The following configuration is required: Local Nvidia Triton Server : true Nvidia Triton Server address : localhost Nvidia Triton Server ports : \\<mandatory> Local model repository path : \\<mandatory> Inference Models : \\<mandatory>. Note that the models have to be already present on the filesystem. Local backends path : \\<mandatory> The typical command used to start the Triton Server is like this: tritonserver --model-repository = <model_repository_path> \\ --backend-directory = <backend_repository_path> \\ --backend-config = <backend_config> \\ --http-port = <http_port> \\ --grpc-port = <grpc_port> \\ --metrics-port = <metrics_port> \\ --model-control-mode = explicit \\ --load-model = <model_name_1> \\ --load-model = <model_name_2> \\ ... Configuration for a local Triton Server running in a Docker container If the Nvidia\u2122 Triton Server is running as a Docker container in the gateway, the following configuration is required: Local Nvidia Triton Server : false Nvidia Triton Server address : localhost Nvidia Triton Server ports : \\<mandatory> Inference Models : \\<mandatory>. The models have to be already present on the filesystem. In order to correctly load the models at runtime, configure the server with the --model-control-mode=explicit option. The typical command used for running the docker container is as follows. Note the forward of the ports to not interfere with Kura. docker run --rm \\ -p4000:8000 \\ -p4001:8001 \\ -p4002:8002 \\ --shm-size = 150m \\ -v path/to/models:/models \\ nvcr.io/nvidia/tritonserver: [ version ] \\ tritonserver --model-repository = /models --model-control-mode = explicit Configuration for a remote Triton Server When the Nvidia\u2122 Triton Server is running on a remote server, the following configuration is needed: Local Nvidia Triton Server : false Nvidia Triton Server address : \\<mandatory> Nvidia Triton Server ports : \\<mandatory> Inference Models : \\<mandatory>. The models have to be already present on the filesystem. AI Model Encryption support For ensuring inference integrity and providing copyright protection of deep-learning models on edge devices, Kura provides decryption capabilities for trained models to be served through the Triton Server. How it works Prerequisites : a deep-learning trained model (or more) exists with the corresponding necessary configuration for running on the Triton Server without encryption. A folder containing the required files (model, configuration etc) has been tested on a Triton Server. Restrictions : if model encryption is used, the following restrictions apply: - model encryption support is only available for a local Triton Server instance - all models in the folder containing the encrypted models must be encrypted - all models must be encrypted with OpenPGP-compliant AES 256 cipher algorithm - all models must be encrypted with the same password Once the development of the deep-learning model is complete, the developer who wants to deploy the model on the edge device in a secure manner can proceed with encrypting the Triton model using the procedure detailed below. After encrypting the model he/she can transfer the file on the edge device using his/her preferred method. Kura will keep the stored model protected at all times and have the model decrypted in runtime only for use by the Inference Server Runtime. As soon as the model is correctly loaded into memory the decrypted model will be removed from the filesystem. As an additional security measure, the Model Repository containing the decrypted models will be stored in a temporary subfolder and will feature restrictive permission such that only Kura, the Inference Server and the root user will be able to access it. Encryption procedure Given a trained model inside the folder tf_autoencoder_fp32 (for example) with the following layout (see the official documentation for details): tf_autoencoder_fp32 \u251c\u2500\u2500 1 \u2502 \u2514\u2500\u2500 model.savedmodel \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 keras_metadata.pb \u2502 \u251c\u2500\u2500 saved_model.pb \u2502 \u2514\u2500\u2500 variables \u2502 \u251c\u2500\u2500 variables.data-00000-of-00001 \u2502 \u2514\u2500\u2500 variables.index \u2514\u2500\u2500 config.pbtxt Compress the model into a zip archive with the following command: zip -vr tf_autoencoder_fp32.zip tf_autoencoder_fp32/ then encrypt it with the AES 256 algorithm using the following gpg command: gpg --armor --symmetric --cipher-algo AES256 tf_autoencoder_fp32.zip The resulting archive tf_autoencoder_fp32.zip.asc can be transferred to the Local Model Repository Path on the target machine and will be decrypted by Kura.","title":"Nvidia\u2122 Triton Server inference engine"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#nvidiatm-triton-server-inference-engine","text":"The Nvidia\u2122 Triton Server is an open-source inference service software that enables the user to deploy trained AI models from any framework on GPU or CPU infrastructure. It supports all major frameworks like TensorFlow, TensorRT, PyTorch, ONNX Runtime, and even custom framework backend. With specific backends, it is also possible to run Python scripts, mainly for pre-and post-processing purposes, and exploit the DALI building block for optimized operations. For more detail about the Triton Server, please refer to the official website . The Kura Triton Server component is the implementation of the inference engine APIs and provides methods for interacting with a local or remote Nvidia\u2122 Triton Server. As presented below, the component enables the user to configure a local server running on the gateway or to communicate to an external server to load specific models. The parameters used to configure the Triton Service are the following: Local Nvidia Triton Server : If enabled, a local native Nvidia Triton Server is started on the gateway. In this case, the model repository and backends path are mandatory. Moreover, the server address property is overridden and set to localhost. Be aware that the Triton Server has to be already installed on the system. Nvidia Triton Server address : the address of the Nvidia Triton Server. Nvidia Triton Server ports : the ports used to connect to the server for HTTP, GRPC, and Metrics services. Local model repository path : Only for a local instance, specify the path on the filesystem where the models are stored. Local model decryption password : Only for local instance, specify the password to be used for decrypting models stored in the model repository. If none is specified, models are supposed to be plaintext. Inference Models : a comma-separated list of inference model names that the server will load. The models have to be already present in the filesystem where the server is running. This option simply tells the server to load the given models from a local or remote repository. Local backends path : Only for a local instance, specify the path on the filesystem where the backends are stored. Optional configuration for the local backends : Only for local instance, a semi-colon separated list of configuration for the backends. i.e. tensorflow,version=2;tensorflow,allow-soft-placement=false Timeout (in seconds) for time consuming tasks : Timeout (in seconds) for time consuming tasks like server startup, shutdown or model load. If the task exceeds the timeout, the operation will be terminated with an error. Pay attention on the ports used for communicating with the Triton Server. The default ports are the 8000-8002, but these are tipically used by Kura for debug purposes. Pay attention on the ports used for communicating with the Triton Server. The default ports are the 8000-8002, but these are tipically used by Kura for debug purposes.","title":"Nvidia\u2122 Triton Server inference engine"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#nvidiatm-triton-server-installation","text":"Before running Kura's Triton Server Service, you must install the Triton Inference Server. Here you can find the necessary steps for the two suggested installation methods.","title":"Nvidia\u2122 Triton Server installation"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#native-triton-installation-on-jetson-devices","text":"A release of Triton for JetPack is provided in the tar file in the Triton Inference Server release notes . Full documentation is available here . Installation steps: - Before running the executable you need to install the Runtime Dependencies for Triton . - After doing so you can extract the tar file and run the executable in the bin folder. - It is highly recommended to add the tritonserver executable to your path or symlinking the executable to /usr/local/bin .","title":"Native Triton installation on Jetson devices"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#triton-docker-image-installation","text":"Before you can use the Triton Docker image you must install Docker . If you plan on using a GPU for inference you must also install the NVIDIA Container Toolkit . Pull the image using the following command. $ docker pull nvcr.io/nvidia/tritonserver:<xx.yy>-py3 Where <xx.yy> is the version of Triton that you want to pull.","title":"Triton Docker image installation"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#triton-server-setup","text":"The Triton Inference Server serves models from one or more model repositories that are specified when the server is started. The model repository is the directory where you place the models that you want Triton to serve. Be sure to follow the instructions to setup the model repository directory. Further information about an example Triton Server setup can be found in the official documentation .","title":"Triton Server setup"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#configuration-for-a-local-native-triton-server","text":"Requirement : tritonserver executable needs to be available in the path to the kurad user. Be sure to have a working Triton Server installation before configuring the local native Triton Server instance through Kura UI. When the Local Nvidia Triton Server option is set to true, a local instance of the Nvidia\u2122 Triton Server is started on the gateway. The following configuration is required: Local Nvidia Triton Server : true Nvidia Triton Server address : localhost Nvidia Triton Server ports : \\<mandatory> Local model repository path : \\<mandatory> Inference Models : \\<mandatory>. Note that the models have to be already present on the filesystem. Local backends path : \\<mandatory> The typical command used to start the Triton Server is like this: tritonserver --model-repository = <model_repository_path> \\ --backend-directory = <backend_repository_path> \\ --backend-config = <backend_config> \\ --http-port = <http_port> \\ --grpc-port = <grpc_port> \\ --metrics-port = <metrics_port> \\ --model-control-mode = explicit \\ --load-model = <model_name_1> \\ --load-model = <model_name_2> \\ ...","title":"Configuration for a local native Triton Server"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#configuration-for-a-local-triton-server-running-in-a-docker-container","text":"If the Nvidia\u2122 Triton Server is running as a Docker container in the gateway, the following configuration is required: Local Nvidia Triton Server : false Nvidia Triton Server address : localhost Nvidia Triton Server ports : \\<mandatory> Inference Models : \\<mandatory>. The models have to be already present on the filesystem. In order to correctly load the models at runtime, configure the server with the --model-control-mode=explicit option. The typical command used for running the docker container is as follows. Note the forward of the ports to not interfere with Kura. docker run --rm \\ -p4000:8000 \\ -p4001:8001 \\ -p4002:8002 \\ --shm-size = 150m \\ -v path/to/models:/models \\ nvcr.io/nvidia/tritonserver: [ version ] \\ tritonserver --model-repository = /models --model-control-mode = explicit","title":"Configuration for a local Triton Server running in a Docker container"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#configuration-for-a-remote-triton-server","text":"When the Nvidia\u2122 Triton Server is running on a remote server, the following configuration is needed: Local Nvidia Triton Server : false Nvidia Triton Server address : \\<mandatory> Nvidia Triton Server ports : \\<mandatory> Inference Models : \\<mandatory>. The models have to be already present on the filesystem.","title":"Configuration for a remote Triton Server"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#ai-model-encryption-support","text":"For ensuring inference integrity and providing copyright protection of deep-learning models on edge devices, Kura provides decryption capabilities for trained models to be served through the Triton Server.","title":"AI Model Encryption support"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#how-it-works","text":"Prerequisites : a deep-learning trained model (or more) exists with the corresponding necessary configuration for running on the Triton Server without encryption. A folder containing the required files (model, configuration etc) has been tested on a Triton Server. Restrictions : if model encryption is used, the following restrictions apply: - model encryption support is only available for a local Triton Server instance - all models in the folder containing the encrypted models must be encrypted - all models must be encrypted with OpenPGP-compliant AES 256 cipher algorithm - all models must be encrypted with the same password Once the development of the deep-learning model is complete, the developer who wants to deploy the model on the edge device in a secure manner can proceed with encrypting the Triton model using the procedure detailed below. After encrypting the model he/she can transfer the file on the edge device using his/her preferred method. Kura will keep the stored model protected at all times and have the model decrypted in runtime only for use by the Inference Server Runtime. As soon as the model is correctly loaded into memory the decrypted model will be removed from the filesystem. As an additional security measure, the Model Repository containing the decrypted models will be stored in a temporary subfolder and will feature restrictive permission such that only Kura, the Inference Server and the root user will be able to access it.","title":"How it works"},{"location":"builtin/nvidiatm-triton-server-inference-engine/#encryption-procedure","text":"Given a trained model inside the folder tf_autoencoder_fp32 (for example) with the following layout (see the official documentation for details): tf_autoencoder_fp32 \u251c\u2500\u2500 1 \u2502 \u2514\u2500\u2500 model.savedmodel \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 keras_metadata.pb \u2502 \u251c\u2500\u2500 saved_model.pb \u2502 \u2514\u2500\u2500 variables \u2502 \u251c\u2500\u2500 variables.data-00000-of-00001 \u2502 \u2514\u2500\u2500 variables.index \u2514\u2500\u2500 config.pbtxt Compress the model into a zip archive with the following command: zip -vr tf_autoencoder_fp32.zip tf_autoencoder_fp32/ then encrypt it with the AES 256 algorithm using the following gpg command: gpg --armor --symmetric --cipher-algo AES256 tf_autoencoder_fp32.zip The resulting archive tf_autoencoder_fp32.zip.asc can be transferred to the Local Model Repository Path on the target machine and will be decrypted by Kura.","title":"Encryption procedure"},{"location":"builtin/position-service/","text":"Position Service The PositionService provides the geographic position of the gateway if a GPS component is available and enabled. When this service is enabled and provides a valid geographic position, this position is published in the gateway birth certificate and its location is updated on the Everyware Cloud Console. The GPS connection parameters must be defined in order to allow the service to receive the GPS frames. The PositionService supports direct access to gps device or the connection to that through gpsd. For a device that is not connected to a GPS, it is possible to define a static position by entering latitude, longitude, and altitude. In this case, the position is returned by the PositionService as if it were an actual GPS position. This may be useful when a gateway is installed in a known place and does not move. To use this service, select the PositionService option located in the Services area as shown in the screen capture below. This service provides the following configuration parameters: enabled - defines whether or not this service is enabled or disabled. (Required field.) static - specifies true or false whether to use a static position instead of a GPS. (Required field.) provider - species which position provider use, can be gpsd or serial. gpsd - gpsd service daemon if is available on the system. serial - direct access to gps device through serial or usb port. gpsd.host - host where gpsd service deamon is running. (required only if gpsd provider is selected.) gpsd.port - port where gpsd service is listening. (required only if gpsd provider is selected.) latitude - provides the static latitude value in degrees. longitude - provides the static longitude value in degrees. altitude - provides the static altitude value in meters. port - supplies the USB or serial port of the GPS device. (required only if serial provider is selected.) baudRate - supplies the baud rate of the GPS device. (required only if serial provider is selected.) bitsPerWord - sets the number of bits per word (databits) for the serial communication to the GPS device. (required only if serial provider is selected.) stopbits - sets the number of stop bits for the serial communication to the GPS device. (required only if serial provider is selected.) parity - sets the parity for the serial communication to the GPS device. (required only if serial provider is selected.)","title":"Position Service"},{"location":"builtin/position-service/#position-service","text":"The PositionService provides the geographic position of the gateway if a GPS component is available and enabled. When this service is enabled and provides a valid geographic position, this position is published in the gateway birth certificate and its location is updated on the Everyware Cloud Console. The GPS connection parameters must be defined in order to allow the service to receive the GPS frames. The PositionService supports direct access to gps device or the connection to that through gpsd. For a device that is not connected to a GPS, it is possible to define a static position by entering latitude, longitude, and altitude. In this case, the position is returned by the PositionService as if it were an actual GPS position. This may be useful when a gateway is installed in a known place and does not move. To use this service, select the PositionService option located in the Services area as shown in the screen capture below. This service provides the following configuration parameters: enabled - defines whether or not this service is enabled or disabled. (Required field.) static - specifies true or false whether to use a static position instead of a GPS. (Required field.) provider - species which position provider use, can be gpsd or serial. gpsd - gpsd service daemon if is available on the system. serial - direct access to gps device through serial or usb port. gpsd.host - host where gpsd service deamon is running. (required only if gpsd provider is selected.) gpsd.port - port where gpsd service is listening. (required only if gpsd provider is selected.) latitude - provides the static latitude value in degrees. longitude - provides the static longitude value in degrees. altitude - provides the static altitude value in meters. port - supplies the USB or serial port of the GPS device. (required only if serial provider is selected.) baudRate - supplies the baud rate of the GPS device. (required only if serial provider is selected.) bitsPerWord - sets the number of bits per word (databits) for the serial communication to the GPS device. (required only if serial provider is selected.) stopbits - sets the number of stop bits for the serial communication to the GPS device. (required only if serial provider is selected.) parity - sets the parity for the serial communication to the GPS device. (required only if serial provider is selected.)","title":"Position Service"},{"location":"builtin/rest-service/","text":"REST Service Eclipse Kura provides a built-in REST Service based on the osgi-jax-rs-connector project. By default, REST service providers register their services using the context path /services . The REST service provides the BASIC Authentication support and HTTPS client certificate authentication support. REST API access is available on all HTTP ports defined in the Security -> Http Service section, unless access is restricted to dedicated ports using the corresponding configuration parameter (see below). Certificate authentication support is only available on the HTTPS With Certificate Authentication Ports configured in Security -> Http Service section. Kura Identity names and passwords can be used for BASIC Authentication. Certificate authentication follows the same rules as Kura Web Console access. If the forced password change feature for a given identity is enabled, REST API password authentication will be blocked for that identity until the password is updated by the user or the feature is manually disabled. Certificate authentication will continue to be allowed even if the forced password change feature is enabled JAX-RS roles are mapped to ESF permissions, the name of a permission associated with a JAX-RS role is the rest. prefix followed by the role name. For example the assets role is mapped to the rest.assets permission. REST related permissions can be assigned to an identity using the ESF Gateway Administration Console in the Identities section. RestService configuration The RestService configuration contains an Allowed Ports parameter that can be used to restrict REST API access to specific ports. If the port list is left empty, access will be enabled on all available ports. Starting from Kura 5.2.0, the RestService configuration provides options to disable the built-in authentication methods. Custom authentication methods Starting from Kura 5.2.0, it is also possible to develop custom REST authentication method providers by registering an implementation of the org.eclipse.kura.rest.auth.AuthenticationProvider interface as an OSGi service. The org.eclipse.kura.example.rest.authentication.provider bundle in Kura repository provides an example on how to implement a custom authentication method. The System Administrator is required to specify: user.name - Specifies the list of users allowed to use the REST APIs password - Specifies the password for each user roles - The list of roles for each user as a list separated by the ';' character of the users allowed to interact with the REST APIs provided by this ESF bundle. By default, ESF comes pre-configured with the following credentials: user.name - admin password - admin roles - assets Assets REST APIs ESF exposes REST APIs for the Asset instances instantiated in the framework. Assets REST APIs are available in the context path /services/assets . Following, the supported REST endpoints: Method Path Roles Allowed Encoding Request Parameters Description GET / assets JSON None Returns the list of available assets. GET /{pid} assets JSON None Returns the list of available channels for the selected asset (specified by the corresponding PID) GET /{pid}/_read assets JSON None Returns the read for all the READ channels in the selected Asset POST /{pid}/_read assets JSON The list of channels where the READ operation should be performed. The expected format is: { \"channels\":[ \"channel-1\", \"channel-2\" ] } Returns the result of the read operation for the specified channels. POST /{pid}/_write assets JSON The list of channels and associated values that will be used for the WRITE operation. The expected format is: { \"channels\":[ { \"name\":\"channel-1\", \"type\":\"INTEGER\", \"value\":10 } ] } Performs the write operation for the specified channels returning the result of the operation.","title":"REST Service"},{"location":"builtin/rest-service/#rest-service","text":"Eclipse Kura provides a built-in REST Service based on the osgi-jax-rs-connector project. By default, REST service providers register their services using the context path /services . The REST service provides the BASIC Authentication support and HTTPS client certificate authentication support. REST API access is available on all HTTP ports defined in the Security -> Http Service section, unless access is restricted to dedicated ports using the corresponding configuration parameter (see below). Certificate authentication support is only available on the HTTPS With Certificate Authentication Ports configured in Security -> Http Service section. Kura Identity names and passwords can be used for BASIC Authentication. Certificate authentication follows the same rules as Kura Web Console access. If the forced password change feature for a given identity is enabled, REST API password authentication will be blocked for that identity until the password is updated by the user or the feature is manually disabled. Certificate authentication will continue to be allowed even if the forced password change feature is enabled JAX-RS roles are mapped to ESF permissions, the name of a permission associated with a JAX-RS role is the rest. prefix followed by the role name. For example the assets role is mapped to the rest.assets permission. REST related permissions can be assigned to an identity using the ESF Gateway Administration Console in the Identities section.","title":"REST Service"},{"location":"builtin/rest-service/#restservice-configuration","text":"The RestService configuration contains an Allowed Ports parameter that can be used to restrict REST API access to specific ports. If the port list is left empty, access will be enabled on all available ports. Starting from Kura 5.2.0, the RestService configuration provides options to disable the built-in authentication methods.","title":"RestService configuration"},{"location":"builtin/rest-service/#custom-authentication-methods","text":"Starting from Kura 5.2.0, it is also possible to develop custom REST authentication method providers by registering an implementation of the org.eclipse.kura.rest.auth.AuthenticationProvider interface as an OSGi service. The org.eclipse.kura.example.rest.authentication.provider bundle in Kura repository provides an example on how to implement a custom authentication method. The System Administrator is required to specify: user.name - Specifies the list of users allowed to use the REST APIs password - Specifies the password for each user roles - The list of roles for each user as a list separated by the ';' character of the users allowed to interact with the REST APIs provided by this ESF bundle. By default, ESF comes pre-configured with the following credentials: user.name - admin password - admin roles - assets","title":"Custom authentication methods"},{"location":"builtin/rest-service/#assets-rest-apis","text":"ESF exposes REST APIs for the Asset instances instantiated in the framework. Assets REST APIs are available in the context path /services/assets . Following, the supported REST endpoints: Method Path Roles Allowed Encoding Request Parameters Description GET / assets JSON None Returns the list of available assets. GET /{pid} assets JSON None Returns the list of available channels for the selected asset (specified by the corresponding PID) GET /{pid}/_read assets JSON None Returns the read for all the READ channels in the selected Asset POST /{pid}/_read assets JSON The list of channels where the READ operation should be performed. The expected format is: { \"channels\":[ \"channel-1\", \"channel-2\" ] } Returns the result of the read operation for the specified channels. POST /{pid}/_write assets JSON The list of channels and associated values that will be used for the WRITE operation. The expected format is: { \"channels\":[ { \"name\":\"channel-1\", \"type\":\"INTEGER\", \"value\":10 } ] } Performs the write operation for the specified channels returning the result of the operation.","title":"Assets REST APIs"},{"location":"builtin/simple-artemis-mqtt-broker-service/","text":"Simple Artemis MQTT Broker Service Eclipse Kura provides, out of the box, an Apache ActiveMQ Artemis broker. By default, this instance is disabled but, selecting the Simple Artemis MQTT Broker option in Services it is possible to enable a basic instance of an \u200bActiveMQ-7 broker with MQTT capabilities. The service has the following configuration fields: Enabled - (Required) - Enables the broker instance MQTT address - MQTT broker listener address. In order to allow access to the broker from processes running on external nodes, make sure to bind the server to an externally accessible address. Setting this parameter to 0.0.0.0 binds to all addresses. MQTT port - (Required) - MQTT broker port User name - The username\u200b required to access to the broker Password of the user - The password required to connect. If the password is empty, no password will be required to connect.","title":"Simple Artemis MQTT Broker Service"},{"location":"builtin/simple-artemis-mqtt-broker-service/#simple-artemis-mqtt-broker-service","text":"Eclipse Kura provides, out of the box, an Apache ActiveMQ Artemis broker. By default, this instance is disabled but, selecting the Simple Artemis MQTT Broker option in Services it is possible to enable a basic instance of an \u200bActiveMQ-7 broker with MQTT capabilities. The service has the following configuration fields: Enabled - (Required) - Enables the broker instance MQTT address - MQTT broker listener address. In order to allow access to the broker from processes running on external nodes, make sure to bind the server to an externally accessible address. Setting this parameter to 0.0.0.0 binds to all addresses. MQTT port - (Required) - MQTT broker port User name - The username\u200b required to access to the broker Password of the user - The password required to connect. If the password is empty, no password will be required to connect.","title":"Simple Artemis MQTT Broker Service"},{"location":"builtin/watchdog-service/","text":"Watchdog Service The WatchdogService provides methods for starting, stopping, and updating a hardware watchdog if it is present on the system. Once started, the watchdog must be updated to prevent the system from rebooting. To use this service, select the WatchdogService option located in the Services area as shown in the screen capture below. This service provides the following configuration parameters: enabled - sets whether or not this service is enabled or disabled. (Required field.) pingInterval - defines the maximum time interval between two watchdogs' refresh to prevent the system from rebooting. (Required field.) Watchdog device path - sets the watchdog device path. (Required field.) Reboot Cause File Path - sets the path to the file that will contain the reboot cause information. (Required field.)","title":"Watchdog Service"},{"location":"builtin/watchdog-service/#watchdog-service","text":"The WatchdogService provides methods for starting, stopping, and updating a hardware watchdog if it is present on the system. Once started, the watchdog must be updated to prevent the system from rebooting. To use this service, select the WatchdogService option located in the Services area as shown in the screen capture below. This service provides the following configuration parameters: enabled - sets whether or not this service is enabled or disabled. (Required field.) pingInterval - defines the maximum time interval between two watchdogs' refresh to prevent the system from rebooting. (Required field.) Watchdog device path - sets the watchdog device path. (Required field.) Reboot Cause File Path - sets the path to the file that will contain the reboot cause information. (Required field.)","title":"Watchdog Service"},{"location":"cloud-api/app-dev-guide/","text":"Application developer guide This guide will provide information on how an application developer can leverage the new Generic Cloud Services APIs, in order to be able to properly use the CloudPublisher/CloudSubscriber API, publish a message, being notified of message delivery and of connection status changes. The Kura ExamplePublisher will be used as a reference. The application should bind itself to a CloudPublisher or CloudSubscriber instance, this can be done in different ways, such as using OSGi ServiceTracker s or by leveraging the Declarative Service layer. The recommended way to perform this operation is choosing the latter and allowing the user to customize the service references through component configuration. If the component metatype and definition are structured as described below, the Kura Web UI will show a dedicated widget in component configuration that helps the user to pick compatible CloudPublisher or CloudSubscriber instances. 1. Write component definition The first step involves declaring the Publisher or Subscriber references in component definition: <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" name= \"org.eclipse.kura.example.publisher.ExamplePublisher\" activate= \"activate\" deactivate= \"deactivate\" modified= \"updated\" enabled= \"true\" immediate= \"true\" configuration-policy= \"require\" > <implementation class= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> <!-- If the component is configurable through the Kura ConfigurationService, it must expose a Service. --> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> <service> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> </service> <reference name= \"CloudPublisher\" policy= \"static\" bind= \"setCloudPublisher\" unbind= \"unsetCloudPublisher\" cardinality= \"0..1\" interface= \"org.eclipse.kura.cloudconnection.publisher.CloudPublisher\" /> <reference name= \"CloudSubscriber\" policy= \"static\" bind= \"setCloudSubscriber\" unbind= \"unsetCloudSubscriber\" cardinality= \"0..1\" interface= \"org.eclipse.kura.cloudconnection.subscriber.CloudSubscriber\" /> </scr:component> The snipped above shows the definition of Kura ExamplePublisher, this component is capable of sending and receiving messages, and therefore defines two references, the first to a CloudPublisher and the second to a CloudSubscriber . In order to allow the user to customize the bindings at runtime, the target attribute of the references should not be specified at this point in component definition, as it will be set by the Web UI. Reference cardinality should be use the 0..1 or 0..n form, as it is not guaranteed that the references will point to a valid service instance during all the lifetime of the application component. For example, references can not be bound if the application has not been configured by the user yet or if the target service is missing. 2. Create component metatype Application metatype should declare an AD for each Publisher/Subscriber reference declared in component definition: <MetaData xmlns= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" localization= \"en_us\" > <OCD id= \"org.eclipse.kura.example.publisher.ExamplePublisher\" name= \"ExamplePublisher\" description= \"Example of a Configuring Kura Application.\" > <!-- ... --> <AD id= \"CloudPublisher.target\" name= \"CloudPublisher Target Filter\" type= \"String\" cardinality= \"0\" required= \"true\" default= \"(kura.service.pid=changeme)\" description= \"Specifies, as an OSGi target filter, the pid of the Cloud Publisher used to publish messages to the cloud platform.\" > </AD> <AD id= \"CloudSubscriber.target\" name= \"CloudSubscriber Target Filter\" type= \"String\" cardinality= \"0\" required= \"true\" default= \"(kura.service.pid=changeme)\" description= \"Specifies, as an OSGi target filter, the pid of the Cloud Subscriber used to receive messages from the cloud platform.\" > </AD> <!-- ... --> </OCD> <Designate pid= \"org.eclipse.kura.example.publisher.ExamplePublisher\" factoryPid= \"org.eclipse.kura.example.publisher.ExamplePublisher\" > <Object ocdref= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> </Designate> </MetaData> It is important to respect the following rules for some of the AD attributes: id : this attribute must have the following form: <reference name>.target where <reference name> should match the value of the name attribute of the corresponding reference in component definition. required : must be set to true default : must not be empty and must be a valid OSGi filter. The Web UI will renderer a dedicated widget for picking CloudPublisher and CloudSubscriber instances: 3. Write the bind/unbind methods in applicaiton code The last step involves defining some bind...() / unbind...() methods with a name that matches the values of the bind / unbind attributes of the references in component definition. public void setCloudPublisher ( CloudPublisher cloudPublisher ) { ... } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { ... } public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... } As stated above, since reference cardinality is declared as 0.. , the application must be prepared to handle the cases where references are not satisfied, and therefore CloudPublisher and CloudSubscriber instances are not available. 4. Publish a message If a CloudPublisher instance is bound, the application can publish messages using its publish() method: if ( nonNull ( this . cloudPublisher )) { KuraMessage message = new KuraMessage ( payload ); String messageId = this . cloudPublisher . publish ( message ); } 5. Receiving messages using a CloudSubscriber In order to receive messages from a CloudSubscriber , the application must implement and attach a CloudSubscriberListener to it. This can be done for example during CloudSubscriber binding: public class ExamplePublisher implements CloudSubscriberListener , ... { ... public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber = cloudSubscriber ; this . cloudSubscriber . registerCloudSubscriberListener ( ExamplePublisher . this ); ... } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber . unregisterCloudSubscriberListener ( ExamplePublisher . this ); ... this . cloudSubscriber = null ; } ... @Override public void onMessageArrived ( KuraMessage message ) { logReceivedMessage ( message ); } ... } The CloudSubscriber will invoke the onMessageArrived() method when new messages are received. 5. Receiving connection state notifications If an application is interested in cloud connection status change events (connected, disconnected, etc), it can implement and attach a CloudConnectionListener to a CloudPublisher or CloudSubscriber instance. public class ExamplePublisher implements CloudConnectionListener , ... { ... public void setCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher = cloudPublisher ; this . cloudPublisher . registerCloudConnectionListener ( ExamplePublisher . this ); ... } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher . unregisterCloudConnectionListener ( ExamplePublisher . this ); ... this . cloudPublisher = null ; } public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber = cloudSubscriber ; ... this . cloudSubscriber . registerCloudConnectionListener ( ExamplePublisher . this ); } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... this . cloudSubscriber . unregisterCloudConnectionListener ( ExamplePublisher . this ); this . cloudSubscriber = null ; } ... @Override public void onConnectionEstablished () { logger . info ( \"Connection established\" ); } @Override public void onConnectionLost () { logger . warn ( \"Connection lost!\" ); } @Override public void onDisconnected () { logger . warn ( \"On disconnected\" ); } ... } 6. Receiving message delivery notifications If an application is interested in message confirmation events and the underlying cloud connection supports it, it can implement and attach a CloudDeliveryListener to a CloudPublisher instance. public class ExamplePublisher implements CloudDeliveryListener , ... { ... public void setCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher = cloudPublisher ; ... this . cloudPublisher . registerCloudDeliveryListener ( ExamplePublisher . this ); } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { ... this . cloudPublisher . registerCloudDeliveryListener ( ExamplePublisher . this ); this . cloudPublisher = null ; } ... @Override public void onMessageConfirmed ( String messageId ) { logger . info ( \"Confirmed message with id: {}\" , messageId ); } ... } The CloudSubscriber will invoke the onMessageConfirmed() method when a published message is confirmed. In order to determine which message has been confirmed, the provided messageId can be compared with the id returned by the publish() call that published the message. Please note that if the underlying cloud connection is not able to provide message confirmation for the published message, the id returned by publish() will be null .","title":"Application developer guide"},{"location":"cloud-api/app-dev-guide/#application-developer-guide","text":"This guide will provide information on how an application developer can leverage the new Generic Cloud Services APIs, in order to be able to properly use the CloudPublisher/CloudSubscriber API, publish a message, being notified of message delivery and of connection status changes. The Kura ExamplePublisher will be used as a reference. The application should bind itself to a CloudPublisher or CloudSubscriber instance, this can be done in different ways, such as using OSGi ServiceTracker s or by leveraging the Declarative Service layer. The recommended way to perform this operation is choosing the latter and allowing the user to customize the service references through component configuration. If the component metatype and definition are structured as described below, the Kura Web UI will show a dedicated widget in component configuration that helps the user to pick compatible CloudPublisher or CloudSubscriber instances.","title":"Application developer guide"},{"location":"cloud-api/app-dev-guide/#1-write-component-definition","text":"The first step involves declaring the Publisher or Subscriber references in component definition: <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" name= \"org.eclipse.kura.example.publisher.ExamplePublisher\" activate= \"activate\" deactivate= \"deactivate\" modified= \"updated\" enabled= \"true\" immediate= \"true\" configuration-policy= \"require\" > <implementation class= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> <!-- If the component is configurable through the Kura ConfigurationService, it must expose a Service. --> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> <service> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> </service> <reference name= \"CloudPublisher\" policy= \"static\" bind= \"setCloudPublisher\" unbind= \"unsetCloudPublisher\" cardinality= \"0..1\" interface= \"org.eclipse.kura.cloudconnection.publisher.CloudPublisher\" /> <reference name= \"CloudSubscriber\" policy= \"static\" bind= \"setCloudSubscriber\" unbind= \"unsetCloudSubscriber\" cardinality= \"0..1\" interface= \"org.eclipse.kura.cloudconnection.subscriber.CloudSubscriber\" /> </scr:component> The snipped above shows the definition of Kura ExamplePublisher, this component is capable of sending and receiving messages, and therefore defines two references, the first to a CloudPublisher and the second to a CloudSubscriber . In order to allow the user to customize the bindings at runtime, the target attribute of the references should not be specified at this point in component definition, as it will be set by the Web UI. Reference cardinality should be use the 0..1 or 0..n form, as it is not guaranteed that the references will point to a valid service instance during all the lifetime of the application component. For example, references can not be bound if the application has not been configured by the user yet or if the target service is missing.","title":"1. Write component definition"},{"location":"cloud-api/app-dev-guide/#2-create-component-metatype","text":"Application metatype should declare an AD for each Publisher/Subscriber reference declared in component definition: <MetaData xmlns= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" localization= \"en_us\" > <OCD id= \"org.eclipse.kura.example.publisher.ExamplePublisher\" name= \"ExamplePublisher\" description= \"Example of a Configuring Kura Application.\" > <!-- ... --> <AD id= \"CloudPublisher.target\" name= \"CloudPublisher Target Filter\" type= \"String\" cardinality= \"0\" required= \"true\" default= \"(kura.service.pid=changeme)\" description= \"Specifies, as an OSGi target filter, the pid of the Cloud Publisher used to publish messages to the cloud platform.\" > </AD> <AD id= \"CloudSubscriber.target\" name= \"CloudSubscriber Target Filter\" type= \"String\" cardinality= \"0\" required= \"true\" default= \"(kura.service.pid=changeme)\" description= \"Specifies, as an OSGi target filter, the pid of the Cloud Subscriber used to receive messages from the cloud platform.\" > </AD> <!-- ... --> </OCD> <Designate pid= \"org.eclipse.kura.example.publisher.ExamplePublisher\" factoryPid= \"org.eclipse.kura.example.publisher.ExamplePublisher\" > <Object ocdref= \"org.eclipse.kura.example.publisher.ExamplePublisher\" /> </Designate> </MetaData> It is important to respect the following rules for some of the AD attributes: id : this attribute must have the following form: <reference name>.target where <reference name> should match the value of the name attribute of the corresponding reference in component definition. required : must be set to true default : must not be empty and must be a valid OSGi filter. The Web UI will renderer a dedicated widget for picking CloudPublisher and CloudSubscriber instances:","title":"2. Create component metatype"},{"location":"cloud-api/app-dev-guide/#3-write-the-bindunbind-methods-in-applicaiton-code","text":"The last step involves defining some bind...() / unbind...() methods with a name that matches the values of the bind / unbind attributes of the references in component definition. public void setCloudPublisher ( CloudPublisher cloudPublisher ) { ... } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { ... } public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... } As stated above, since reference cardinality is declared as 0.. , the application must be prepared to handle the cases where references are not satisfied, and therefore CloudPublisher and CloudSubscriber instances are not available.","title":"3. Write the bind/unbind methods in applicaiton code"},{"location":"cloud-api/app-dev-guide/#4-publish-a-message","text":"If a CloudPublisher instance is bound, the application can publish messages using its publish() method: if ( nonNull ( this . cloudPublisher )) { KuraMessage message = new KuraMessage ( payload ); String messageId = this . cloudPublisher . publish ( message ); }","title":"4. Publish a message"},{"location":"cloud-api/app-dev-guide/#5-receiving-messages-using-a-cloudsubscriber","text":"In order to receive messages from a CloudSubscriber , the application must implement and attach a CloudSubscriberListener to it. This can be done for example during CloudSubscriber binding: public class ExamplePublisher implements CloudSubscriberListener , ... { ... public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber = cloudSubscriber ; this . cloudSubscriber . registerCloudSubscriberListener ( ExamplePublisher . this ); ... } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber . unregisterCloudSubscriberListener ( ExamplePublisher . this ); ... this . cloudSubscriber = null ; } ... @Override public void onMessageArrived ( KuraMessage message ) { logReceivedMessage ( message ); } ... } The CloudSubscriber will invoke the onMessageArrived() method when new messages are received.","title":"5. Receiving messages using a CloudSubscriber"},{"location":"cloud-api/app-dev-guide/#5-receiving-connection-state-notifications","text":"If an application is interested in cloud connection status change events (connected, disconnected, etc), it can implement and attach a CloudConnectionListener to a CloudPublisher or CloudSubscriber instance. public class ExamplePublisher implements CloudConnectionListener , ... { ... public void setCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher = cloudPublisher ; this . cloudPublisher . registerCloudConnectionListener ( ExamplePublisher . this ); ... } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher . unregisterCloudConnectionListener ( ExamplePublisher . this ); ... this . cloudPublisher = null ; } public void setCloudSubscriber ( CloudSubscriber cloudSubscriber ) { this . cloudSubscriber = cloudSubscriber ; ... this . cloudSubscriber . registerCloudConnectionListener ( ExamplePublisher . this ); } public void unsetCloudSubscriber ( CloudSubscriber cloudSubscriber ) { ... this . cloudSubscriber . unregisterCloudConnectionListener ( ExamplePublisher . this ); this . cloudSubscriber = null ; } ... @Override public void onConnectionEstablished () { logger . info ( \"Connection established\" ); } @Override public void onConnectionLost () { logger . warn ( \"Connection lost!\" ); } @Override public void onDisconnected () { logger . warn ( \"On disconnected\" ); } ... }","title":"5. Receiving connection state notifications"},{"location":"cloud-api/app-dev-guide/#6-receiving-message-delivery-notifications","text":"If an application is interested in message confirmation events and the underlying cloud connection supports it, it can implement and attach a CloudDeliveryListener to a CloudPublisher instance. public class ExamplePublisher implements CloudDeliveryListener , ... { ... public void setCloudPublisher ( CloudPublisher cloudPublisher ) { this . cloudPublisher = cloudPublisher ; ... this . cloudPublisher . registerCloudDeliveryListener ( ExamplePublisher . this ); } public void unsetCloudPublisher ( CloudPublisher cloudPublisher ) { ... this . cloudPublisher . registerCloudDeliveryListener ( ExamplePublisher . this ); this . cloudPublisher = null ; } ... @Override public void onMessageConfirmed ( String messageId ) { logger . info ( \"Confirmed message with id: {}\" , messageId ); } ... } The CloudSubscriber will invoke the onMessageConfirmed() method when a published message is confirmed. In order to determine which message has been confirmed, the provided messageId can be compared with the id returned by the publish() call that published the message. Please note that if the underlying cloud connection is not able to provide message confirmation for the published message, the id returned by publish() will be null .","title":"6. Receiving message delivery notifications"},{"location":"cloud-api/overview/","text":"Overview This section describes the new cloud related concepts and APIs introduced in Kura 4.0. Motivations Before Kura 4.0, Cloud APIs were quite tied to Kapua messaging conventions and to the MQTT protocol. Defining custom stacks that support other cloud platforms was possible, but the resulting implementations were affected by the following limitations: The legacy APIs assume that the underlying messaging protocol is MQTT. This assumption spans across all API layers, from the low level MQTTDataTrasport to the high level CloudClient . This makes quite difficult to implement cloud stacks that use other protocols like AMQP or HTTP. The CloudClient API, which was the recommended way for applications to interface with a cloud stack, enforce the following MQTT topic structure: #account-name/#device-id/#app-id/<app-topic> This topic hierarchy, which is Kapua related, might be too restrictive or too loose for other cloud platforms, for example: The Eclipse IoT working group namespace allows authenticated devices to omit the accont-name and device-id parameters in the topic. Moreover, telemetry, alert and event message topics must start respectively the t/ , a/ and e/ prefixes. Adhering to this specification is not possible for a cloud stack that implements the legacy APIs. The AWS cloud platform allows publishing on virtually any topic, using a CloudClient would be quite restrictive in this case. A way for overcoming this limitation for an application might be using the DataService layer directly, adversely affecting portability. The Cumulocity cloud platform allows publishing only on a limited set of topics, and most of the application generated information is placed in the payload encoded in CSV. Using CloudClient in this case makes difficult for the cloud stack to enforce that the messages are published on the correct topics. Moreover, the cloud stack in this case must also convert from KuraPayload to CSV, this can be currently achieved only by introducing rigid conversion rules, that might not be enough to support all message formats. Applications that use the current APIs are not portable across cloud platforms. For example if an appliaction intends to publish on Cumulocity or AWS, it should be probably aware of the underlying cloud platform. Concepts The main interfaces of the new set of APIs and their interactions are depicted in the diagram below: As shown in the above diagram new APIs introduce the concept of Cloud Connection , a set of related services that allow to manage the communication to/from a remote cloud platform. The services that compose a Cloud Connection can implement the following cloud-specific interfaces: CloudEndpoint (required): Each Cloud Connection is identified by a single instance of CloudEndpoint that implements low level specificities for the communication with the remote cloud platform. CloudConnectionManager (optional): Exposes methods that allow to manage long-lived connections. The implementor of CloudEndpoint can implement this interface as well if the cloud platform support long-lived connections (for example by using the MQTT protocol). RequestHandlerRegistry (optional): Manages the command and control functionalities if supported by the cloud platform. CloudPublisher (optional): Allows applications to publish messages to the cloud platform in a portable way. CloudSubscriber (optional): Allows applications to receive messages from the cloud platform in a portable way. CloudConnectionFactory (required): Manages the lifecycle of Cloud Connections. A Cloud Connection can also include services that do not provide any of the interfaces above but compose the internal implementation. CloudEndpoint Every Cloud Connection must contain a single CloudEndpoint instance. The kura.service.pid of the CloudEndpoint identifies the whole Cloud Connection. The CloudEndpoint provides some low level methods that can be used to interact with the remote cloud platform. For example the interface provides the publish() and subscribe() methods that allow to publish or receive messages from the cloud platform in form of KuraMessage s. Those methods are designed for internal use and are not intended to be used by end-user applications. The format of the KuraMessage provided to/received from a CloudEndpoint is implementation specific: the CloudEndpoint expects some properties to be set in the KuraMessage to be able to correctly publish a message (e.g. MQTT topic). These properties are specified by the particular CloudEndpoint , and should be documented by the implementor. The recommended way for applications to publish and receive messages involves using the Publisher and Subscriber APIs described below. If an application directly uses the methods above, it will lose portability and will be tied to the specific Cloud Connection implementation. CloudConnectionManager If the messaging protocol implemented by a Cloud Connection supports long-lived connection, then its CloudEndpoint can also implement and provide the CloudConnectionManager interface. This interface exposes some methods that can be used to manage the connection like connect() , disconnect() and isConnected() ; it also supports monitoring connection state using the CloudConnectionListener interface. Publishers and Subscribers The limitations of the current model described above are addressed by the introduction of the CloudPublisher and CloudSubscriber APIs, that replace the CloudClient as the recommended interface between applications and cloud stacks. CloudPublisher and CloudSubscriber are service interfaces defined as follows: public interface CloudPublisher { public String publish ( KuraMessage message ) throws KuraException ; public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void registerCloudDeliveryListener ( CloudDeliveryListener cloudDeliveryListener ); public void unregisterCloudDeliveryListener ( CloudDeliveryListener cloudDeliveryListener ); } public interface CloudSubscriber { public void registerCloudSubscriberListener ( CloudSubscriberListener listener ); public void unregisterCloudSubscriberListener ( CloudSubscriberListener listener ); public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); } CloudPublisher The CloudPublisher interface should be used by applications for publishing messages using the single publish() method. This method accepts a KuraMessage which is basically a KuraPayload that can be enriched with metadata. The main difference with the CloudClient APIs is that the publish() method does not require the application to specify any information related to message destinations. This allows to write portable applications that are unaware of the low level details of the destination cloud platform, such as the message format and the transport protocol. CloudSubscriber An application designed to receive messages from the cloud must now attach a listener ( CloudSubscriberListener ) to a CloudSubscriber instance. In this case, the message source cannot be specified by the application but is defined by the subscriber instance, in the same way as the CloudPublisher defines destination for published messages. The low level details necessary for message delivery and reception (e.g. the MQTT topic and the conversion between KuraMessage and the message format used on the wire) are managed by the publisher/subscriber, typically these details are stored in the service configuration. While in the previous model an application was responsible to actively obtain a CloudClient instance from a CloudService , now the relation between the application and a CloudPublisher or CloudSubscriber instance is represented as an OSGi service reference. Applications should allow the user to modify this reference in configuration, making it easy to switch between different cloud publisher/subscriber instances and different cloud platforms. Publisher/subscriber instances are now typically instantiated and configured by the end user using the Web UI. Publisher/subscriber instances are related to a CloudEnpoint instance using an OSGi service reference encoded in well known configuration property specified in the APIs ( CloudConnectionConstants.CLOUD_ENDPOINT_SERVICE_PID_PROP_NAME ). This allows the user to create those instances in a dedicated section of the Web UI. Command and control Another field in which the current Kura cloud related APIs can be generalized is related to command and control. In the previous model this aspect was covered by the Cloudlet APIs that are now replaced by RequestHandler APIs Legacy Cloudlet implementations are defined by extending a base class, Cloudlet , which takes care of handling the invocation of the doGet() , doPut() , doPost() ... methods, and of correlating request and response messages. Messages were sent and received through a CloudClient . More explicitly, Cloudlet only works with control topics whose structure is $EDC/<account-name>/<device-id>/<app-id>/<method>/<resource-path> and also expects the identifier of the sender and the correlation identifier in the KuraPayload . In the previous model, there is no way for a cloud stack implementor to customize the aspects above, which are hardcoded in the Cloudlet base class. The new model delegates these aspects to some component of the cloud stack, and requires applications that want to support command and control to register themselves as RequestHandler to a RequestHandlerRegistry instance. In order to ease porting old applications to the new model, some of the concepts of the old Cloudlet APIs are still present, this can be seen by looking at the RequestHandler interface definition: public interface RequestHandler { public KuraMessage doGet ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doPut ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doPost ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doDel ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doExec ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; } A RequestHandler invocation involves the following parameters: Request parameters: method : (GET, PUT, POST, DEL, EXEC) that identifies the RequestHandler method to be called request message : A set of key-value pairs and/or binary body contained in the KuraPayload wrapped inside the KuraMessage . resources : A List<String> of positional parameters available under the well known args key in the provided KuraMessage properties. Response parameters: response message : A set of key-value pairs and/or binary body contained in the KuraPayload wrapped inside the returned KuraMessage . status : A numeric code reporting operation completion state, determined as follows: 200, if RequestHandler methods returns without throwing exceptions. 400, if RequestHandler methods throws a KuraException with KuraErrorCode == BAD_REQUEST 404, if RequestHandler methods throws a KuraException with KuraErrorCode == NOT_FOUND 500, if RequestHandler methods throws a KuraException with other error codes. exception message : The message of the KuraException thrown by the RequestHandler methods, if any. exception stack trace : The stack trace of the KuraException thrown by the RequestHandler methods, if any. The parameters above are the same involved in current Cloudlet calls. The request id and requester client id parameters are no longer part of the API, because are related to the to the way Kapua correlates requests and response. In the new API, request and response identifiers are not specified and not forwarded to the Cloudlet, this allows the CloudletService implementation to adopt the platform specific conventions for message correlation. The Cloudlet parameters must be present in the request and response messages encoded in some format. A user that intends to call a Kura Cloudlet, for example through platform-specific REST APIs must be aware of these parameters. The user must supply request parameters in request message and must be able to extract response data from received message. The actual encoding of these parameters inside the messages depends on the particular platform. The fact that set of Cloudlet parameters are roughly the same involved in current Cloudlet calls allows existing Cloudlet based applications to continue to work without changes to the protocol. Cloud Connection lifecycle CloudEndpoint instance lifecycle is managed by a CloudConnectionFactory instance. A cloud connection implementor must register a CloudConnectionFactory instance in the framework that is responsible of creating and destroying the CloudEndpoint instances. The CloudConnectionFactory will be typically invoked by the Web UI, and is defined as follows: public interface CloudConnectionFactory { public static final String KURA_CLOUD_CONNECTION_FACTORY_PID = \"kura.cloud.connection.factory.pid\" ; public String getFactoryPid (); public void createConfiguration ( String pid ) throws KuraException ; public List < String > getStackComponentsPids ( String pid ) throws KuraException ; public void deleteConfiguration ( String pid ) throws KuraException ; public Set < String > getManagedCloudConnectionPids () throws KuraException ; } The createConfiguration() and deleteConfiguration() methods are responsible of creating/destroying a CloudEndpoint instance, specified by the provided kura.service.pid , and all the related services. The getManagedCloudConnectionPids() returns the set of kura.service.pid managed by the factory. The getStackComponentsPids(String pid) returns the list of the kura.service.pid s of the ConfigurableComponent s that are associated with the CloudEndpoint with the specified pid. The Web Ui will render the configuration of those components in separated tabs, in the dedicated CloudConnections section. Backwards compatibility In order to ease the transition to the new model, legacy APIs like CloudService and CloudClient are still supported in Kura 4.0.0, even if deprecated. The default Kapua oriented CloudService implementation is still available and can be used by legacy applications without changes. The default CloudService instance in Kura 4.0 also implements the new CloudEndpoint and CloudConnectionManager interfaces.","title":"Overview"},{"location":"cloud-api/overview/#overview","text":"This section describes the new cloud related concepts and APIs introduced in Kura 4.0.","title":"Overview"},{"location":"cloud-api/overview/#motivations","text":"Before Kura 4.0, Cloud APIs were quite tied to Kapua messaging conventions and to the MQTT protocol. Defining custom stacks that support other cloud platforms was possible, but the resulting implementations were affected by the following limitations: The legacy APIs assume that the underlying messaging protocol is MQTT. This assumption spans across all API layers, from the low level MQTTDataTrasport to the high level CloudClient . This makes quite difficult to implement cloud stacks that use other protocols like AMQP or HTTP. The CloudClient API, which was the recommended way for applications to interface with a cloud stack, enforce the following MQTT topic structure: #account-name/#device-id/#app-id/<app-topic> This topic hierarchy, which is Kapua related, might be too restrictive or too loose for other cloud platforms, for example: The Eclipse IoT working group namespace allows authenticated devices to omit the accont-name and device-id parameters in the topic. Moreover, telemetry, alert and event message topics must start respectively the t/ , a/ and e/ prefixes. Adhering to this specification is not possible for a cloud stack that implements the legacy APIs. The AWS cloud platform allows publishing on virtually any topic, using a CloudClient would be quite restrictive in this case. A way for overcoming this limitation for an application might be using the DataService layer directly, adversely affecting portability. The Cumulocity cloud platform allows publishing only on a limited set of topics, and most of the application generated information is placed in the payload encoded in CSV. Using CloudClient in this case makes difficult for the cloud stack to enforce that the messages are published on the correct topics. Moreover, the cloud stack in this case must also convert from KuraPayload to CSV, this can be currently achieved only by introducing rigid conversion rules, that might not be enough to support all message formats. Applications that use the current APIs are not portable across cloud platforms. For example if an appliaction intends to publish on Cumulocity or AWS, it should be probably aware of the underlying cloud platform.","title":"Motivations"},{"location":"cloud-api/overview/#concepts","text":"The main interfaces of the new set of APIs and their interactions are depicted in the diagram below: As shown in the above diagram new APIs introduce the concept of Cloud Connection , a set of related services that allow to manage the communication to/from a remote cloud platform. The services that compose a Cloud Connection can implement the following cloud-specific interfaces: CloudEndpoint (required): Each Cloud Connection is identified by a single instance of CloudEndpoint that implements low level specificities for the communication with the remote cloud platform. CloudConnectionManager (optional): Exposes methods that allow to manage long-lived connections. The implementor of CloudEndpoint can implement this interface as well if the cloud platform support long-lived connections (for example by using the MQTT protocol). RequestHandlerRegistry (optional): Manages the command and control functionalities if supported by the cloud platform. CloudPublisher (optional): Allows applications to publish messages to the cloud platform in a portable way. CloudSubscriber (optional): Allows applications to receive messages from the cloud platform in a portable way. CloudConnectionFactory (required): Manages the lifecycle of Cloud Connections. A Cloud Connection can also include services that do not provide any of the interfaces above but compose the internal implementation.","title":"Concepts"},{"location":"cloud-api/overview/#cloudendpoint","text":"Every Cloud Connection must contain a single CloudEndpoint instance. The kura.service.pid of the CloudEndpoint identifies the whole Cloud Connection. The CloudEndpoint provides some low level methods that can be used to interact with the remote cloud platform. For example the interface provides the publish() and subscribe() methods that allow to publish or receive messages from the cloud platform in form of KuraMessage s. Those methods are designed for internal use and are not intended to be used by end-user applications. The format of the KuraMessage provided to/received from a CloudEndpoint is implementation specific: the CloudEndpoint expects some properties to be set in the KuraMessage to be able to correctly publish a message (e.g. MQTT topic). These properties are specified by the particular CloudEndpoint , and should be documented by the implementor. The recommended way for applications to publish and receive messages involves using the Publisher and Subscriber APIs described below. If an application directly uses the methods above, it will lose portability and will be tied to the specific Cloud Connection implementation.","title":"CloudEndpoint"},{"location":"cloud-api/overview/#cloudconnectionmanager","text":"If the messaging protocol implemented by a Cloud Connection supports long-lived connection, then its CloudEndpoint can also implement and provide the CloudConnectionManager interface. This interface exposes some methods that can be used to manage the connection like connect() , disconnect() and isConnected() ; it also supports monitoring connection state using the CloudConnectionListener interface.","title":"CloudConnectionManager"},{"location":"cloud-api/overview/#publishers-and-subscribers","text":"The limitations of the current model described above are addressed by the introduction of the CloudPublisher and CloudSubscriber APIs, that replace the CloudClient as the recommended interface between applications and cloud stacks. CloudPublisher and CloudSubscriber are service interfaces defined as follows: public interface CloudPublisher { public String publish ( KuraMessage message ) throws KuraException ; public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void registerCloudDeliveryListener ( CloudDeliveryListener cloudDeliveryListener ); public void unregisterCloudDeliveryListener ( CloudDeliveryListener cloudDeliveryListener ); } public interface CloudSubscriber { public void registerCloudSubscriberListener ( CloudSubscriberListener listener ); public void unregisterCloudSubscriberListener ( CloudSubscriberListener listener ); public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ); }","title":"Publishers and Subscribers"},{"location":"cloud-api/overview/#cloudpublisher","text":"The CloudPublisher interface should be used by applications for publishing messages using the single publish() method. This method accepts a KuraMessage which is basically a KuraPayload that can be enriched with metadata. The main difference with the CloudClient APIs is that the publish() method does not require the application to specify any information related to message destinations. This allows to write portable applications that are unaware of the low level details of the destination cloud platform, such as the message format and the transport protocol.","title":"CloudPublisher"},{"location":"cloud-api/overview/#cloudsubscriber","text":"An application designed to receive messages from the cloud must now attach a listener ( CloudSubscriberListener ) to a CloudSubscriber instance. In this case, the message source cannot be specified by the application but is defined by the subscriber instance, in the same way as the CloudPublisher defines destination for published messages. The low level details necessary for message delivery and reception (e.g. the MQTT topic and the conversion between KuraMessage and the message format used on the wire) are managed by the publisher/subscriber, typically these details are stored in the service configuration. While in the previous model an application was responsible to actively obtain a CloudClient instance from a CloudService , now the relation between the application and a CloudPublisher or CloudSubscriber instance is represented as an OSGi service reference. Applications should allow the user to modify this reference in configuration, making it easy to switch between different cloud publisher/subscriber instances and different cloud platforms. Publisher/subscriber instances are now typically instantiated and configured by the end user using the Web UI. Publisher/subscriber instances are related to a CloudEnpoint instance using an OSGi service reference encoded in well known configuration property specified in the APIs ( CloudConnectionConstants.CLOUD_ENDPOINT_SERVICE_PID_PROP_NAME ). This allows the user to create those instances in a dedicated section of the Web UI.","title":"CloudSubscriber"},{"location":"cloud-api/overview/#command-and-control","text":"Another field in which the current Kura cloud related APIs can be generalized is related to command and control. In the previous model this aspect was covered by the Cloudlet APIs that are now replaced by RequestHandler APIs Legacy Cloudlet implementations are defined by extending a base class, Cloudlet , which takes care of handling the invocation of the doGet() , doPut() , doPost() ... methods, and of correlating request and response messages. Messages were sent and received through a CloudClient . More explicitly, Cloudlet only works with control topics whose structure is $EDC/<account-name>/<device-id>/<app-id>/<method>/<resource-path> and also expects the identifier of the sender and the correlation identifier in the KuraPayload . In the previous model, there is no way for a cloud stack implementor to customize the aspects above, which are hardcoded in the Cloudlet base class. The new model delegates these aspects to some component of the cloud stack, and requires applications that want to support command and control to register themselves as RequestHandler to a RequestHandlerRegistry instance. In order to ease porting old applications to the new model, some of the concepts of the old Cloudlet APIs are still present, this can be seen by looking at the RequestHandler interface definition: public interface RequestHandler { public KuraMessage doGet ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doPut ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doPost ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doDel ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; public KuraMessage doExec ( RequestHandlerContext context , KuraMessage reqMessage ) throws KuraException ; } A RequestHandler invocation involves the following parameters: Request parameters: method : (GET, PUT, POST, DEL, EXEC) that identifies the RequestHandler method to be called request message : A set of key-value pairs and/or binary body contained in the KuraPayload wrapped inside the KuraMessage . resources : A List<String> of positional parameters available under the well known args key in the provided KuraMessage properties. Response parameters: response message : A set of key-value pairs and/or binary body contained in the KuraPayload wrapped inside the returned KuraMessage . status : A numeric code reporting operation completion state, determined as follows: 200, if RequestHandler methods returns without throwing exceptions. 400, if RequestHandler methods throws a KuraException with KuraErrorCode == BAD_REQUEST 404, if RequestHandler methods throws a KuraException with KuraErrorCode == NOT_FOUND 500, if RequestHandler methods throws a KuraException with other error codes. exception message : The message of the KuraException thrown by the RequestHandler methods, if any. exception stack trace : The stack trace of the KuraException thrown by the RequestHandler methods, if any. The parameters above are the same involved in current Cloudlet calls. The request id and requester client id parameters are no longer part of the API, because are related to the to the way Kapua correlates requests and response. In the new API, request and response identifiers are not specified and not forwarded to the Cloudlet, this allows the CloudletService implementation to adopt the platform specific conventions for message correlation. The Cloudlet parameters must be present in the request and response messages encoded in some format. A user that intends to call a Kura Cloudlet, for example through platform-specific REST APIs must be aware of these parameters. The user must supply request parameters in request message and must be able to extract response data from received message. The actual encoding of these parameters inside the messages depends on the particular platform. The fact that set of Cloudlet parameters are roughly the same involved in current Cloudlet calls allows existing Cloudlet based applications to continue to work without changes to the protocol.","title":"Command and control"},{"location":"cloud-api/overview/#cloud-connection-lifecycle","text":"CloudEndpoint instance lifecycle is managed by a CloudConnectionFactory instance. A cloud connection implementor must register a CloudConnectionFactory instance in the framework that is responsible of creating and destroying the CloudEndpoint instances. The CloudConnectionFactory will be typically invoked by the Web UI, and is defined as follows: public interface CloudConnectionFactory { public static final String KURA_CLOUD_CONNECTION_FACTORY_PID = \"kura.cloud.connection.factory.pid\" ; public String getFactoryPid (); public void createConfiguration ( String pid ) throws KuraException ; public List < String > getStackComponentsPids ( String pid ) throws KuraException ; public void deleteConfiguration ( String pid ) throws KuraException ; public Set < String > getManagedCloudConnectionPids () throws KuraException ; } The createConfiguration() and deleteConfiguration() methods are responsible of creating/destroying a CloudEndpoint instance, specified by the provided kura.service.pid , and all the related services. The getManagedCloudConnectionPids() returns the set of kura.service.pid managed by the factory. The getStackComponentsPids(String pid) returns the list of the kura.service.pid s of the ConfigurableComponent s that are associated with the CloudEndpoint with the specified pid. The Web Ui will render the configuration of those components in separated tabs, in the dedicated CloudConnections section.","title":"Cloud Connection lifecycle"},{"location":"cloud-api/overview/#backwards-compatibility","text":"In order to ease the transition to the new model, legacy APIs like CloudService and CloudClient are still supported in Kura 4.0.0, even if deprecated. The default Kapua oriented CloudService implementation is still available and can be used by legacy applications without changes. The default CloudService instance in Kura 4.0 also implements the new CloudEndpoint and CloudConnectionManager interfaces.","title":"Backwards compatibility"},{"location":"cloud-api/stack-components/","text":"Built-in Cloud Services Eclipse Kura provides by default a set of services used to connect to a cloud platform. The following sections describe the services and how to configure them. The CloudService API is deprecated since Kura 4.0. The functionalities provided by CloudService are now provided by the CloudEndpoint and CloudConnectionManager service interfaces. See the section describing the Kura 4.0 cloud connection model for more details. The DataService and MqttDataTrasport APIs are not deprecated in Kura 4.0. CloudService The CloudService provides an easy-to-use API layer for the M2M application to communicate with a remote server. It operates as a decorator for the DataService, providing add-on features over the management of the transport layer. In addition to simple publish/subscribe, the CloudService API simplifies the implementation of more complex interaction flows like request/response or remote resource management. The CloudService abstracts the developers from the complexity of the transport protocol and payload format used in the communication. The CloudService allows a single connection to a remote server to be shared across more than one application in the gateway providing the necessary topic partitioning. Its functions include: Adds application topic prefixes to allow for a single remote server connection to be shared across applications. Defines a payload data model and provides default encoding/decoding serializers. Publishes life-cycle messages when the device and applications start and stop. To use this service, select the CloudServices option located in the System area and select the CloudService tab as shown in the screen capture below. The CloudService provides the following configuration parameters: device.display-name - defines the device display name given by the system. (Required field.) device.custom-name - defines the custom device display name if the device.display-name parameter is set to \"Custom\". topic.control-prefix - defines the topic prefix for system messages. encode.gzip - defines if the message payloads are sent compressed. republish.mqtt.birth.cert.on.gps.lock - when set to true, forces a republish of the MQTT Birth Certificate when a GPS correct position lock is received. The device is then registered with its real coordinates. (Required field.) republish.mqtt.birth.cert.on.modem.detect - when set to true, forces a republish of the MQTT Birth Certificate when the service receives a modem detection event. (Required field.) enable.default.subscriptions - when set to true, the gateway will not be remotely manageable. birth.cert.policy - specify the birth certificate policy. The options are Disable publishing , Publish birth on connect and Publish birth on connect and reconnect . payload.encoding - Specify the message payload encoding. The possible options are Kura Protobuf and Simple JSON . DataService The DataService provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. The DataService delegates to the MqttDataTransport service the implementation of the transport protocol that is used to interact with the remote server. The DataService also adds the capability of storing published messages in a persistent store function and sending them over the wire at a later time. The purpose of this feature is to relieve service users from implementing their own persistent store. Service users may publish messages independently on the DataService connection status. In order to overcome the potential latencies introduced by buffering messages, the DataService allows a priority level to be assigned for each published message. Depending on the store configuration, there are certain guarantees that stored messages are not lost due to sudden crashes or power outages. To use this service, select the DataService option located in the System area and select the CloudService tab as shown in the screen capture below. The DataService offers methods and configuration options to manage the connection to the remote server including the following (all required) parameters described below. connect.auto-on-startup - when set to true, the service tries to auto-connect to the remote server on start-up and restore the connection every time the device is disconnected. These attempts are made at the frequency defined in the connect.retry-interval parameter until the connection is established. disconnect.quiesce-timeout - allows the delivery of in-flight messages to be completed before disconnecting from the broker when a disconnection from the broker is being forced. store.housekeeper-interval - defines the interval in seconds used to run the Data Store housekeeper task. store.purge-age - defines the age in seconds of completed messages (either published with QoS = 0 or confirmed with QoS > 0) after which they are deleted (minimum 5). store.capacity - defines the maximum number of messages persisted in the Data Store. in-flight-messages parameters - define the management of messages that have been published and not yet confirmed, including: in-flight-messages.republish-on-new-session in-flight-messages.max-number in-flight-messages.congestion-timeout MqttDataTransport The MqttDataTransport service provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. To use this service, select the MqttDataTransport option located in the System area and select the CloudService tab as shown in the screen capture below. The MqttDataTransport service provides the following configuration parameters: broker-url - defines the URL of the MQTT broker to connect to. (Required field.) topic.context.account-name - defines the name of the account to which the device belongs. username and password - define the username and password that have been assigned to the device by the account administrator (generally username is account-name_broker). (Required field.) client-id - defines the identifier of the MQTT client representing the device when connecting to the MQTT broker. If left empty, it is automatically determined by the client software as the MAC address of the main network interface (in general numbers and uppercase letters without ':'). This identifier has to be unique within your account. keep-alive - defines the \"keep alive\" interval measured in seconds. It specifies the maximum amount of time that should pass without communication between the client and the server. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during this time period, the client will send a very small MQTT \"ping\" message that the server will acknowledge. The keep alive interval enables the client to detect when the server is no longer available without having to wait for the long TCP/IP timeout. (Required field.) timeout - sets the timeout used for all interactions with the MQTT broker. (Required field.) clean-session - controls the behavior of both the client and the server at the time of connect and disconnect. When this parameter is set to true, the state information is discarded at connect and disconnect; when set to false, the state information is maintained. (Required field.) lwt parameters - define the MQTT \"Last Will and Testament\" (LWT) settings for the client. In the event that the client unexpectedly loses its connection to the server, the server publishes the LWT message (lwt.payload) to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. LWT parameters that may be configured include: lwt.topic lwt.payload lwt.qos lwt.retain in-flight.persistence - defines the storage type where in-flight messages are persisted across reconnections. They may be stored in memory, or in a file on the disk. (Required field.) protocol-version - defines the MQTT Protocol version to be used. This value may be 3.1 or 3.1.1. ssl parameters - defines the SSL configuration. SSL parameters that may be configured include: ssl.default.protocol ssl.hostname.verification ssl.default.cipherSuites ssl.certificate.alias","title":"Built-in Cloud Services"},{"location":"cloud-api/stack-components/#built-in-cloud-services","text":"Eclipse Kura provides by default a set of services used to connect to a cloud platform. The following sections describe the services and how to configure them. The CloudService API is deprecated since Kura 4.0. The functionalities provided by CloudService are now provided by the CloudEndpoint and CloudConnectionManager service interfaces. See the section describing the Kura 4.0 cloud connection model for more details. The DataService and MqttDataTrasport APIs are not deprecated in Kura 4.0.","title":"Built-in Cloud Services"},{"location":"cloud-api/stack-components/#cloudservice","text":"The CloudService provides an easy-to-use API layer for the M2M application to communicate with a remote server. It operates as a decorator for the DataService, providing add-on features over the management of the transport layer. In addition to simple publish/subscribe, the CloudService API simplifies the implementation of more complex interaction flows like request/response or remote resource management. The CloudService abstracts the developers from the complexity of the transport protocol and payload format used in the communication. The CloudService allows a single connection to a remote server to be shared across more than one application in the gateway providing the necessary topic partitioning. Its functions include: Adds application topic prefixes to allow for a single remote server connection to be shared across applications. Defines a payload data model and provides default encoding/decoding serializers. Publishes life-cycle messages when the device and applications start and stop. To use this service, select the CloudServices option located in the System area and select the CloudService tab as shown in the screen capture below. The CloudService provides the following configuration parameters: device.display-name - defines the device display name given by the system. (Required field.) device.custom-name - defines the custom device display name if the device.display-name parameter is set to \"Custom\". topic.control-prefix - defines the topic prefix for system messages. encode.gzip - defines if the message payloads are sent compressed. republish.mqtt.birth.cert.on.gps.lock - when set to true, forces a republish of the MQTT Birth Certificate when a GPS correct position lock is received. The device is then registered with its real coordinates. (Required field.) republish.mqtt.birth.cert.on.modem.detect - when set to true, forces a republish of the MQTT Birth Certificate when the service receives a modem detection event. (Required field.) enable.default.subscriptions - when set to true, the gateway will not be remotely manageable. birth.cert.policy - specify the birth certificate policy. The options are Disable publishing , Publish birth on connect and Publish birth on connect and reconnect . payload.encoding - Specify the message payload encoding. The possible options are Kura Protobuf and Simple JSON .","title":"CloudService"},{"location":"cloud-api/stack-components/#dataservice","text":"The DataService provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. The DataService delegates to the MqttDataTransport service the implementation of the transport protocol that is used to interact with the remote server. The DataService also adds the capability of storing published messages in a persistent store function and sending them over the wire at a later time. The purpose of this feature is to relieve service users from implementing their own persistent store. Service users may publish messages independently on the DataService connection status. In order to overcome the potential latencies introduced by buffering messages, the DataService allows a priority level to be assigned for each published message. Depending on the store configuration, there are certain guarantees that stored messages are not lost due to sudden crashes or power outages. To use this service, select the DataService option located in the System area and select the CloudService tab as shown in the screen capture below. The DataService offers methods and configuration options to manage the connection to the remote server including the following (all required) parameters described below. connect.auto-on-startup - when set to true, the service tries to auto-connect to the remote server on start-up and restore the connection every time the device is disconnected. These attempts are made at the frequency defined in the connect.retry-interval parameter until the connection is established. disconnect.quiesce-timeout - allows the delivery of in-flight messages to be completed before disconnecting from the broker when a disconnection from the broker is being forced. store.housekeeper-interval - defines the interval in seconds used to run the Data Store housekeeper task. store.purge-age - defines the age in seconds of completed messages (either published with QoS = 0 or confirmed with QoS > 0) after which they are deleted (minimum 5). store.capacity - defines the maximum number of messages persisted in the Data Store. in-flight-messages parameters - define the management of messages that have been published and not yet confirmed, including: in-flight-messages.republish-on-new-session in-flight-messages.max-number in-flight-messages.congestion-timeout","title":"DataService"},{"location":"cloud-api/stack-components/#mqttdatatransport","text":"The MqttDataTransport service provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. To use this service, select the MqttDataTransport option located in the System area and select the CloudService tab as shown in the screen capture below. The MqttDataTransport service provides the following configuration parameters: broker-url - defines the URL of the MQTT broker to connect to. (Required field.) topic.context.account-name - defines the name of the account to which the device belongs. username and password - define the username and password that have been assigned to the device by the account administrator (generally username is account-name_broker). (Required field.) client-id - defines the identifier of the MQTT client representing the device when connecting to the MQTT broker. If left empty, it is automatically determined by the client software as the MAC address of the main network interface (in general numbers and uppercase letters without ':'). This identifier has to be unique within your account. keep-alive - defines the \"keep alive\" interval measured in seconds. It specifies the maximum amount of time that should pass without communication between the client and the server. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during this time period, the client will send a very small MQTT \"ping\" message that the server will acknowledge. The keep alive interval enables the client to detect when the server is no longer available without having to wait for the long TCP/IP timeout. (Required field.) timeout - sets the timeout used for all interactions with the MQTT broker. (Required field.) clean-session - controls the behavior of both the client and the server at the time of connect and disconnect. When this parameter is set to true, the state information is discarded at connect and disconnect; when set to false, the state information is maintained. (Required field.) lwt parameters - define the MQTT \"Last Will and Testament\" (LWT) settings for the client. In the event that the client unexpectedly loses its connection to the server, the server publishes the LWT message (lwt.payload) to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. LWT parameters that may be configured include: lwt.topic lwt.payload lwt.qos lwt.retain in-flight.persistence - defines the storage type where in-flight messages are persisted across reconnections. They may be stored in memory, or in a file on the disk. (Required field.) protocol-version - defines the MQTT Protocol version to be used. This value may be 3.1 or 3.1.1. ssl parameters - defines the SSL configuration. SSL parameters that may be configured include: ssl.default.protocol ssl.hostname.verification ssl.default.cipherSuites ssl.certificate.alias","title":"MqttDataTransport"},{"location":"cloud-api/stack-dev-guide/","text":"Cloud connection developer guide This guide will provide information on how a cloud connection developer can leverage the new Generic Cloud Services APIs. Cloud connection developer guide Implement CloudEndpoint and CloudConnectionManager Implement the CloudConnectionFactory interface Provide a CloudPublisher implementation Provide a CloudSubscriber implementation Implement RequestHandler support As reference, this guide will use the Eclipse IoT WG namespace implementation bundle available here Implement CloudEndpoint and CloudConnectionManager In order to leverage the new APIs, and be managed by the Kura Web UI, the Cloud Connection implementation bundle must implement CloudEndpont and, if log-lived connections are supported, the CloudConnectionManager interface must be implemented as well. The ending class should be something as follows: public class CloudConnectionManagerImpl implements CloudConnectionManager , CloudEndpoint , ... { @Override public boolean isConnected () { ... } @Override public void connect () throws KuraConnectException { ... } @Override public void disconnect () { ... } @Override public Map < String , String > getInfo () { ... } @Override public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ) { ... } @Override public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ) { ... } } A corresponding component definition should be provided in the OSGI-INF folder exposing the implementation of CloudEndpoint and CloudConnectionManager interfaces. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" activate= \"activate\" configuration-policy= \"require\" deactivate= \"deactivate\" enabled= \"true\" immediate= \"true\" modified= \"updated\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.CloudConnectionManagerImpl\" /> <service> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> <provide interface= \"org.eclipse.kura.cloudconnection.CloudConnectionManager\" /> <provide interface= \"org.eclipse.kura.cloudconnection.CloudEndpoint\" /> <!-- ... --> </service> <!-- ... --> <property name= \"kura.ui.service.hide\" type= \"Boolean\" value= \"true\" /> <property name= \"kura.ui.factory.hide\" type= \"String\" value= \"true\" /> </scr:component> In order to be fully compliant with the Web UI requirements, the CloudConnection component definition should provide two properties kura.ui.service.hide and kura.ui.factory.hide to hide the component from the left side part of the UI dedicated to display the services list. Implement the CloudConnectionFactory interface The CloudConnectionFactory is responsible to manage the cloud connection instance lifecycle by creating the CloudEndpoint instance and all the required services needed to publish or receive messages from the cloud platform. As a reference, please have a look at the CloudConnectionFactory defined for the Eclipse IoT WG namespace implementation. In particular, the getFactoryPid() method returns the PID of the CloudEndpoint factory. The createConfiguration() method receives a PID that will be used for the instantiation of the CloudEndpoint and for all the related services required to communicate with the cloud platform. In the example above, the factory creates the CloudEnpoint, and a DataService and MqttDataTransport instances internally needed to communicate with a remote cloud platform. As can be seen here , the CloudEndpoint instance configuration is enriched with the reference to the CloudConnectionFactory that generated it. This step is required by the Web UI in order to properly relate the instances with the corresponding factories. The deleteConfiguration() method deletes from the framework the CloudEndpoint instance identified by the PID passed as argument and all the related services. In the Eclipse IOT WG example, it not only deletes the CloudEndpoint instance but also the corresponding DataService and MqttDataTransport instances. The getStackComponentsPids() method return a List of String that represent the kura.service.pid of the configurable components that are part of a Cloud Connection instance. This method is used by the Web UI to get the list of configurable components that need to be displayed to the end user. The getManagedCloudConnectionPids() method will return the list of kura.service.pid of all the CloudEndpoints managed by the factory. The factory component definition should be defined as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.DefaultCloudConnectionFactory\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.factory.DefaultCloudConnectionFactory\" /> <reference bind= \"setConfigurationService\" cardinality= \"1..1\" interface= \"org.eclipse.kura.configuration.ConfigurationService\" name= \"ConfigurationService\" policy= \"static\" unbind= \"unsetConfigurationService\" /> <service> <provide interface= \"org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory\" /> </service> <property name= \"osgi.command.scope\" type= \"String\" value= \"kura.cloud\" /> <property name= \"osgi.command.function\" type= \"String\" > createConfiguration </property> <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager(\\-[a-zA-Z0-9]+)?$\" /> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.DefaultCloudConnectionFactory\" /> </scr:component> In particular, it should expose in the service section the fact that the factory implements org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory <service> <provide interface= \"org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory\" /> </service> Important properties that need to be specified to have a better Web UI experience are the following: <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager(\\-[a-zA-Z0-9]+)?$\" /> those allow to specify the form of the expected PID that the end user should provide when creating a new cloud connection. Provide a CloudPublisher implementation To provide a CloudPublisher implementation, other than implementing CloudPublisher API in a java class, the developer must provide a component definition in the OSGI-INF folder that should be like the following: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" activate= \"activate\" configuration-policy= \"require\" deactivate= \"deactivate\" enabled= \"true\" immediate= \"true\" modified= \"updated\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.publisher.CloudPublisherImpl\" /> <service> <provide interface= \"org.eclipse.kura.cloudconnection.publisher.CloudPublisher\" /> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> </service> <property name= \"cloud.connection.factory.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" /> <property name= \"kura.ui.service.hide\" type= \"Boolean\" value= \"true\" /> <property name= \"kura.ui.factory.hide\" type= \"String\" value= \"true\" /> <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher(\\-[a-zA-Z0-9]+)?$\" /> </scr:component> As can be seen in the previous snippet, the Publisher exposes itself in the framework as a ConfigurableComponent and as a CloudPublisher . The component definition must contain the following well-known properties: cloud.connection.factory.pid : this property must be set to the kura.service.pid of the factory that created the cloud connection which the publisher belongs. It is used by the Web UI to enforce that the correct cloud publisher implementation is used in a specific cloud endpoint. kura.ui.service.hide : as specified before for the Cloud Endpoint kura.ui.factory.hide : as specified before for the Cloud Endpoint kura.ui.csf.pid.default : as specified before for the Cloud Factory. It is an optional property. kura.ui.csf.pid.regex : as specified before for the Cloud Factory. It is an optional property. The relation between the CloudPublisher instance and the CloudEndpoint is defined by a configuration property set by the Web UI at CloudPublisher creation. Provide a CloudSubscriber implementation The CloudSubscriber implementation and component definition is similar to the one described for the CloudPublisher. Implement RequestHandler support In order to support Command and Control, the cloud connection bundle should provide a service that registers itself as RequestHandlerRegistry. In this way all the RequestHandler instances could be able to discover the different Registry and subscribe for command and control messages received from the cloud platform. As an example, for the Eclipse IoT WG bundle, the CloudEndpoint registers itself also as RequestHandlerRegistry.","title":"Cloud connection developer guide"},{"location":"cloud-api/stack-dev-guide/#cloud-connection-developer-guide","text":"This guide will provide information on how a cloud connection developer can leverage the new Generic Cloud Services APIs. Cloud connection developer guide Implement CloudEndpoint and CloudConnectionManager Implement the CloudConnectionFactory interface Provide a CloudPublisher implementation Provide a CloudSubscriber implementation Implement RequestHandler support As reference, this guide will use the Eclipse IoT WG namespace implementation bundle available here","title":"Cloud connection developer guide"},{"location":"cloud-api/stack-dev-guide/#implement-cloudendpoint-and-cloudconnectionmanager","text":"In order to leverage the new APIs, and be managed by the Kura Web UI, the Cloud Connection implementation bundle must implement CloudEndpont and, if log-lived connections are supported, the CloudConnectionManager interface must be implemented as well. The ending class should be something as follows: public class CloudConnectionManagerImpl implements CloudConnectionManager , CloudEndpoint , ... { @Override public boolean isConnected () { ... } @Override public void connect () throws KuraConnectException { ... } @Override public void disconnect () { ... } @Override public Map < String , String > getInfo () { ... } @Override public void registerCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ) { ... } @Override public void unregisterCloudConnectionListener ( CloudConnectionListener cloudConnectionListener ) { ... } } A corresponding component definition should be provided in the OSGI-INF folder exposing the implementation of CloudEndpoint and CloudConnectionManager interfaces. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" activate= \"activate\" configuration-policy= \"require\" deactivate= \"deactivate\" enabled= \"true\" immediate= \"true\" modified= \"updated\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.CloudConnectionManagerImpl\" /> <service> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> <provide interface= \"org.eclipse.kura.cloudconnection.CloudConnectionManager\" /> <provide interface= \"org.eclipse.kura.cloudconnection.CloudEndpoint\" /> <!-- ... --> </service> <!-- ... --> <property name= \"kura.ui.service.hide\" type= \"Boolean\" value= \"true\" /> <property name= \"kura.ui.factory.hide\" type= \"String\" value= \"true\" /> </scr:component> In order to be fully compliant with the Web UI requirements, the CloudConnection component definition should provide two properties kura.ui.service.hide and kura.ui.factory.hide to hide the component from the left side part of the UI dedicated to display the services list.","title":"Implement CloudEndpoint and CloudConnectionManager"},{"location":"cloud-api/stack-dev-guide/#implement-the-cloudconnectionfactory-interface","text":"The CloudConnectionFactory is responsible to manage the cloud connection instance lifecycle by creating the CloudEndpoint instance and all the required services needed to publish or receive messages from the cloud platform. As a reference, please have a look at the CloudConnectionFactory defined for the Eclipse IoT WG namespace implementation. In particular, the getFactoryPid() method returns the PID of the CloudEndpoint factory. The createConfiguration() method receives a PID that will be used for the instantiation of the CloudEndpoint and for all the related services required to communicate with the cloud platform. In the example above, the factory creates the CloudEnpoint, and a DataService and MqttDataTransport instances internally needed to communicate with a remote cloud platform. As can be seen here , the CloudEndpoint instance configuration is enriched with the reference to the CloudConnectionFactory that generated it. This step is required by the Web UI in order to properly relate the instances with the corresponding factories. The deleteConfiguration() method deletes from the framework the CloudEndpoint instance identified by the PID passed as argument and all the related services. In the Eclipse IOT WG example, it not only deletes the CloudEndpoint instance but also the corresponding DataService and MqttDataTransport instances. The getStackComponentsPids() method return a List of String that represent the kura.service.pid of the configurable components that are part of a Cloud Connection instance. This method is used by the Web UI to get the list of configurable components that need to be displayed to the end user. The getManagedCloudConnectionPids() method will return the list of kura.service.pid of all the CloudEndpoints managed by the factory. The factory component definition should be defined as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.DefaultCloudConnectionFactory\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.factory.DefaultCloudConnectionFactory\" /> <reference bind= \"setConfigurationService\" cardinality= \"1..1\" interface= \"org.eclipse.kura.configuration.ConfigurationService\" name= \"ConfigurationService\" policy= \"static\" unbind= \"unsetConfigurationService\" /> <service> <provide interface= \"org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory\" /> </service> <property name= \"osgi.command.scope\" type= \"String\" value= \"kura.cloud\" /> <property name= \"osgi.command.function\" type= \"String\" > createConfiguration </property> <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager(\\-[a-zA-Z0-9]+)?$\" /> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.DefaultCloudConnectionFactory\" /> </scr:component> In particular, it should expose in the service section the fact that the factory implements org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory <service> <provide interface= \"org.eclipse.kura.cloudconnection.factory.CloudConnectionFactory\" /> </service> Important properties that need to be specified to have a better Web UI experience are the following: <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager(\\-[a-zA-Z0-9]+)?$\" /> those allow to specify the form of the expected PID that the end user should provide when creating a new cloud connection.","title":"Implement the CloudConnectionFactory interface"},{"location":"cloud-api/stack-dev-guide/#provide-a-cloudpublisher-implementation","text":"To provide a CloudPublisher implementation, other than implementing CloudPublisher API in a java class, the developer must provide a component definition in the OSGI-INF folder that should be like the following: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <scr:component xmlns:scr= \"http://www.osgi.org/xmlns/scr/v1.1.0\" activate= \"activate\" configuration-policy= \"require\" deactivate= \"deactivate\" enabled= \"true\" immediate= \"true\" modified= \"updated\" name= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" > <implementation class= \"org.eclipse.kura.internal.cloudconnection.eclipseiot.mqtt.cloud.publisher.CloudPublisherImpl\" /> <service> <provide interface= \"org.eclipse.kura.cloudconnection.publisher.CloudPublisher\" /> <provide interface= \"org.eclipse.kura.configuration.ConfigurableComponent\" /> </service> <property name= \"cloud.connection.factory.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.ConnectionManager\" /> <property name= \"service.pid\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" /> <property name= \"kura.ui.service.hide\" type= \"Boolean\" value= \"true\" /> <property name= \"kura.ui.factory.hide\" type= \"String\" value= \"true\" /> <property name= \"kura.ui.csf.pid.default\" type= \"String\" value= \"org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher\" /> <property name= \"kura.ui.csf.pid.regex\" type= \"String\" value= \"^org.eclipse.kura.cloudconnection.eclipseiot.mqtt.CloudPublisher(\\-[a-zA-Z0-9]+)?$\" /> </scr:component> As can be seen in the previous snippet, the Publisher exposes itself in the framework as a ConfigurableComponent and as a CloudPublisher . The component definition must contain the following well-known properties: cloud.connection.factory.pid : this property must be set to the kura.service.pid of the factory that created the cloud connection which the publisher belongs. It is used by the Web UI to enforce that the correct cloud publisher implementation is used in a specific cloud endpoint. kura.ui.service.hide : as specified before for the Cloud Endpoint kura.ui.factory.hide : as specified before for the Cloud Endpoint kura.ui.csf.pid.default : as specified before for the Cloud Factory. It is an optional property. kura.ui.csf.pid.regex : as specified before for the Cloud Factory. It is an optional property. The relation between the CloudPublisher instance and the CloudEndpoint is defined by a configuration property set by the Web UI at CloudPublisher creation.","title":"Provide a CloudPublisher implementation"},{"location":"cloud-api/stack-dev-guide/#provide-a-cloudsubscriber-implementation","text":"The CloudSubscriber implementation and component definition is similar to the one described for the CloudPublisher.","title":"Provide a CloudSubscriber implementation"},{"location":"cloud-api/stack-dev-guide/#implement-requesthandler-support","text":"In order to support Command and Control, the cloud connection bundle should provide a service that registers itself as RequestHandlerRegistry. In this way all the RequestHandler instances could be able to discover the different Registry and subscribe for command and control messages received from the cloud platform. As an example, for the Eclipse IoT WG bundle, the CloudEndpoint registers itself also as RequestHandlerRegistry.","title":"Implement RequestHandler support"},{"location":"cloud-api/user-guide/","text":"User guide This guide will illustrate the steps required for configuring an application that uses the new Cloud Connection APIs to publish messages to the Kapua platform. The involved steps are the following Instantiation and configuration of the Cloud Connection . Instantiation and configuration of a Publisher . Binding an application to the Publisher . Creating a new Cloud Connection Open the Cloud Connections section of the Web UI: Create a new Cloud Connection Click on the New Connection button Enter a new unique identifier in the Cloud Connection Service PID field. The identifier must be a valid kura.service.pid and, in case of a Kapua Cloud Connection, it must start with the org.eclipse.kura.cloud.CloudService- prefix. A valid identifier can be org.eclipse.kura.cloud.CloudService-KAPUA . As an alternative it is possible to reconfigure the existing org.eclipse.kura.cloud.CloudService Cloud Connection. Configure the MQTTDataTrasport service. Click on the MQTTDataTrasport-KAPUA tab and fill the parameters required for establishing the MQTT connection: Broker-url Topic Context Account-Name Username Password Configure the DataService-KAPUA service. In order to enable automatic connection, set the Connect Auto-on-startup parameter to true Creating and configuring a new Publisher Select to the connection to be used from the list. Click on the New Pub/Sub button. Select the type of component to be created, from the Available Publisher/Subscriber factories drop down list, in order to create a Publisher select the org.eclipse.kura.cloud.publisher.CloudPublisher entry. Enter an unique kura.service.pid identifier in the New Publisher/Subscriber PID field. Click Apply , you should see the publisher configuration Select and configure the newly created publisher instance, and then click Apply Binding an application to a publisher Select the application instance configuration Find the configuration entry that represents a Publisher reference. Click on the Select available targets link and select the desired Publisher instance to bind to. Click on Apply","title":"User guide"},{"location":"cloud-api/user-guide/#user-guide","text":"This guide will illustrate the steps required for configuring an application that uses the new Cloud Connection APIs to publish messages to the Kapua platform. The involved steps are the following Instantiation and configuration of the Cloud Connection . Instantiation and configuration of a Publisher . Binding an application to the Publisher .","title":"User guide"},{"location":"cloud-api/user-guide/#creating-a-new-cloud-connection","text":"Open the Cloud Connections section of the Web UI: Create a new Cloud Connection Click on the New Connection button Enter a new unique identifier in the Cloud Connection Service PID field. The identifier must be a valid kura.service.pid and, in case of a Kapua Cloud Connection, it must start with the org.eclipse.kura.cloud.CloudService- prefix. A valid identifier can be org.eclipse.kura.cloud.CloudService-KAPUA . As an alternative it is possible to reconfigure the existing org.eclipse.kura.cloud.CloudService Cloud Connection. Configure the MQTTDataTrasport service. Click on the MQTTDataTrasport-KAPUA tab and fill the parameters required for establishing the MQTT connection: Broker-url Topic Context Account-Name Username Password Configure the DataService-KAPUA service. In order to enable automatic connection, set the Connect Auto-on-startup parameter to true","title":"Creating a new Cloud Connection"},{"location":"cloud-api/user-guide/#creating-and-configuring-a-new-publisher","text":"Select to the connection to be used from the list. Click on the New Pub/Sub button. Select the type of component to be created, from the Available Publisher/Subscriber factories drop down list, in order to create a Publisher select the org.eclipse.kura.cloud.publisher.CloudPublisher entry. Enter an unique kura.service.pid identifier in the New Publisher/Subscriber PID field. Click Apply , you should see the publisher configuration Select and configure the newly created publisher instance, and then click Apply","title":"Creating and configuring a new Publisher"},{"location":"cloud-api/user-guide/#binding-an-application-to-a-publisher","text":"Select the application instance configuration Find the configuration entry that represents a Publisher reference. Click on the Select available targets link and select the desired Publisher instance to bind to. Click on Apply","title":"Binding an application to a publisher"},{"location":"config/auth/","text":"Gateway Administration Console Authentication The Kura Gateway Administration Console supports multiple login identities with associated permissions and HTTPS client-side authentication with certificates. Kura introduces a centralized authentication and authorization framework based on the OSGi UserAdmin specification. This framework introduces the concepts of identities and permissions: Identity : A Kura identity is related to authentication. An identity has a name and a set of associated credentials, for example, a password. Permission : A Kura permission is related to authorization. Zero or more permissions can be assigned to a given identity. Each permission allows to access a set of resources and/or perform certain operations. Permissions can be defined by applications. The authentication and authorization framework only allows to define and store identities and permissions, it does not provide an implementation of authentication methods and/or session management. These aspects are left to applications. Permissions The Kura Gateway Administration Console defines the following permissions, that restrict the operations that the identity is allowed to perform: kura.cloud.connection.admin : Allows to manage cloud connections using Cloud Connections tab. kura.packages.admin : Allows to install deployment packages using the Packages tab. kura.device : Allows interaction with the Device and Status tabs. kura.network.admin : Allows to manage network connectivity and firewall configuration using the Network and Firewall tabs. kura.wires.admin : Allows to manage Wire Graph and Driver and Asset configurations using the Wires and Drivers and Assets tabs. kura.admin : This permission implies all the other permissions, including the ones defined by external applications. Default Identities Kura provides the following identities by default. Identity Permissions admin kura.admin appadmin kura.cloud.connection.admin kura.packages.admin kura.wires.admin netadmin kura.cloud.connection.admin (not available for no-network profiles) kura.device kura.network.admin Managing Identities and Permissions Managing identities and associated permissions can be done from the Identities section of the web UI. With the controls available in the interface it is possible to: Create new identities with the New Identity button. Change password of existing identity with Change Password button. Delete identities with the Delete Identity button. Assign permissions to identities by selecting the identity and ticking the corresponding permissions. Disable password-based authentication by selecting Password authentication enabled to false . The default password for the admin identity is admin . It is recommended changing the default password after initial setup and before deployment, as well as limiting access to the Kura Gateway Administration Console to a trusted local network interface using appropriate firewall rules.","title":"Gateway Administration Console Authentication"},{"location":"config/auth/#gateway-administration-console-authentication","text":"The Kura Gateway Administration Console supports multiple login identities with associated permissions and HTTPS client-side authentication with certificates. Kura introduces a centralized authentication and authorization framework based on the OSGi UserAdmin specification. This framework introduces the concepts of identities and permissions: Identity : A Kura identity is related to authentication. An identity has a name and a set of associated credentials, for example, a password. Permission : A Kura permission is related to authorization. Zero or more permissions can be assigned to a given identity. Each permission allows to access a set of resources and/or perform certain operations. Permissions can be defined by applications. The authentication and authorization framework only allows to define and store identities and permissions, it does not provide an implementation of authentication methods and/or session management. These aspects are left to applications.","title":"Gateway Administration Console Authentication"},{"location":"config/auth/#permissions","text":"The Kura Gateway Administration Console defines the following permissions, that restrict the operations that the identity is allowed to perform: kura.cloud.connection.admin : Allows to manage cloud connections using Cloud Connections tab. kura.packages.admin : Allows to install deployment packages using the Packages tab. kura.device : Allows interaction with the Device and Status tabs. kura.network.admin : Allows to manage network connectivity and firewall configuration using the Network and Firewall tabs. kura.wires.admin : Allows to manage Wire Graph and Driver and Asset configurations using the Wires and Drivers and Assets tabs. kura.admin : This permission implies all the other permissions, including the ones defined by external applications.","title":"Permissions"},{"location":"config/auth/#default-identities","text":"Kura provides the following identities by default. Identity Permissions admin kura.admin appadmin kura.cloud.connection.admin kura.packages.admin kura.wires.admin netadmin kura.cloud.connection.admin (not available for no-network profiles) kura.device kura.network.admin","title":"Default Identities"},{"location":"config/auth/#managing-identities-and-permissions","text":"Managing identities and associated permissions can be done from the Identities section of the web UI. With the controls available in the interface it is possible to: Create new identities with the New Identity button. Change password of existing identity with Change Password button. Delete identities with the Delete Identity button. Assign permissions to identities by selecting the identity and ticking the corresponding permissions. Disable password-based authentication by selecting Password authentication enabled to false . The default password for the admin identity is admin . It is recommended changing the default password after initial setup and before deployment, as well as limiting access to the Kura Gateway Administration Console to a trusted local network interface using appropriate firewall rules.","title":"Managing Identities and Permissions"},{"location":"config/cloud-service-configuration/","text":"Cloud Service Configuration The CloudService provides an easy-to-use API layer for the M2M application to communicate with a remote server. It operates as a decorator for the DataService, providing add-on features over the management of the transport layer. In addition to simple publish/subscribe, the CloudService API simplifies the implementation of more complex interaction flows like request/response or remote resource management. The CloudService abstracts the developers from the complexity of the transport protocol and payload format used in the communication. The CloudService allows a single connection to a remote server to be shared across more than one application in the gateway, providing the necessary topic partitioning. Its functions include: Adds application topic prefixes to allow a single remote server connection to be shared across applications. Defines a payload data model and provides default encoding/decoding serializers. Publishes life-cycle messages when the device and applications start and stop. To use this service, select the CloudService option located in the Cloud Services area as shown in the screen capture below. The CloudService provides the following configuration parameters: device.display-name - defines the device display name given by the system. (Required field.) device.custom-name - defines the custom device display name if the device.display-name parameter is set to \"Custom\". topic.control-prefix - defines the topic prefix used for system and device management messages. encode.gzip - defines if the message payloads are sent compressed. republish.mqtt.birth.cert.on.gps.lock - when set to true, forces a republish of the MQTT Birth Certificate when a GPS correct position lock is received. The device is then registered with its real coordinates. (Required field.) republish.mqtt.birth.cert.on.modem.detect - when set to true, forces a republish of the MQTT Birth Certificate when the service receives a modem detection event. (Required field.) enable.default.subscriptions - manages the default subscriptions to the gateway management MQTT topics. When disabled, the gateway will not be remotely manageable. birth.cert.policy - specifies the birth cert policy to be used. The possible selectable options are: Disable publishing - No birth message will be sent Publish birth on connect - Publishes a birth message at the first connection event Publish birth on connect and reconnect - Publishes a birth message at connection and reconnection events. payload.encoding - specifies the encoding for the messages sent by the specific CloudService instance. Kura Protobuf - when this option is selected, the Kura Protobuf encoding will be used Simple JSON - the simple JSON encoding will be used instead. More information is available here . An example below. { \"sentOn\" : 1491298822, \"position\" : { \"latitude\" : 45.234, \"longitude\" : -7.3456, \"altitude\" : 1.0, \"heading\" : 5.4, \"precision\" : 0.1, \"speed\" : 23.5, \"timestamp\" : 1191292288, \"satellites\" : 3, \"status\" : 2 }, \"metrics\": { \"code\" : \"A23D44567Q\", \"distance\" : 0.26456E+4, \"temperature\" : 27.5, \"count\" : 12354, \"timestamp\" : 23412334545, \"enable\" : true, \"rawBuffer\" : \"cGlwcG8gcGx1dG8gcGFwZXJpbm8=\" }, \"body\": \"UGlwcG8sIHBsdXRvLCBwYXBlcmlubywgcXVpLCBxdW8gZSBxdWEu\" } The Simple JSON payload encoding is not supported by Everyware Cloud. Use the default Kura Protobuf encoding instead.","title":"Cloud Service Configuration"},{"location":"config/cloud-service-configuration/#cloud-service-configuration","text":"The CloudService provides an easy-to-use API layer for the M2M application to communicate with a remote server. It operates as a decorator for the DataService, providing add-on features over the management of the transport layer. In addition to simple publish/subscribe, the CloudService API simplifies the implementation of more complex interaction flows like request/response or remote resource management. The CloudService abstracts the developers from the complexity of the transport protocol and payload format used in the communication. The CloudService allows a single connection to a remote server to be shared across more than one application in the gateway, providing the necessary topic partitioning. Its functions include: Adds application topic prefixes to allow a single remote server connection to be shared across applications. Defines a payload data model and provides default encoding/decoding serializers. Publishes life-cycle messages when the device and applications start and stop. To use this service, select the CloudService option located in the Cloud Services area as shown in the screen capture below. The CloudService provides the following configuration parameters: device.display-name - defines the device display name given by the system. (Required field.) device.custom-name - defines the custom device display name if the device.display-name parameter is set to \"Custom\". topic.control-prefix - defines the topic prefix used for system and device management messages. encode.gzip - defines if the message payloads are sent compressed. republish.mqtt.birth.cert.on.gps.lock - when set to true, forces a republish of the MQTT Birth Certificate when a GPS correct position lock is received. The device is then registered with its real coordinates. (Required field.) republish.mqtt.birth.cert.on.modem.detect - when set to true, forces a republish of the MQTT Birth Certificate when the service receives a modem detection event. (Required field.) enable.default.subscriptions - manages the default subscriptions to the gateway management MQTT topics. When disabled, the gateway will not be remotely manageable. birth.cert.policy - specifies the birth cert policy to be used. The possible selectable options are: Disable publishing - No birth message will be sent Publish birth on connect - Publishes a birth message at the first connection event Publish birth on connect and reconnect - Publishes a birth message at connection and reconnection events. payload.encoding - specifies the encoding for the messages sent by the specific CloudService instance. Kura Protobuf - when this option is selected, the Kura Protobuf encoding will be used Simple JSON - the simple JSON encoding will be used instead. More information is available here . An example below. { \"sentOn\" : 1491298822, \"position\" : { \"latitude\" : 45.234, \"longitude\" : -7.3456, \"altitude\" : 1.0, \"heading\" : 5.4, \"precision\" : 0.1, \"speed\" : 23.5, \"timestamp\" : 1191292288, \"satellites\" : 3, \"status\" : 2 }, \"metrics\": { \"code\" : \"A23D44567Q\", \"distance\" : 0.26456E+4, \"temperature\" : 27.5, \"count\" : 12354, \"timestamp\" : 23412334545, \"enable\" : true, \"rawBuffer\" : \"cGlwcG8gcGx1dG8gcGFwZXJpbm8=\" }, \"body\": \"UGlwcG8sIHBsdXRvLCBwYXBlcmlubywgcXVpLCBxdW8gZSBxdWEu\" } The Simple JSON payload encoding is not supported by Everyware Cloud. Use the default Kura Protobuf encoding instead.","title":"Cloud Service Configuration"},{"location":"config/cloud-services/","text":"Cloud Connections The Cloud Connections section of the Kura Administrative Web UI allows user to create and manage cloud connections. By default, Kura starts with a single cloud connection, as depicted in the following image: The cloud connections page allows to: - create a new cloud connection; - create a new publisher or subscriber component; - delete an existing cloud connection; - connect a selected cloud stack to the configured cloud platform; - disconnect the selected cloud stack from the connected cloud platform; - refresh the existing cloud connections. When clicking on the New button, a dialog is displayed as depicted in the image below: The user can select one of the existing cloud connection factories and give it a name (depending on the implementation, a name format can be suggested or forced). Selecting a created Cloud Connection it is possible to associate a new publisher/subscriber by clicking the New Pub/Sub button. As for the connection creation case, the user can select one of the existing publisher/subscriber factories and give it a name.","title":"Cloud Connections"},{"location":"config/cloud-services/#cloud-connections","text":"The Cloud Connections section of the Kura Administrative Web UI allows user to create and manage cloud connections. By default, Kura starts with a single cloud connection, as depicted in the following image: The cloud connections page allows to: - create a new cloud connection; - create a new publisher or subscriber component; - delete an existing cloud connection; - connect a selected cloud stack to the configured cloud platform; - disconnect the selected cloud stack from the connected cloud platform; - refresh the existing cloud connections. When clicking on the New button, a dialog is displayed as depicted in the image below: The user can select one of the existing cloud connection factories and give it a name (depending on the implementation, a name format can be suggested or forced). Selecting a created Cloud Connection it is possible to associate a new publisher/subscriber by clicking the New Pub/Sub button. As for the connection creation case, the user can select one of the existing publisher/subscriber factories and give it a name.","title":"Cloud Connections"},{"location":"config/connection-monitors/","text":"Connection Monitors in DataService The DataService offers methods and configuration options to monitor the connection to the remote server and, eventually, cause a system reboot to recover from transient network problems. This feature, if enabled, leverages the watchdog service and reboots the gateway if the maximum number of configured connection attempts has been made. A reboot is not requested if the connection to the remote broker succeeds but an authentication error , an invalid client id or an authorization error is thrown by the remote cloud platform and causes a connection drop. The image below shows the parameters that need to be tuned in order to enable this connection monitor feature. To configure this functionality, the System Administrator needs to specify the following configuration elements: enable.recovery.on.connection.failure - when enabled, activates the recovery feature on connection failure: if the device is not able to connect to a remote cloud platform, the service will wait for a specified amount of connection retries. If the recovery fails, the device will be rebooted. Being based on the Watchdog service, it needs to be activated as well. connection.recovery.max.failures - related to the previous parameter. It specifies the number of failures before a reboot is requested. To be fully working, this feature needs the enabling of the Watchdog Service.","title":"Connection Monitors in DataService"},{"location":"config/connection-monitors/#connection-monitors-in-dataservice","text":"The DataService offers methods and configuration options to monitor the connection to the remote server and, eventually, cause a system reboot to recover from transient network problems. This feature, if enabled, leverages the watchdog service and reboots the gateway if the maximum number of configured connection attempts has been made. A reboot is not requested if the connection to the remote broker succeeds but an authentication error , an invalid client id or an authorization error is thrown by the remote cloud platform and causes a connection drop. The image below shows the parameters that need to be tuned in order to enable this connection monitor feature. To configure this functionality, the System Administrator needs to specify the following configuration elements: enable.recovery.on.connection.failure - when enabled, activates the recovery feature on connection failure: if the device is not able to connect to a remote cloud platform, the service will wait for a specified amount of connection retries. If the recovery fails, the device will be rebooted. Being based on the Watchdog service, it needs to be activated as well. connection.recovery.max.failures - related to the previous parameter. It specifies the number of failures before a reboot is requested. To be fully working, this feature needs the enabling of the Watchdog Service.","title":"Connection Monitors in DataService"},{"location":"config/console/","text":"Gateway Administration Console Accessing the Kura Gateway Administration Console Kura provides a web-based, user interface for the administration and management of your IoT gateway. The Kura Gateway Administration Console enables you to monitor the gateway status, manage the network configuration, and manage the installed application and services. Access to the Kura Gateway Administration Console requires that a unit running Eclipse Kura is reachable via its Ethernet or Wi-Fi network interfaces (i.e., eth0, eth1, or wlan0). The default (out-of-the-box) network configuration for the supported platforms is as follows: Raspberry Pi eth0 Status: Enabled for WAN Configure: DHCP (DHCP client) wlan0 Status: Enabled for LAN Configure: Manually (Static IP) IP Address: 172.16.1.1 Subnet Mask: 255.255.255.0 Wireless Mode: Access Point SSID: kura_gateway_<eth0_MAC_Address> Wireless Security: WPA/WPA2 Passphrase: testKEYS Connections on HTTP port 443 for these interfaces are allowed by default through the built-in firewall. The Kura Gateway Administration Console can be accessed by typing the IP address of the gateway into the browser's URL bar. Once the URL is submitted, the user is required to log in and is then redirected to the Administration Console (e.g., https://192.168.2.8/admin/console ) shown in the screen capture below. The default login name and password is admin/admin . {% include alerts.html message='It is recommended to change the default password after initial setup and before deployment, as well as limiting access to the Administration Console to a trusted local network interface using appropriate firewall rules.' %} Password change Once logged in, the user can modify its password (recommended after the first login). To access the option, click on the button near the username in the header section. A dropdown menu appears with the logout and the password modification options. When clicking on \"Change password\", the following dialog will appear: After confirming the changes, the user will be logged out.","title":"Gateway Administration Console"},{"location":"config/console/#gateway-administration-console","text":"","title":"Gateway Administration Console"},{"location":"config/console/#accessing-the-kura-gateway-administration-console","text":"Kura provides a web-based, user interface for the administration and management of your IoT gateway. The Kura Gateway Administration Console enables you to monitor the gateway status, manage the network configuration, and manage the installed application and services. Access to the Kura Gateway Administration Console requires that a unit running Eclipse Kura is reachable via its Ethernet or Wi-Fi network interfaces (i.e., eth0, eth1, or wlan0). The default (out-of-the-box) network configuration for the supported platforms is as follows: Raspberry Pi eth0 Status: Enabled for WAN Configure: DHCP (DHCP client) wlan0 Status: Enabled for LAN Configure: Manually (Static IP) IP Address: 172.16.1.1 Subnet Mask: 255.255.255.0 Wireless Mode: Access Point SSID: kura_gateway_<eth0_MAC_Address> Wireless Security: WPA/WPA2 Passphrase: testKEYS Connections on HTTP port 443 for these interfaces are allowed by default through the built-in firewall. The Kura Gateway Administration Console can be accessed by typing the IP address of the gateway into the browser's URL bar. Once the URL is submitted, the user is required to log in and is then redirected to the Administration Console (e.g., https://192.168.2.8/admin/console ) shown in the screen capture below. The default login name and password is admin/admin . {% include alerts.html message='It is recommended to change the default password after initial setup and before deployment, as well as limiting access to the Administration Console to a trusted local network interface using appropriate firewall rules.' %}","title":"Accessing the Kura Gateway Administration Console"},{"location":"config/console/#password-change","text":"Once logged in, the user can modify its password (recommended after the first login). To access the option, click on the button near the username in the header section. A dropdown menu appears with the logout and the password modification options. When clicking on \"Change password\", the following dialog will appear: After confirming the changes, the user will be logged out.","title":"Password change"},{"location":"config/data-service-configuration/","text":"Data Service Configuration The DataService provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. The DataService delegates to the MqttDataTransport service the implementation of the transport protocol that is used to interact with the remote server. The DataService also adds the capability of storing published messages in a persistent store function and sending them over the wire at a later time. The purpose of this feature is to relieve service users from implementing their own persistent store. Service users may publish messages independently on the DataService connection status. In order to overcome the potential latencies introduced by buffering messages, the DataService allows a priority level to be assigned to\u200b each published message. Depending on the store configuration, there are certain guarantees that stored messages are not lost due to sudden crashes or power outages. To use this service, select the DataService option located in the Cloud Connections area as shown in the screen capture below. The DataService offers methods and configuration options to manage the connection to the remote server including the following (all required) parameters described below. connect.auto-on-startup - when set to true, the service tries to auto-connect to the remote server on start-up and restore the connection every time the device is disconnected. These attempts are made at the frequency defined in the connect.retry-interval parameter until the connection is established. connect.retry-interval - specifies the connection retry frequency after a disconnection. enable.recovery.on.connection.failure - when enabled, activates the recovery feature on connection failure: if the device is not able to connect to a remote cloud platform, the service will wait for a specified amount of connection retries. If the recovery fails, the device will be rebooted. Being based on the Watchdog service, it needs to be activated as well. connection.recovery.max.failures - related to the previous parameter. It specifies the number of failures before a reboot is requested. disconnect.quiesce-timeout - allows the delivery of in-flight messages to be completed before disconnecting from the broker when a disconnection from the broker is being forced. store.db.service.pid - The Kura Service PID of the database instance to be used. The PID of the default instance is org.eclipse.kura.db.H2DbService. store.housekeeper-interval - defines the interval in seconds used to run the Data Store housekeeper task. store.purge-age - defines the age in seconds of completed messages (either published with QoS = 0 or confirmed with QoS > 0) after which they are deleted (minimum 5). store.capacity - defines the maximum number of messages persisted in the Data Store. in-flight-messages.republish-on-new-session - it specifies whether to republish in-flight messages on a new MQTT session. in-flight-messages.max-number - it specifies the maximum number of in-flight messages. in-flight-messages.congestion-timeout - timeouts the in-flight messages congestion condition. The service will force a disconnect attempting to reconnect. enable.rate.limit - Enables the token bucket message rate limiting. rate.limit.average - The average message publishing rate. It is intended as the number of messages per unit of time. The maximum allowed message rate is 1 message per millisecond , so the following limitations are applied: 86400000 per DAY 3600000 per HOUR 60000 messages per MINUTE 1000 messages per SECOND rate.limit.time.unit - The time unit for the rate.limit.average. rate.limit.burst.size - The token bucket burst size.","title":"Data Service Configuration"},{"location":"config/data-service-configuration/#data-service-configuration","text":"The DataService provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. The DataService delegates to the MqttDataTransport service the implementation of the transport protocol that is used to interact with the remote server. The DataService also adds the capability of storing published messages in a persistent store function and sending them over the wire at a later time. The purpose of this feature is to relieve service users from implementing their own persistent store. Service users may publish messages independently on the DataService connection status. In order to overcome the potential latencies introduced by buffering messages, the DataService allows a priority level to be assigned to\u200b each published message. Depending on the store configuration, there are certain guarantees that stored messages are not lost due to sudden crashes or power outages. To use this service, select the DataService option located in the Cloud Connections area as shown in the screen capture below. The DataService offers methods and configuration options to manage the connection to the remote server including the following (all required) parameters described below. connect.auto-on-startup - when set to true, the service tries to auto-connect to the remote server on start-up and restore the connection every time the device is disconnected. These attempts are made at the frequency defined in the connect.retry-interval parameter until the connection is established. connect.retry-interval - specifies the connection retry frequency after a disconnection. enable.recovery.on.connection.failure - when enabled, activates the recovery feature on connection failure: if the device is not able to connect to a remote cloud platform, the service will wait for a specified amount of connection retries. If the recovery fails, the device will be rebooted. Being based on the Watchdog service, it needs to be activated as well. connection.recovery.max.failures - related to the previous parameter. It specifies the number of failures before a reboot is requested. disconnect.quiesce-timeout - allows the delivery of in-flight messages to be completed before disconnecting from the broker when a disconnection from the broker is being forced. store.db.service.pid - The Kura Service PID of the database instance to be used. The PID of the default instance is org.eclipse.kura.db.H2DbService. store.housekeeper-interval - defines the interval in seconds used to run the Data Store housekeeper task. store.purge-age - defines the age in seconds of completed messages (either published with QoS = 0 or confirmed with QoS > 0) after which they are deleted (minimum 5). store.capacity - defines the maximum number of messages persisted in the Data Store. in-flight-messages.republish-on-new-session - it specifies whether to republish in-flight messages on a new MQTT session. in-flight-messages.max-number - it specifies the maximum number of in-flight messages. in-flight-messages.congestion-timeout - timeouts the in-flight messages congestion condition. The service will force a disconnect attempting to reconnect. enable.rate.limit - Enables the token bucket message rate limiting. rate.limit.average - The average message publishing rate. It is intended as the number of messages per unit of time. The maximum allowed message rate is 1 message per millisecond , so the following limitations are applied: 86400000 per DAY 3600000 per HOUR 60000 messages per MINUTE 1000 messages per SECOND rate.limit.time.unit - The time unit for the rate.limit.average. rate.limit.burst.size - The token bucket burst size.","title":"Data Service Configuration"},{"location":"config/device-information/","text":"Device Information Along with the Status of a Kura Gateway, the Device section provides several information about the gateway where Kura is running on. This section can be accessed by selecting the Device option located in the System area. Profile The Profile tab shows several information about the gateway, organized under the Device, Hardware, Software and Java Information. Bundles This tab lists all the bundles installed on ESF, with details about the name, version, id, state and signature. The signature value will be true if the corresponding bundle is digitally signed, false otherwise. The buttons in the upper part of the tab allows the user to manage the listed bundles: Start Bundle : starts a bundle that is in Resolved or Installed state; Stop Bundle : stops a bundle that is in Active state; Refresh : reloads the bundles states list. Threads The Threads tab shows a list of the threads that are currently running in the JVM. System Packages The System Packages tab shows the list of all the Linux packages installed on the OS. The package is detailed with the name, version and type (DEB/RPM/APK). System Properties The System Properties tab shows a list of relevant properties including OS and JVM parameters. Command A detailed description of this tab is presented in the Command Service page. System Logs The System Logs tab allows to download a compressed file containing all the relevant log files from the gateway. The download button creates and downloads a compressed file with the following items: all the files in /var/log or the the content of the folder defined by the kura.log.download.sources property; the content of the journal for the Kura process (kura-journal.log); the content of the journal for the whole system (system-journal.log). In addition to this feature, the page also allows the real-time displaying of system logs, if the framework has the availability of one or more components that implement the LogProvider API. The UI also provides a useful button to open a new Kura instance in a new browser window. A reference implementation of the LogProvider API is provided in the org.eclipse.kura.log.filesystem.provider bundle. This bundle exposes in the framework a factory that can be used to read filesystem files. By default, Eclipse Kura creates two log providers at startup: one that reads from /var/log/kura.log and the other that reads from /var/log/kura-audit.log .","title":"Device Information"},{"location":"config/device-information/#device-information","text":"Along with the Status of a Kura Gateway, the Device section provides several information about the gateway where Kura is running on. This section can be accessed by selecting the Device option located in the System area.","title":"Device Information"},{"location":"config/device-information/#profile","text":"The Profile tab shows several information about the gateway, organized under the Device, Hardware, Software and Java Information.","title":"Profile"},{"location":"config/device-information/#bundles","text":"This tab lists all the bundles installed on ESF, with details about the name, version, id, state and signature. The signature value will be true if the corresponding bundle is digitally signed, false otherwise. The buttons in the upper part of the tab allows the user to manage the listed bundles: Start Bundle : starts a bundle that is in Resolved or Installed state; Stop Bundle : stops a bundle that is in Active state; Refresh : reloads the bundles states list.","title":"Bundles"},{"location":"config/device-information/#threads","text":"The Threads tab shows a list of the threads that are currently running in the JVM.","title":"Threads"},{"location":"config/device-information/#system-packages","text":"The System Packages tab shows the list of all the Linux packages installed on the OS. The package is detailed with the name, version and type (DEB/RPM/APK).","title":"System Packages"},{"location":"config/device-information/#system-properties","text":"The System Properties tab shows a list of relevant properties including OS and JVM parameters.","title":"System Properties"},{"location":"config/device-information/#command","text":"A detailed description of this tab is presented in the Command Service page.","title":"Command"},{"location":"config/device-information/#system-logs","text":"The System Logs tab allows to download a compressed file containing all the relevant log files from the gateway. The download button creates and downloads a compressed file with the following items: all the files in /var/log or the the content of the folder defined by the kura.log.download.sources property; the content of the journal for the Kura process (kura-journal.log); the content of the journal for the whole system (system-journal.log). In addition to this feature, the page also allows the real-time displaying of system logs, if the framework has the availability of one or more components that implement the LogProvider API. The UI also provides a useful button to open a new Kura instance in a new browser window. A reference implementation of the LogProvider API is provided in the org.eclipse.kura.log.filesystem.provider bundle. This bundle exposes in the framework a factory that can be used to read filesystem files. By default, Eclipse Kura creates two log providers at startup: one that reads from /var/log/kura.log and the other that reads from /var/log/kura-audit.log .","title":"System Logs"},{"location":"config/ethernet-configuration/","text":"Ethernet Configuration As described in the Network Configuration section, Ethernet interfaces have two configuration tabs: TCP/IP and DHCP & NAT . Each Ethernet interface may be configured either as LAN or WAN; it may also be disabled. If the interface is designated as LAN and is manually configured, the DHCP & NAT tab is enabled to allow DHCP server and/or 'many-to-one' NAT setup; otherwise, the DHCP & NAT tab is disabled. For more information on TCP/IP and DHCP & NAT settings, please refer to the Network Configuration section.","title":"Ethernet Configuration"},{"location":"config/ethernet-configuration/#ethernet-configuration","text":"As described in the Network Configuration section, Ethernet interfaces have two configuration tabs: TCP/IP and DHCP & NAT . Each Ethernet interface may be configured either as LAN or WAN; it may also be disabled. If the interface is designated as LAN and is manually configured, the DHCP & NAT tab is enabled to allow DHCP server and/or 'many-to-one' NAT setup; otherwise, the DHCP & NAT tab is disabled. For more information on TCP/IP and DHCP & NAT settings, please refer to the Network Configuration section.","title":"Ethernet Configuration"},{"location":"config/firewall-configuration/","text":"Firewall Configuration Kura offers easy management of the Linux firewall iptables included in an IoT Gateway. Additionally, Kura provides the ability to manage network access security to an IoT Gateway through the following: Open Ports (local service rules) Port Forwarding IP Forwarding and Masquerading (NAT service rules) 'Automatic' NAT service rules Open Ports, Port Forwarding, and IP Forwarding and Masquerading are configured via respective Firewall configuration tabs. 'Automatic' NAT is enabled for each local (LAN) interface using the DHCP & NAT tab of the respective interface configuration. Firewall Linux Configuration This section describes the changes applied by Kura at the Linux networking configuration. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state. When a new firewall configuration is submitted, Kura immediately applies it using the iptables service provided by the OS. Moreover, the rules are stored in the filesystem and a new Kura snapshot is generated containing the new configuration. At the next startup, the firewall service in the OS will re-apply them and Kura will check the firewall configuration against the one contained in the last snapshot. In this way, the user can update the snapshot with the needed rules and apply them to the system using the webUI or modify the snapshot_0.xml before the first start of Kura. In order to allow a better coexistence between Kura and external applications that need to modify firewall rules, Kura writes its rules to a set of custom iptables chains. They are input-kura , output-kura , forward-kura , forward-kura-pf and forward-kura-ipf for the filter table and input-kura , output-kura , prerouting-kura , prerouting-kura-pf , postrouting-kura , postrouting-kura-pf and postrouting-kura-ipf for the nat table. The custom chains are then put in their respective standard iptables chains, as shown in the following: iptables -t filter -I INPUT -j input-kura iptables -t filter -I OUTPUT -j output-kura iptables -t filter -I FORWARD -j forward-kura iptables -t filter -I forward-kura -j forward-kura-pf iptables -t filter -I forward-kura -j forward-kura-ipf iptables -t nat -I PREROUTING -j prerouting-kura iptables -t nat -I prerouting-kura -j prerouting-kura-pf iptables -t nat -I INPUT -j input-kura iptables -t nat -I OUTPUT -j output-kura iptables -t nat -I POSTROUTING -j postrouting-kura iptables -t nat -I postrouting-kura -j postrouting-kura-pf iptables -t nat -I postrouting-kura -j postrouting-kura-ipf Even if many firewall rules can be handled by Kura, it could be that some rules cannot be filled through the Web Console. In this case, custom firewall rules may be added to the /etc/init.d/firewall_cust script manually. These rules are applied/reapplied every time the firewall service starts, that is at the gateway startup. These custom rules should not be applied to the Kura custom chains, but to the standard ones. Open Ports If Kura is running on a gateway, all TCP/UDP ports are closed by default unless custom rules are added to the /etc/sysconfig/iptables file. Therefore, if a user needs to connect to a specific port on a gateway, it is insufficient to have an application listening on the desired port; the port also needs to be opened in the firewall. To open a port using the Administration Console, select the Firewall option located in the System area. The Firewall configuration display appears in the main window. With the Open Ports tab selected, click the New button. The New Open Port Entry form appears. The New Open Port Entry form contains the following configuration parameters: Port or Port Range - specifies the port or port range ( : ) to be opened. (Required field.) Protocol - defines the protocol (tcp or udp). (Required field.) Permitted Network - only allows packets originated by a host on this network in CIDR notation (e.g. 172.16.1.0/24) Permitted Interface Name - only allows packets arrived on this interface. Unpermitted Interface Name - blocks packets arrived on this interface. Permitted MAC Address - only allows packets originated by this host in the format XX:XX:XX:XX:XX:XX. Source Port Range - only allows packets with source port in the defined range ( : ). Complete the New Open Port Entry form and click the Submit button when finished. Once the form is submitted, a new port entry will appear. Click the Apply button for the change to take effect. The firewall rules related to the open ports section are stored in the input-kura custom chain of the filter table. Port Forwarding Port forwarding rules are needed to establish connectivity from the WAN side to a specific port on a host that resides on a LAN behind the gateway. In this case, a routing solution may be avoided since the connection is made to a specified external port on a gateway, and packets are forwarded to an internal port on the destination host; therefore, it is not necessary to add the external port to the list of open ports. To add a port forwarding rule, select the Port Forwarding tab on the Firewall display and click the New button. The Port Forward Entry form appears. The Port Forward Entry form contains the following configuration parameters: Input Interface - specifies the interface through which a packet is going to be received. (Required field.) Output Interface - specifies the interface through which a packet is going to be forwarded to its destination. (Required field.) LAN Address - supplies the IP address of the destination host. (Required field.) Protocol - defines the protocol (tcp or udp). (Required field.) External Port - provides the external destination port on the gateway unit. (Required field.) Internal Port - provides the port on a destination host. (Required field.) Enable Masquerading - defines whether masquerading is used (yes or no). If enabled, the gateway replaces the IP address of the originating host with the IP address of its own output (LAN) interface. This is needed when the destination host does not have a back route to the originating host (or default gateway route) via the gateway unit. The masquerading option is provided with port forwarding to limit gateway forwarding only to the destination port. (Required field.) Permitted Network - only forwards if the packet is originated from a host on this network. Permitted MAC Address - only forwards if the packet is originated by this host. Source Port Range - only forwards if the packet's source port is within the defined range. Complete the Port Forward Entry form and click the Apply button for the desired port forwarding rules to take effect. The firewall rules related to the port forwarding section are stored in the forward-kura-pf custom chain of the filter table and in the postrouting-kura-pf and prerouting-kura-pf chains of the nat table. Port Forwarding example This section describes an example of port forwarding rules. The initial setup is described below. A couple of RaspberryPi 3 that shares the same LAN over Ethernet. The first RaspberryPi running Kura is configured as follows: The eth0 interface static with IP address of 172.16.0.5. There is no default gateway. The second RaspberryPi running Kura is configured as follows: The eth0 interface LAN/static with IP address of 172.16.0.1/24 and no NAT. The wlan0 interface is WAN/DHCP client. A laptop is connected to the same network of the wlan0 of the second RaspberryPi and can ping its wlan0 interface. The purpose of the second RaspberryPi configuration is to enable access to the Administration Console running on the first one (port 80) by connecting to the second RaspberryPi's port 8080 over the wlan. This scenario assumes that IP addresses are assigned as follows: Second RaspberryPi wlan0 - 10.200.12.6 Laptop wlan0 - 10.200.12.10 The following port forwarding entries are added to the second RaspberryPi configuration as described above using the Port Forward Entry form: Input Interface - wlan0 Output Interface - eth0 LAN Address - 172.16.0.5 Protocol - tcp External Port - 8080 Internal Port - 80 Masquerade - yes The Permitted Network , Permitted MAC Address , and Source Port Range fields are left blank. The following iptables rules are applied and added to the /etc/sysconfig/iptables file: iptables -t nat -A prerouting-kura-pf -i wlan0 -p tcp -s 0.0.0.0/0 --dport 8080 -j DNAT --to 172.16.0.5:80 iptables -t nat -A postrouting-kura-pf -o eth0 -p tcp -d 172.16.0.5 -j MASQUERADE iptables -A forward-kura-pf -i wlan0 -o eth0 -p tcp -s 0.0.0.0/0 --dport 80 -d 172.16.0.5 -j ACCEPT iptables -A forward-kura-pf -i eth0 -o wlan0 -p tcp -s 172.16.0.5 -m state --state RELATED,ESTABLISHED -j ACCEPT The following iptables commands may be used to verify that the new rules have been applied: sudo iptables -v -n -L sudo iptables -v -n -L -t nat At this point, it is possible to try to connect to http://10.200.12.6 and to http://10.200.12.6:8080 from the laptop. Note that when a connection is made to the device on port 80, it is to the Kura configuration page on the device itself (the second RaspberryPi). When the gateway is connected on port 8080, you are forwarded to the Kura Gateway Administration Console on the first RaspberryPi. The destination host can only be reached by connecting to the gateway on port 8080. Another way to connect to the Kura Gateway Administration Console on the first RaspberryPi would be to add an IP Forwarding/Masquerading entry as described in the next section. IP Forwarding/Masquerading The advantage of the Automatic NAT method is its simplicity. However, this approach does not handle reverse NATing, and it cannot be used for interfaces that are not listed in the Gateway Administration Console. To set up generic (one-to-many) NATing, select the IP Forwarding/Masquerading tab on the Firewall display. The IP Forwarding/Masquerading form appears. The IP Forwarding/Masquerading form contains the following configuration parameters: Input Interface - specifies the interface through which a packet is going to be received. (Required field.) Output Interface - specifies the interface through which a packet is going to be forwarded to its destination. (Required field.) Protocol - defines the protocol of the rule to check (all, tcp, or udp). (Required field.) Source Network/Host - identifies the source network or host name (CIDR notation). Set to 0.0.0.0/0 if empty. Destination Network/Host - identifies the destination network or host name (CIDR notation). Set to 0.0.0.0/0 if empty. Enable Masquerading - defines whether masquerading is used (yes or no). If set to 'yes', masquerading is enabled. If set to 'no', only FORWARDING rules are being added. (Required field.) The rules will be added to the forward-kura-ipf chain in the filter table and in the postrouting-kura-ipf one in the nat table. As a use-case scenario, consider the same setup as in port forwarding. In this case, the interfaces of the gateway are configured as follows: eth0 - LAN/Static/No NAT 172.16.0.1/24 wlan0 - WAN/DHCP 10.200.12.6/24 To reach the RaspberryPi unit sitting on the 172.16.0.5/24 from a specific host on the 10.200.0.0/16 network, set up the following Reverse NAT entry: Input Interface - wlan0 (WAN interface) Output Interface - eth0 (LAN interface) Protocol - tcp Source Network/Host - 10.200.12.10/32 Destination Network/Host - 172.16.0.5/32 Enable Masquerading - yes This case adds the following iptables rules to the /etc/sysconfig/iptables file: iptables -t nat -A postrouting-kura-ipf -p tcp -s 10.200.12.6/32 -d 172.16.0.5/32 -o eth0 -j MASQUERADE iptables -A forward-kura-ipf -p tcp -s 172.16.0.5/32 -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A forward-kura-ipf -p tcp -s 10.200.12.6/32 -d 172.16.0.5/32 -i wlan0 -o eth0 -m tcp -j ACCEPT Additionally, a route to the 172.16.0.0/24 network needs to be configured on a connecting laptop as shown below: sudo route add -net 172.16.0.0 netmask 255.255.255.0 gw 10.200.12.6 Since masquerading is enabled, there is no need to specify the back route on the destination host. Note that with this setup, the RaspberryPi only forwards packets originating on the 10.200.12.10 laptop to the 172.16.0.5 destination. If the Source Network/Host and Destination Network/Host fields are empty, iptables rules appear as follows: iptables -t nat -A postrouting-kura-ipf -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -o eth0 -j MASQUERADE iptables -A forward-kura-ipf -p tcp -s 0.0.0.0/0 -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A forward-kura-ipf -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -i wlan0 -o eth0 -j ACCEPT The RaspberryPi forwards packets from any external host (connected to wlan0) to any destination on the local network (eth0 interface).","title":"Firewall Configuration"},{"location":"config/firewall-configuration/#firewall-configuration","text":"Kura offers easy management of the Linux firewall iptables included in an IoT Gateway. Additionally, Kura provides the ability to manage network access security to an IoT Gateway through the following: Open Ports (local service rules) Port Forwarding IP Forwarding and Masquerading (NAT service rules) 'Automatic' NAT service rules Open Ports, Port Forwarding, and IP Forwarding and Masquerading are configured via respective Firewall configuration tabs. 'Automatic' NAT is enabled for each local (LAN) interface using the DHCP & NAT tab of the respective interface configuration.","title":"Firewall Configuration"},{"location":"config/firewall-configuration/#firewall-linux-configuration","text":"This section describes the changes applied by Kura at the Linux networking configuration. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state. When a new firewall configuration is submitted, Kura immediately applies it using the iptables service provided by the OS. Moreover, the rules are stored in the filesystem and a new Kura snapshot is generated containing the new configuration. At the next startup, the firewall service in the OS will re-apply them and Kura will check the firewall configuration against the one contained in the last snapshot. In this way, the user can update the snapshot with the needed rules and apply them to the system using the webUI or modify the snapshot_0.xml before the first start of Kura. In order to allow a better coexistence between Kura and external applications that need to modify firewall rules, Kura writes its rules to a set of custom iptables chains. They are input-kura , output-kura , forward-kura , forward-kura-pf and forward-kura-ipf for the filter table and input-kura , output-kura , prerouting-kura , prerouting-kura-pf , postrouting-kura , postrouting-kura-pf and postrouting-kura-ipf for the nat table. The custom chains are then put in their respective standard iptables chains, as shown in the following: iptables -t filter -I INPUT -j input-kura iptables -t filter -I OUTPUT -j output-kura iptables -t filter -I FORWARD -j forward-kura iptables -t filter -I forward-kura -j forward-kura-pf iptables -t filter -I forward-kura -j forward-kura-ipf iptables -t nat -I PREROUTING -j prerouting-kura iptables -t nat -I prerouting-kura -j prerouting-kura-pf iptables -t nat -I INPUT -j input-kura iptables -t nat -I OUTPUT -j output-kura iptables -t nat -I POSTROUTING -j postrouting-kura iptables -t nat -I postrouting-kura -j postrouting-kura-pf iptables -t nat -I postrouting-kura -j postrouting-kura-ipf Even if many firewall rules can be handled by Kura, it could be that some rules cannot be filled through the Web Console. In this case, custom firewall rules may be added to the /etc/init.d/firewall_cust script manually. These rules are applied/reapplied every time the firewall service starts, that is at the gateway startup. These custom rules should not be applied to the Kura custom chains, but to the standard ones.","title":"Firewall Linux Configuration"},{"location":"config/firewall-configuration/#open-ports","text":"If Kura is running on a gateway, all TCP/UDP ports are closed by default unless custom rules are added to the /etc/sysconfig/iptables file. Therefore, if a user needs to connect to a specific port on a gateway, it is insufficient to have an application listening on the desired port; the port also needs to be opened in the firewall. To open a port using the Administration Console, select the Firewall option located in the System area. The Firewall configuration display appears in the main window. With the Open Ports tab selected, click the New button. The New Open Port Entry form appears. The New Open Port Entry form contains the following configuration parameters: Port or Port Range - specifies the port or port range ( : ) to be opened. (Required field.) Protocol - defines the protocol (tcp or udp). (Required field.) Permitted Network - only allows packets originated by a host on this network in CIDR notation (e.g. 172.16.1.0/24) Permitted Interface Name - only allows packets arrived on this interface. Unpermitted Interface Name - blocks packets arrived on this interface. Permitted MAC Address - only allows packets originated by this host in the format XX:XX:XX:XX:XX:XX. Source Port Range - only allows packets with source port in the defined range ( : ). Complete the New Open Port Entry form and click the Submit button when finished. Once the form is submitted, a new port entry will appear. Click the Apply button for the change to take effect. The firewall rules related to the open ports section are stored in the input-kura custom chain of the filter table.","title":"Open Ports"},{"location":"config/firewall-configuration/#port-forwarding","text":"Port forwarding rules are needed to establish connectivity from the WAN side to a specific port on a host that resides on a LAN behind the gateway. In this case, a routing solution may be avoided since the connection is made to a specified external port on a gateway, and packets are forwarded to an internal port on the destination host; therefore, it is not necessary to add the external port to the list of open ports. To add a port forwarding rule, select the Port Forwarding tab on the Firewall display and click the New button. The Port Forward Entry form appears. The Port Forward Entry form contains the following configuration parameters: Input Interface - specifies the interface through which a packet is going to be received. (Required field.) Output Interface - specifies the interface through which a packet is going to be forwarded to its destination. (Required field.) LAN Address - supplies the IP address of the destination host. (Required field.) Protocol - defines the protocol (tcp or udp). (Required field.) External Port - provides the external destination port on the gateway unit. (Required field.) Internal Port - provides the port on a destination host. (Required field.) Enable Masquerading - defines whether masquerading is used (yes or no). If enabled, the gateway replaces the IP address of the originating host with the IP address of its own output (LAN) interface. This is needed when the destination host does not have a back route to the originating host (or default gateway route) via the gateway unit. The masquerading option is provided with port forwarding to limit gateway forwarding only to the destination port. (Required field.) Permitted Network - only forwards if the packet is originated from a host on this network. Permitted MAC Address - only forwards if the packet is originated by this host. Source Port Range - only forwards if the packet's source port is within the defined range. Complete the Port Forward Entry form and click the Apply button for the desired port forwarding rules to take effect. The firewall rules related to the port forwarding section are stored in the forward-kura-pf custom chain of the filter table and in the postrouting-kura-pf and prerouting-kura-pf chains of the nat table.","title":"Port Forwarding"},{"location":"config/firewall-configuration/#port-forwarding-example","text":"This section describes an example of port forwarding rules. The initial setup is described below. A couple of RaspberryPi 3 that shares the same LAN over Ethernet. The first RaspberryPi running Kura is configured as follows: The eth0 interface static with IP address of 172.16.0.5. There is no default gateway. The second RaspberryPi running Kura is configured as follows: The eth0 interface LAN/static with IP address of 172.16.0.1/24 and no NAT. The wlan0 interface is WAN/DHCP client. A laptop is connected to the same network of the wlan0 of the second RaspberryPi and can ping its wlan0 interface. The purpose of the second RaspberryPi configuration is to enable access to the Administration Console running on the first one (port 80) by connecting to the second RaspberryPi's port 8080 over the wlan. This scenario assumes that IP addresses are assigned as follows: Second RaspberryPi wlan0 - 10.200.12.6 Laptop wlan0 - 10.200.12.10 The following port forwarding entries are added to the second RaspberryPi configuration as described above using the Port Forward Entry form: Input Interface - wlan0 Output Interface - eth0 LAN Address - 172.16.0.5 Protocol - tcp External Port - 8080 Internal Port - 80 Masquerade - yes The Permitted Network , Permitted MAC Address , and Source Port Range fields are left blank. The following iptables rules are applied and added to the /etc/sysconfig/iptables file: iptables -t nat -A prerouting-kura-pf -i wlan0 -p tcp -s 0.0.0.0/0 --dport 8080 -j DNAT --to 172.16.0.5:80 iptables -t nat -A postrouting-kura-pf -o eth0 -p tcp -d 172.16.0.5 -j MASQUERADE iptables -A forward-kura-pf -i wlan0 -o eth0 -p tcp -s 0.0.0.0/0 --dport 80 -d 172.16.0.5 -j ACCEPT iptables -A forward-kura-pf -i eth0 -o wlan0 -p tcp -s 172.16.0.5 -m state --state RELATED,ESTABLISHED -j ACCEPT The following iptables commands may be used to verify that the new rules have been applied: sudo iptables -v -n -L sudo iptables -v -n -L -t nat At this point, it is possible to try to connect to http://10.200.12.6 and to http://10.200.12.6:8080 from the laptop. Note that when a connection is made to the device on port 80, it is to the Kura configuration page on the device itself (the second RaspberryPi). When the gateway is connected on port 8080, you are forwarded to the Kura Gateway Administration Console on the first RaspberryPi. The destination host can only be reached by connecting to the gateway on port 8080. Another way to connect to the Kura Gateway Administration Console on the first RaspberryPi would be to add an IP Forwarding/Masquerading entry as described in the next section.","title":"Port Forwarding example"},{"location":"config/firewall-configuration/#ip-forwardingmasquerading","text":"The advantage of the Automatic NAT method is its simplicity. However, this approach does not handle reverse NATing, and it cannot be used for interfaces that are not listed in the Gateway Administration Console. To set up generic (one-to-many) NATing, select the IP Forwarding/Masquerading tab on the Firewall display. The IP Forwarding/Masquerading form appears. The IP Forwarding/Masquerading form contains the following configuration parameters: Input Interface - specifies the interface through which a packet is going to be received. (Required field.) Output Interface - specifies the interface through which a packet is going to be forwarded to its destination. (Required field.) Protocol - defines the protocol of the rule to check (all, tcp, or udp). (Required field.) Source Network/Host - identifies the source network or host name (CIDR notation). Set to 0.0.0.0/0 if empty. Destination Network/Host - identifies the destination network or host name (CIDR notation). Set to 0.0.0.0/0 if empty. Enable Masquerading - defines whether masquerading is used (yes or no). If set to 'yes', masquerading is enabled. If set to 'no', only FORWARDING rules are being added. (Required field.) The rules will be added to the forward-kura-ipf chain in the filter table and in the postrouting-kura-ipf one in the nat table. As a use-case scenario, consider the same setup as in port forwarding. In this case, the interfaces of the gateway are configured as follows: eth0 - LAN/Static/No NAT 172.16.0.1/24 wlan0 - WAN/DHCP 10.200.12.6/24 To reach the RaspberryPi unit sitting on the 172.16.0.5/24 from a specific host on the 10.200.0.0/16 network, set up the following Reverse NAT entry: Input Interface - wlan0 (WAN interface) Output Interface - eth0 (LAN interface) Protocol - tcp Source Network/Host - 10.200.12.10/32 Destination Network/Host - 172.16.0.5/32 Enable Masquerading - yes This case adds the following iptables rules to the /etc/sysconfig/iptables file: iptables -t nat -A postrouting-kura-ipf -p tcp -s 10.200.12.6/32 -d 172.16.0.5/32 -o eth0 -j MASQUERADE iptables -A forward-kura-ipf -p tcp -s 172.16.0.5/32 -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A forward-kura-ipf -p tcp -s 10.200.12.6/32 -d 172.16.0.5/32 -i wlan0 -o eth0 -m tcp -j ACCEPT Additionally, a route to the 172.16.0.0/24 network needs to be configured on a connecting laptop as shown below: sudo route add -net 172.16.0.0 netmask 255.255.255.0 gw 10.200.12.6 Since masquerading is enabled, there is no need to specify the back route on the destination host. Note that with this setup, the RaspberryPi only forwards packets originating on the 10.200.12.10 laptop to the 172.16.0.5 destination. If the Source Network/Host and Destination Network/Host fields are empty, iptables rules appear as follows: iptables -t nat -A postrouting-kura-ipf -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -o eth0 -j MASQUERADE iptables -A forward-kura-ipf -p tcp -s 0.0.0.0/0 -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A forward-kura-ipf -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -i wlan0 -o eth0 -j ACCEPT The RaspberryPi forwards packets from any external host (connected to wlan0) to any destination on the local network (eth0 interface).","title":"IP Forwarding/Masquerading"},{"location":"config/gateway-status/","text":"Gateway Status The status of a gateway may be viewed from the Status window, which is accessed by selecting the Status option located in the System area. The Status window provides a summary of the key information regarding the status of the gateway including its IoT Cloud connection and network configuration. The values reported in the page can be reloaded using the Refresh button. This will read the current values from the system and update the page. Since the update procedure can take time, the update can be performed at most every 30 seconds. Cloud and Data Services This section provides a summary of the IoT Cloud connections status including the following details: Service Status - provides the status of the DataService and DataTransport connection. Valid values are CONNECTED or DISCONNECTED. Auto-connect - specifies whether the DataService automatically connects to the remote IoT Cloud Service on startup and disconnect. Broker URL - defines the URL of the MQTT broker. Account - defines the name of the account used by the MqttDataTransport service when an MQTT connection is opened. Username - supplies the name of the user used by the MqttDataTransport service when an MQTT connection is opened. Client ID - specifies the client identifier used by the MqttDataTransport service when an MQTT connection is opened. Ethernet and Wireless Settings These sections provide a summary of the network interfaces configurations as eth0, eth1 and wlan0. Position Status This section provides the GPS status and latest known position (if applicable) including the following details: Longitude - longitude as reported by the PositionService in degrees. Latitude - latitude as reported by the PositionService in degrees. Altitude - altitude as reported by the PositionService in meters. The status reported in the page may not be synchronized with the real state of the system. In this case, use the Refresh button to updated the values in the page.","title":"Gateway Status"},{"location":"config/gateway-status/#gateway-status","text":"The status of a gateway may be viewed from the Status window, which is accessed by selecting the Status option located in the System area. The Status window provides a summary of the key information regarding the status of the gateway including its IoT Cloud connection and network configuration. The values reported in the page can be reloaded using the Refresh button. This will read the current values from the system and update the page. Since the update procedure can take time, the update can be performed at most every 30 seconds.","title":"Gateway Status"},{"location":"config/gateway-status/#cloud-and-data-services","text":"This section provides a summary of the IoT Cloud connections status including the following details: Service Status - provides the status of the DataService and DataTransport connection. Valid values are CONNECTED or DISCONNECTED. Auto-connect - specifies whether the DataService automatically connects to the remote IoT Cloud Service on startup and disconnect. Broker URL - defines the URL of the MQTT broker. Account - defines the name of the account used by the MqttDataTransport service when an MQTT connection is opened. Username - supplies the name of the user used by the MqttDataTransport service when an MQTT connection is opened. Client ID - specifies the client identifier used by the MqttDataTransport service when an MQTT connection is opened.","title":"Cloud and Data Services"},{"location":"config/gateway-status/#ethernet-and-wireless-settings","text":"These sections provide a summary of the network interfaces configurations as eth0, eth1 and wlan0.","title":"Ethernet and Wireless Settings"},{"location":"config/gateway-status/#position-status","text":"This section provides the GPS status and latest known position (if applicable) including the following details: Longitude - longitude as reported by the PositionService in degrees. Latitude - latitude as reported by the PositionService in degrees. Altitude - altitude as reported by the PositionService in meters. The status reported in the page may not be synchronized with the real state of the system. In this case, use the Refresh button to updated the values in the page.","title":"Position Status"},{"location":"config/message-publishing-backoff-delay/","text":"Message Publishing Backoff Delay In order to have a finer control on the data flow, when a device reconnects to a remote cloud platform, ESF integrates into the Data Service a Backoff delay feature that limits the rate of messages sent. This feature, enabled by default, integrates the Token Bucket concept to limit the bursts of messages sent to a remote cloud platform. In the image below, the parameters that need to be tuned, in the Data Service, to take advantage of this feature: enable.rate.limit - Enables the token bucket message rate limiting. rate.limit.average - The average message publishing rate. It is intended as the number of messages per unit of time. rate.limit.time.unit - The time unit for the rate.limit.average. rate.limit.burst.size - The token bucket burst size. The default setup limits the data flow to 1 message per second with a bucket size of 1 token . This feature needs to be properly tuned by the System Administrator in order to prevent delays in the remote cloud platform due to messages stacked at the edge. If not sure of the number of messages that your gateways will try to push to the remote platform, disable this feature. .","title":"Message Publishing Backoff Delay"},{"location":"config/message-publishing-backoff-delay/#message-publishing-backoff-delay","text":"In order to have a finer control on the data flow, when a device reconnects to a remote cloud platform, ESF integrates into the Data Service a Backoff delay feature that limits the rate of messages sent. This feature, enabled by default, integrates the Token Bucket concept to limit the bursts of messages sent to a remote cloud platform. In the image below, the parameters that need to be tuned, in the Data Service, to take advantage of this feature: enable.rate.limit - Enables the token bucket message rate limiting. rate.limit.average - The average message publishing rate. It is intended as the number of messages per unit of time. rate.limit.time.unit - The time unit for the rate.limit.average. rate.limit.burst.size - The token bucket burst size. The default setup limits the data flow to 1 message per second with a bucket size of 1 token . This feature needs to be properly tuned by the System Administrator in order to prevent delays in the remote cloud platform due to messages stacked at the edge. If not sure of the number of messages that your gateways will try to push to the remote platform, disable this feature. .","title":"Message Publishing Backoff Delay"},{"location":"config/mqttdata-transport-service-configuration/","text":"MqttData Transport Service Configuration The MqttDataTransport service provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. To use this service, select the MqttDataTransport option located in the Cloud Services area as shown in the screen captures below. The MqttDataTransport service provides the following configuration parameters: broker-url - defines the URL of the MQTT broker to connect to. For the Eclipse IoT broker, this address is either Eclipse IoT: mqtt://iot.eclipse.org:1883/ or mqtts://iot.eclipse.org:8883/ for an encrypted connection. (Required field.) topic.context.account-name - defines the name of the account to which the device belongs. username and password - define the username and password that have been assigned to the device by the account administrator (generally username is account-name_broker). (Required field.) client-id - defines the identifier of the MQTT client representing the device when connecting to the MQTT broker. If left empty, it is automatically determined by the client software as the MAC address of the main network interface (in general numbers and uppercase letters without ':'). keep-alive - defines the \"keep alive\" interval measured in seconds. It specifies the maximum amount of time that should pass without communication between the client and the server. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during this time period, the client will send a very small MQTT \"ping\" message that the server will acknowledge. The keep alive interval enables the client to detect when the server is no longer available without having to wait for the long TCP/IP timeout. (Required field.) timeout - sets the timeout used for all interactions with the MQTT broker. (Required field.) clean-session - controls the behavior of both the client and the server at the time of connection and disconnection. When this parameter is set to true, the state information is discarded at connection and disconnection; when set to false, the state information is maintained. (Required field.) lwt parameters - define the MQTT \"Last Will and Testament\" (LWT) settings for the client. In the event that the client unexpectedly loses its connection to the server, the server publishes the LWT message (lwt.payload) to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. LWT parameters that may be configured include: lwt.topic lwt.payload lwt.qos lwt.retain in-flight.persistence - defines the storage type where in-flight messages are persisted across reconnections. They may be stored in memory, or in a file on the disk. (Required field.) protocol-version - defines the MQTT Protocol version to be used. This value may be 3.1 or 3.1.1. SSL parameters - define the SSL specific settings for the client. SSL parameters that can be configured include: ssl.default.protocol ssl.hostname.verification ssl.default.cipherSuites ssl.certificate.alias","title":"MqttData Transport Service Configuration"},{"location":"config/mqttdata-transport-service-configuration/#mqttdata-transport-service-configuration","text":"The MqttDataTransport service provides the ability to connect to a remote broker, publish messages, subscribe to topics, receive messages on the subscribed topics, and disconnect from the remote message broker. To use this service, select the MqttDataTransport option located in the Cloud Services area as shown in the screen captures below. The MqttDataTransport service provides the following configuration parameters: broker-url - defines the URL of the MQTT broker to connect to. For the Eclipse IoT broker, this address is either Eclipse IoT: mqtt://iot.eclipse.org:1883/ or mqtts://iot.eclipse.org:8883/ for an encrypted connection. (Required field.) topic.context.account-name - defines the name of the account to which the device belongs. username and password - define the username and password that have been assigned to the device by the account administrator (generally username is account-name_broker). (Required field.) client-id - defines the identifier of the MQTT client representing the device when connecting to the MQTT broker. If left empty, it is automatically determined by the client software as the MAC address of the main network interface (in general numbers and uppercase letters without ':'). keep-alive - defines the \"keep alive\" interval measured in seconds. It specifies the maximum amount of time that should pass without communication between the client and the server. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during this time period, the client will send a very small MQTT \"ping\" message that the server will acknowledge. The keep alive interval enables the client to detect when the server is no longer available without having to wait for the long TCP/IP timeout. (Required field.) timeout - sets the timeout used for all interactions with the MQTT broker. (Required field.) clean-session - controls the behavior of both the client and the server at the time of connection and disconnection. When this parameter is set to true, the state information is discarded at connection and disconnection; when set to false, the state information is maintained. (Required field.) lwt parameters - define the MQTT \"Last Will and Testament\" (LWT) settings for the client. In the event that the client unexpectedly loses its connection to the server, the server publishes the LWT message (lwt.payload) to the LWT topic on behalf of the client. This allows other clients (subscribed to the LWT topic) to be made aware that the client has disconnected. LWT parameters that may be configured include: lwt.topic lwt.payload lwt.qos lwt.retain in-flight.persistence - defines the storage type where in-flight messages are persisted across reconnections. They may be stored in memory, or in a file on the disk. (Required field.) protocol-version - defines the MQTT Protocol version to be used. This value may be 3.1 or 3.1.1. SSL parameters - define the SSL specific settings for the client. SSL parameters that can be configured include: ssl.default.protocol ssl.hostname.verification ssl.default.cipherSuites ssl.certificate.alias","title":"MqttData Transport Service Configuration"},{"location":"config/network-configuration/","text":"Network Configuration To configure the gateway network interfaces using the Administration Console, select the Network option located in the System area. With this option selected, the Network display appears with a list of available interfaces. Configuration tabs for the selected interface appear on the right side of the screen. By default, the loopback (lo) interface is selected when the network interfaces are displayed. Choose the desired network interface (e.g., eth0, eth1, wlan0, ppp0) and apply the necessary configuration changes using the tabs on the right. Submit the modified configuration by clicking the Apply button. In case of typing errors, the Reset button can be used to reload the prior configuration on the screen. Since the network configuration shown on the screen may not be synchronized with the current state of the system, it can be updated pressing the Refresh button. This can be used also to force the reload of specific parameters like the RSSI or dynamic IP addresses. The refresh procedure reads all the needed parameters from the system and can take several seconds before updating. It is recommended that the TCP/IP tab is configured first since it defines how the interface is going to be used. TCP/IP Configuration The TCP/IP tab contains the following configuration parameters: Status Disabled - disables the selected interface (i.e., administratively down). Enabled for LAN - designates the interface for a local network. It can be set as a DHCP server for hosts on the local network and can serve as a default gateway for those hosts; however, it cannot be set as an actual gateway interface for this device. That is, packets must be routed from this interface to another interface that is configured as WAN. Enabled for WAN - designates the interface as a gateway to an external network. Configure Manually - allows manual entry of the IP Address and Netmask fields, if the interface is configured as LAN; allows manual entry of the IP Address , Netmask , Gateway , and DNS Servers fields, if the interface is designated as WAN. Using DHCP - configures the interface as a DHCP client obtaining the IP address from a network DHCP server. IP Address - defines the IP address of the interface, if manually configured. Subnet Mask - defines the subnet mask of the interface, if manually configured. Gateway - specifies the default gateway for the unit. (Required field if the interface is designated as WAN and manually configured.) DNS Servers - provides a list of space separated DNS servers, if the interface is designated as WAN and is manually configured. Search Domains - not implemented. If the network interface is Enabled for LAN and manually configured (i.e., not a DHCP client), the DHCP & NAT tab allows the DHCP server to be configured and/or NAT (IP forwarding with masquerading) to be enabled. DHCP & NAT Configuration The DHCP & NAT tab contains the following configuration parameters: Router Mode DHCP and NAT - indicates that both DHCP server and NAT are enabled. DHCP Only - indicates that DHCP server is enabled and NAT is disabled. NAT Only - indicates that NAT is enabled and DHCP server is disabled. Off - indicates that both DHCP server and NAT are disabled. DHCP Beginning Address - specifies the first address of DHCP pool (i.e., first available client IP address). DHCP Ending Address - specifies the last address of DHCP pool (i.e., last IP address that can be assigned to a client). DHCP Subnet Mask - defines the subnet mask that is assigned to a client. DHCP Default Lease Time - sets the default time (in seconds) that the client retains the provided IP address. It must be greater than 0. DHCP Max Lease Time - sets the maximum time (in seconds) that the client retains the provided IP address. It must be greater than 0. Pass DNS Servers through DHCP - enables DNS Proxy (i.e., passing DNS servers through DHCP). If NAT is enabled and there is another interface designated as WAN (e.g., ppp0), the following iptables rules are added to the custom automatic NAT service rules section of the /etc/init.d/firewall script: # custom automatic NAT service rules (if NAT option is enabled for LAN interface) iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE iptables -A FORWARD -i ppp0 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A FORWARD -i eth0 -o ppp0 -j ACCEPT Also, IP forwarding is enabled in the kernel as follows: # allow forwarding if any masquerade is defined echo 1 > /proc/sys/net/ipv4/ip_forward The rules shown above create an Overloaded (i.e., many-to-one) NAT. This type of network address translation maps multiple IP addresses on the LAN side to a single IP address on the WAN side, allowing internet access from hosts on a local network via a gateway (WAN) interface. Note that for NAT rules to be added, it is insufficient to enable NATing through the DHCP & NAT tab of the LAN interface; there must also be another interface designated as WAN. Network Linux Configuration When applying a new network configuration, Kura changes the configuration files of the Linux networking subsystem. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state. Network Configuration properties The Network configuration can be modified using the ESF Gateway Administration Console, as described above, using the Configuration Service or by appling a proper snapshot . The following table describes all the properties related to the Network Configuration. Common properties Name Type Description net.interfaces String Comma-separated list of the interface names in the device net.interface.\\<interface>.config.type String The type of the network interface; possible values are: ETHERNET, WIFI, MODEM and LOOPBACK net.interface.\\<interface>.config.wifi.mode String For wifi interfaces, specify the modality; possible values are INFRA and MASTER net.interface.\\<interface>.config.nat.enabled Boolean Enable the NAT feature IPv4 properties Name Type Description net.interface.\\<interface>.config.ip4.status String The status of the interface for the IPv4 configuration; possibile values are: netIPv4StatusDisabled, netIPv4StatusUnmanaged, netIPv4StatusL2Only, netIPv4StatusEnabledLAN, netIPv4StatusEnabledWAN, netIPv4StatusUnknown net.interface.\\<interface>.config.ip4.address String The IPv4 address assigned to the network interface net.interface.\\<interface>.config.ip4.prefix Short The IPv4 netmask assigned to the network interface net.interface.\\<interface>.config.ip4.gateway String The IPv4 address of the default gateway net.interface.\\<interface>.config.ip4.dnsServers String Comma-separated list of dns servers IPv4 DHCP Server properties Name Type Description net.interface.\\<interface>.config.dhcpServer4.enabled Boolean Specify if the DHCP server is enabled net.interface.\\<interface>.config.dhcpServer4.rangeStart String First IP address available for clients net.interface.\\<interface>.config.dhcpServer4.rangeEnd String Last IP address available for clients net.interface.\\<interface>.config.dhcpServer4.defaultLeaseTime Integer The default lease time net.interface.\\<interface>.config.dhcpServer4.maxLeaseTime Integer The maximum lease time net.interface.\\<interface>.config.dhcpServer4.prefix Short The netmask for the available IP addresses net.interface.\\<interface>.config.dhcpServer4.passDns Boolean Specify if the DNS server addresses has to be passed through DHCP IPv4 DHCP Client properties Name Type Description net.interface.\\<interface>.config.dhcpClient4.enabled Boolean Specify if the DHCP client is enabled WiFi Master (Access Point) properties Name Type Description net.interface.\\<interface>.config.wifi.master.driver String The driver used for the connection net.interface.\\<interface>.config.wifi.master.passphrase Password The password for the access point net.interface.\\<interface>.config.wifi.master.ssid String The SSID of the access point net.interface.\\<interface>.config.wifi.master.securityType String The security protocol for the wireless network; possible values are SECURITY_NONE, SECURITY_WEP, SECURITY_WPA, SECURITY_WPA2, SECURITY_WPA_WPA2 net.interface.\\<interface>.config.wifi.master.mode String The mode of the wireless connection; for the access point mode set it to MASTER net.interface.\\<interface>.config.wifi.master.channel String The channel to be used for the access point net.interface.\\<interface>.config.wifi.master.radioMode String Specify the 802.11 radio mode; possible values are RADIO_MODE_80211a, RADIO_MODE_80211b, RADIO_MODE_80211g, RADIO_MODE_80211nHT20, RADIO_MODE_80211_AC net.interface.\\<interface>.config.wifi.master.ignoreSSID Boolean Specify if the SSID broadcast is ignored WiFi Infra (Station Mode) properties Name Type Description net.interface.\\<interface>.config.wifi.infra.ssid String The SSID of the wireless network to connect to net.interface.\\<interface>.config.wifi.infra.channel String The channel of the wireless network to connect to net.interface.\\<interface>.config.wifi.infra.bgscan String Set the background scans; possible values are None, Simple and Learn net.interface.\\<interface>.config.wifi.infra.passphrase Password The password for the wireless network net.interface.\\<interface>.config.wifi.infra.ignoreSSID Boolean Specify if a scan for SSID is required before attempting to associate net.interface.\\<interface>.config.wifi.infra.mode String The mode of the wireless connection; for station mode set to INFRA net.interface.\\<interface>.config.wifi.infra.pingAccessPoint Boolean Enable pinging the access point after connection is established net.interface.\\<interface>.config.wifi.infra.driver String The driver used for the connection net.interface.\\<interface>.config.wifi.infra.securityType String The security protocol for the wireless network; possible values are SECURITY_NONE, SECURITY_WEP, SECURITY_WPA, SECURITY_WPA2, SECURITY_WPA_WPA2 Cellular Modem properties Name Type Description net.interface.\\<interface>.config.enabled Boolean Enable the interface net.interface.\\<interface>.config.idle Integer The idle option of the PPP daemon net.interface.\\<interface>.config.password Password The password used for the connection net.interface.\\<interface>.config.pdpType String The PdP type; possible values are IP, PPP and IPv6 net.interface.\\<interface>.config.maxFail Integer The maxfail option of the PPP daemon net.interface.\\<interface>.config.authType String The authentication type; possible values are None, Auto, CHAP and PAP net.interface.\\<interface>.config.lpcEchoInterval Integer the lcp-echo-interval option of the PPP daemon net.interface.\\<interface>.config.activeFilter String The active-filter option of the PPP daemon net.interface.\\<interface>.config.lpcEchoFailure Integer The lcp-echo-failure option of the PPP daemon net.interface.\\<interface>.config.diversityEnabled Boolean Enable the LTE diversity antenna net.interface.\\<interface>.config.resetTimeout Integer The modem reset timeout in minutes net.interface.\\<interface>.config.gpsEnabled Boolean Enable the GPS device in the modem if available net.interface.\\<interface>.config.persist Boolean The persist option of the PPP daemon net.interface.\\<interface>.config.apn String The modem Access Point Name net.interface.\\<interface>.config.dialString String The dial string used for connecting to the APN Network Configuration recipes This section presents some snapshot examples to perform basic operations on networking. The snippets can be modified adapting them to the required configuration (i.e. changing the interface name in the property to be applied). {% include alerts.html message='Be aware that an inconsitent or wrong configuration can compromise the network functionality of the gateway. Try the new configuration on a test device before appling it in a production environment! Moreover, if a property is not present in the new snapshot, the old value is used for the configuration. So, the best practice is to set all the needed properties in the snapshot.' %} Disable a network interface <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusDisabled </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations> Configure an ethernet interface for WAN with DHCP client enabled and custom DNS server <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.dnsServers\" type= \"String\" > <esf:value> 1.2.3.4 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledWAN </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations> Configure an ethernet interface for LAN with DHCP server enabled and NAT disabled <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.rangeEnd\" type= \"String\" > <esf:value> 192.168.4.110 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.defaultLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.passDns\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.rangeStart\" type= \"String\" > <esf:value> 192.168.4.100 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.maxLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.address\" type= \"String\" > <esf:value> 192.168.4.1 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.gateway\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.nat.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations> Configure a wireless interface as access point with DHCP server and NAT enabled <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.type\" type= \"String\" > <esf:value> WIFI </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.gateway\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.address\" type= \"String\" > <esf:value> 172.16.1.1 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.rangeStart\" type= \"String\" > <esf:value> 172.16.1.100 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.maxLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.defaultLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.rangeEnd\" type= \"String\" > <esf:value> 172.16.1.110 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.passDns\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.nat.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.mode\" type= \"String\" > <esf:value> MASTER </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.driver\" type= \"String\" > <esf:value> nl80211 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.wlp1s0.config.wifi.master.passphrase\" type= \"Password\" > <esf:value> ZW5hYmxlbWVwbGVhc2U= </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.ssid\" type= \"String\" > <esf:value> kura_gateway_19 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.securityType\" type= \"String\" > <esf:value> SECURITY_WPA2 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.mode\" type= \"String\" > <esf:value> MASTER </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.channel\" type= \"String\" > <esf:value> 11 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.radioMode\" type= \"String\" > <esf:value> RADIO_MODE_80211g </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.ignoreSSID\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.pairwiseCiphers\" type= \"String\" > <esf:value> CCMP </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations> Configure a wireless interface as station mode with DHCP client enabled <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.type\" type= \"String\" > <esf:value> WIFI </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.mode\" type= \"String\" > <esf:value> INFRA </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.ssid\" type= \"String\" > <esf:value> MyWirelessNetwork </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.bgscan\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.wlp1s0.config.wifi.infra.passphrase\" type= \"Password\" > <esf:value> MyPasswordBase64 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.ignoreSSID\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.mode\" type= \"String\" > <esf:value> INFRA </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.pingAccessPoint\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.driver\" type= \"String\" > <esf:value> nl80211 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.securityType\" type= \"String\" > <esf:value> SECURITY_WPA2 </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations> Enable a cellular interface <?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.type\" type= \"String\" > <esf:value> MODEM </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledWAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.idle\" type= \"Integer\" > <esf:value> 95 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.1-1.config.password\" type= \"Password\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.pdpType\" type= \"String\" > <esf:value> IP </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ipAddress\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.maxFail\" type= \"Integer\" > <esf:value> 5 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.authType\" type= \"String\" > <esf:value> NONE </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.lcpEchoInterval\" type= \"Integer\" > <esf:value> 0 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.activeFilter\" type= \"String\" > <esf:value> inbound </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.lcpEchoFailure\" type= \"Integer\" > <esf:value> 0 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.diversityEnabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.resetTimeout\" type= \"Integer\" > <esf:value> 5 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.gpsEnabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.persist\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dialString\" type= \"String\" > <esf:value> atd*99***2# </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.apn\" type= \"String\" > <esf:value> web.omnitel.it </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Network Configuration"},{"location":"config/network-configuration/#network-configuration","text":"To configure the gateway network interfaces using the Administration Console, select the Network option located in the System area. With this option selected, the Network display appears with a list of available interfaces. Configuration tabs for the selected interface appear on the right side of the screen. By default, the loopback (lo) interface is selected when the network interfaces are displayed. Choose the desired network interface (e.g., eth0, eth1, wlan0, ppp0) and apply the necessary configuration changes using the tabs on the right. Submit the modified configuration by clicking the Apply button. In case of typing errors, the Reset button can be used to reload the prior configuration on the screen. Since the network configuration shown on the screen may not be synchronized with the current state of the system, it can be updated pressing the Refresh button. This can be used also to force the reload of specific parameters like the RSSI or dynamic IP addresses. The refresh procedure reads all the needed parameters from the system and can take several seconds before updating. It is recommended that the TCP/IP tab is configured first since it defines how the interface is going to be used.","title":"Network Configuration"},{"location":"config/network-configuration/#tcpip-configuration","text":"The TCP/IP tab contains the following configuration parameters: Status Disabled - disables the selected interface (i.e., administratively down). Enabled for LAN - designates the interface for a local network. It can be set as a DHCP server for hosts on the local network and can serve as a default gateway for those hosts; however, it cannot be set as an actual gateway interface for this device. That is, packets must be routed from this interface to another interface that is configured as WAN. Enabled for WAN - designates the interface as a gateway to an external network. Configure Manually - allows manual entry of the IP Address and Netmask fields, if the interface is configured as LAN; allows manual entry of the IP Address , Netmask , Gateway , and DNS Servers fields, if the interface is designated as WAN. Using DHCP - configures the interface as a DHCP client obtaining the IP address from a network DHCP server. IP Address - defines the IP address of the interface, if manually configured. Subnet Mask - defines the subnet mask of the interface, if manually configured. Gateway - specifies the default gateway for the unit. (Required field if the interface is designated as WAN and manually configured.) DNS Servers - provides a list of space separated DNS servers, if the interface is designated as WAN and is manually configured. Search Domains - not implemented. If the network interface is Enabled for LAN and manually configured (i.e., not a DHCP client), the DHCP & NAT tab allows the DHCP server to be configured and/or NAT (IP forwarding with masquerading) to be enabled.","title":"TCP/IP Configuration"},{"location":"config/network-configuration/#dhcp-nat-configuration","text":"The DHCP & NAT tab contains the following configuration parameters: Router Mode DHCP and NAT - indicates that both DHCP server and NAT are enabled. DHCP Only - indicates that DHCP server is enabled and NAT is disabled. NAT Only - indicates that NAT is enabled and DHCP server is disabled. Off - indicates that both DHCP server and NAT are disabled. DHCP Beginning Address - specifies the first address of DHCP pool (i.e., first available client IP address). DHCP Ending Address - specifies the last address of DHCP pool (i.e., last IP address that can be assigned to a client). DHCP Subnet Mask - defines the subnet mask that is assigned to a client. DHCP Default Lease Time - sets the default time (in seconds) that the client retains the provided IP address. It must be greater than 0. DHCP Max Lease Time - sets the maximum time (in seconds) that the client retains the provided IP address. It must be greater than 0. Pass DNS Servers through DHCP - enables DNS Proxy (i.e., passing DNS servers through DHCP). If NAT is enabled and there is another interface designated as WAN (e.g., ppp0), the following iptables rules are added to the custom automatic NAT service rules section of the /etc/init.d/firewall script: # custom automatic NAT service rules (if NAT option is enabled for LAN interface) iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE iptables -A FORWARD -i ppp0 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A FORWARD -i eth0 -o ppp0 -j ACCEPT Also, IP forwarding is enabled in the kernel as follows: # allow forwarding if any masquerade is defined echo 1 > /proc/sys/net/ipv4/ip_forward The rules shown above create an Overloaded (i.e., many-to-one) NAT. This type of network address translation maps multiple IP addresses on the LAN side to a single IP address on the WAN side, allowing internet access from hosts on a local network via a gateway (WAN) interface. Note that for NAT rules to be added, it is insufficient to enable NATing through the DHCP & NAT tab of the LAN interface; there must also be another interface designated as WAN.","title":"DHCP &amp; NAT Configuration"},{"location":"config/network-configuration/#network-linux-configuration","text":"When applying a new network configuration, Kura changes the configuration files of the Linux networking subsystem. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state.","title":"Network Linux Configuration"},{"location":"config/network-configuration/#network-configuration-properties","text":"The Network configuration can be modified using the ESF Gateway Administration Console, as described above, using the Configuration Service or by appling a proper snapshot . The following table describes all the properties related to the Network Configuration.","title":"Network Configuration properties"},{"location":"config/network-configuration/#common-properties","text":"Name Type Description net.interfaces String Comma-separated list of the interface names in the device net.interface.\\<interface>.config.type String The type of the network interface; possible values are: ETHERNET, WIFI, MODEM and LOOPBACK net.interface.\\<interface>.config.wifi.mode String For wifi interfaces, specify the modality; possible values are INFRA and MASTER net.interface.\\<interface>.config.nat.enabled Boolean Enable the NAT feature","title":"Common properties"},{"location":"config/network-configuration/#ipv4-properties","text":"Name Type Description net.interface.\\<interface>.config.ip4.status String The status of the interface for the IPv4 configuration; possibile values are: netIPv4StatusDisabled, netIPv4StatusUnmanaged, netIPv4StatusL2Only, netIPv4StatusEnabledLAN, netIPv4StatusEnabledWAN, netIPv4StatusUnknown net.interface.\\<interface>.config.ip4.address String The IPv4 address assigned to the network interface net.interface.\\<interface>.config.ip4.prefix Short The IPv4 netmask assigned to the network interface net.interface.\\<interface>.config.ip4.gateway String The IPv4 address of the default gateway net.interface.\\<interface>.config.ip4.dnsServers String Comma-separated list of dns servers","title":"IPv4 properties"},{"location":"config/network-configuration/#ipv4-dhcp-server-properties","text":"Name Type Description net.interface.\\<interface>.config.dhcpServer4.enabled Boolean Specify if the DHCP server is enabled net.interface.\\<interface>.config.dhcpServer4.rangeStart String First IP address available for clients net.interface.\\<interface>.config.dhcpServer4.rangeEnd String Last IP address available for clients net.interface.\\<interface>.config.dhcpServer4.defaultLeaseTime Integer The default lease time net.interface.\\<interface>.config.dhcpServer4.maxLeaseTime Integer The maximum lease time net.interface.\\<interface>.config.dhcpServer4.prefix Short The netmask for the available IP addresses net.interface.\\<interface>.config.dhcpServer4.passDns Boolean Specify if the DNS server addresses has to be passed through DHCP","title":"IPv4 DHCP Server properties"},{"location":"config/network-configuration/#ipv4-dhcp-client-properties","text":"Name Type Description net.interface.\\<interface>.config.dhcpClient4.enabled Boolean Specify if the DHCP client is enabled","title":"IPv4 DHCP Client properties"},{"location":"config/network-configuration/#wifi-master-access-point-properties","text":"Name Type Description net.interface.\\<interface>.config.wifi.master.driver String The driver used for the connection net.interface.\\<interface>.config.wifi.master.passphrase Password The password for the access point net.interface.\\<interface>.config.wifi.master.ssid String The SSID of the access point net.interface.\\<interface>.config.wifi.master.securityType String The security protocol for the wireless network; possible values are SECURITY_NONE, SECURITY_WEP, SECURITY_WPA, SECURITY_WPA2, SECURITY_WPA_WPA2 net.interface.\\<interface>.config.wifi.master.mode String The mode of the wireless connection; for the access point mode set it to MASTER net.interface.\\<interface>.config.wifi.master.channel String The channel to be used for the access point net.interface.\\<interface>.config.wifi.master.radioMode String Specify the 802.11 radio mode; possible values are RADIO_MODE_80211a, RADIO_MODE_80211b, RADIO_MODE_80211g, RADIO_MODE_80211nHT20, RADIO_MODE_80211_AC net.interface.\\<interface>.config.wifi.master.ignoreSSID Boolean Specify if the SSID broadcast is ignored","title":"WiFi Master (Access Point) properties"},{"location":"config/network-configuration/#wifi-infra-station-mode-properties","text":"Name Type Description net.interface.\\<interface>.config.wifi.infra.ssid String The SSID of the wireless network to connect to net.interface.\\<interface>.config.wifi.infra.channel String The channel of the wireless network to connect to net.interface.\\<interface>.config.wifi.infra.bgscan String Set the background scans; possible values are None, Simple and Learn net.interface.\\<interface>.config.wifi.infra.passphrase Password The password for the wireless network net.interface.\\<interface>.config.wifi.infra.ignoreSSID Boolean Specify if a scan for SSID is required before attempting to associate net.interface.\\<interface>.config.wifi.infra.mode String The mode of the wireless connection; for station mode set to INFRA net.interface.\\<interface>.config.wifi.infra.pingAccessPoint Boolean Enable pinging the access point after connection is established net.interface.\\<interface>.config.wifi.infra.driver String The driver used for the connection net.interface.\\<interface>.config.wifi.infra.securityType String The security protocol for the wireless network; possible values are SECURITY_NONE, SECURITY_WEP, SECURITY_WPA, SECURITY_WPA2, SECURITY_WPA_WPA2","title":"WiFi Infra (Station Mode) properties"},{"location":"config/network-configuration/#cellular-modem-properties","text":"Name Type Description net.interface.\\<interface>.config.enabled Boolean Enable the interface net.interface.\\<interface>.config.idle Integer The idle option of the PPP daemon net.interface.\\<interface>.config.password Password The password used for the connection net.interface.\\<interface>.config.pdpType String The PdP type; possible values are IP, PPP and IPv6 net.interface.\\<interface>.config.maxFail Integer The maxfail option of the PPP daemon net.interface.\\<interface>.config.authType String The authentication type; possible values are None, Auto, CHAP and PAP net.interface.\\<interface>.config.lpcEchoInterval Integer the lcp-echo-interval option of the PPP daemon net.interface.\\<interface>.config.activeFilter String The active-filter option of the PPP daemon net.interface.\\<interface>.config.lpcEchoFailure Integer The lcp-echo-failure option of the PPP daemon net.interface.\\<interface>.config.diversityEnabled Boolean Enable the LTE diversity antenna net.interface.\\<interface>.config.resetTimeout Integer The modem reset timeout in minutes net.interface.\\<interface>.config.gpsEnabled Boolean Enable the GPS device in the modem if available net.interface.\\<interface>.config.persist Boolean The persist option of the PPP daemon net.interface.\\<interface>.config.apn String The modem Access Point Name net.interface.\\<interface>.config.dialString String The dial string used for connecting to the APN","title":"Cellular Modem properties"},{"location":"config/network-configuration/#network-configuration-recipes","text":"This section presents some snapshot examples to perform basic operations on networking. The snippets can be modified adapting them to the required configuration (i.e. changing the interface name in the property to be applied). {% include alerts.html message='Be aware that an inconsitent or wrong configuration can compromise the network functionality of the gateway. Try the new configuration on a test device before appling it in a production environment! Moreover, if a property is not present in the new snapshot, the old value is used for the configuration. So, the best practice is to set all the needed properties in the snapshot.' %}","title":"Network Configuration recipes"},{"location":"config/network-configuration/#disable-a-network-interface","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusDisabled </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Disable a network interface"},{"location":"config/network-configuration/#configure-an-ethernet-interface-for-wan-with-dhcp-client-enabled-and-custom-dns-server","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.dnsServers\" type= \"String\" > <esf:value> 1.2.3.4 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledWAN </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Configure an ethernet interface for WAN with DHCP client enabled and custom DNS server"},{"location":"config/network-configuration/#configure-an-ethernet-interface-for-lan-with-dhcp-server-enabled-and-nat-disabled","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.type\" type= \"String\" > <esf:value> ETHERNET </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.rangeEnd\" type= \"String\" > <esf:value> 192.168.4.110 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.defaultLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.passDns\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.rangeStart\" type= \"String\" > <esf:value> 192.168.4.100 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.dhcpServer4.maxLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.address\" type= \"String\" > <esf:value> 192.168.4.1 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.ip4.gateway\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.enp5s0.config.nat.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Configure an ethernet interface for LAN with DHCP server enabled and NAT disabled"},{"location":"config/network-configuration/#configure-a-wireless-interface-as-access-point-with-dhcp-server-and-nat-enabled","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.type\" type= \"String\" > <esf:value> WIFI </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.gateway\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.address\" type= \"String\" > <esf:value> 172.16.1.1 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.rangeStart\" type= \"String\" > <esf:value> 172.16.1.100 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.maxLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.defaultLeaseTime\" type= \"Integer\" > <esf:value> 900 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.rangeEnd\" type= \"String\" > <esf:value> 172.16.1.110 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.prefix\" type= \"Short\" > <esf:value> 24 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.passDns\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.nat.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.mode\" type= \"String\" > <esf:value> MASTER </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.driver\" type= \"String\" > <esf:value> nl80211 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.wlp1s0.config.wifi.master.passphrase\" type= \"Password\" > <esf:value> ZW5hYmxlbWVwbGVhc2U= </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.ssid\" type= \"String\" > <esf:value> kura_gateway_19 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.securityType\" type= \"String\" > <esf:value> SECURITY_WPA2 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.mode\" type= \"String\" > <esf:value> MASTER </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.channel\" type= \"String\" > <esf:value> 11 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.radioMode\" type= \"String\" > <esf:value> RADIO_MODE_80211g </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.ignoreSSID\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.master.pairwiseCiphers\" type= \"String\" > <esf:value> CCMP </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Configure a wireless interface as access point with DHCP server and NAT enabled"},{"location":"config/network-configuration/#configure-a-wireless-interface-as-station-mode-with-dhcp-client-enabled","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.type\" type= \"String\" > <esf:value> WIFI </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledLAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.mode\" type= \"String\" > <esf:value> INFRA </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.ssid\" type= \"String\" > <esf:value> MyWirelessNetwork </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.bgscan\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.wlp1s0.config.wifi.infra.passphrase\" type= \"Password\" > <esf:value> MyPasswordBase64 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.ignoreSSID\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.mode\" type= \"String\" > <esf:value> INFRA </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.pingAccessPoint\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.driver\" type= \"String\" > <esf:value> nl80211 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.wlp1s0.config.wifi.infra.securityType\" type= \"String\" > <esf:value> SECURITY_WPA2 </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Configure a wireless interface as station mode with DHCP client enabled"},{"location":"config/network-configuration/#enable-a-cellular-interface","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?> <esf:configurations xmlns:esf= \"http://eurotech.com/esf/2.0\" xmlns:ocd= \"http://www.osgi.org/xmlns/metatype/v1.2.0\" > <esf:configuration pid= \"org.eclipse.kura.net.admin.NetworkConfigurationService\" > <esf:properties> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.type\" type= \"String\" > <esf:value> MODEM </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ip4.status\" type= \"String\" > <esf:value> netIPv4StatusEnabledWAN </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ip4.dnsServers\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dhcpClient4.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dhcpServer4.enabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.idle\" type= \"Integer\" > <esf:value> 95 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"true\" name= \"net.interface.1-1.config.password\" type= \"Password\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.pdpType\" type= \"String\" > <esf:value> IP </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.ipAddress\" type= \"String\" > <esf:value/> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.maxFail\" type= \"Integer\" > <esf:value> 5 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.authType\" type= \"String\" > <esf:value> NONE </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.lcpEchoInterval\" type= \"Integer\" > <esf:value> 0 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.enabled\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.activeFilter\" type= \"String\" > <esf:value> inbound </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.lcpEchoFailure\" type= \"Integer\" > <esf:value> 0 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.diversityEnabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.resetTimeout\" type= \"Integer\" > <esf:value> 5 </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.gpsEnabled\" type= \"Boolean\" > <esf:value> false </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.persist\" type= \"Boolean\" > <esf:value> true </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.dialString\" type= \"String\" > <esf:value> atd*99***2# </esf:value> </esf:property> <esf:property array= \"false\" encrypted= \"false\" name= \"net.interface.1-1.config.apn\" type= \"String\" > <esf:value> web.omnitel.it </esf:value> </esf:property> </esf:properties> </esf:configuration> </esf:configurations>","title":"Enable a cellular interface"},{"location":"config/ssl-configuration/","text":"SSL Configuration The Ssl Service manages the configuration of the SSL connections. It provides APIs to manage the trust certificates, private keys, and public certificates. It also enforces best practices that are not enabled by default in the Java VM, such as, enabling hostname verification, disabling the legacy SSL-2.0-compatible Client Hello, and disabling the Nagle algorithm. To use this service, select the SSL Configuration option located in Settings as shown in the screen capture below. The service provides the following configuration parameters: Default protocol - defines the allowed SSL protocol. Hostname verification - indicates whether hostname verification is enabled or disabled. Keystore path - specifies the location of the Key Store files. Keystore password - specifies the keystore access password. (Required field.) Cipher suites - defines the allowed cipher suites. At first boot, ESF verifies the accessibility of the default keystore provided with the distribution. If the keystore results accessible, ESF creates a new password that used to access and manage the keystore. The SSL keystore password can be freely changed with a new password, by specifying its value in the Keystore Password field. At every boot, ESF verifies the coherence of the keystore in order to prevent a possible keystore tampering. SSL Certificates Management Two administrative features are available under Settings , as shown in the screen capture below, to manage the SSL certificates: Server SSL Certificate and Device SSL Certificate . The Server SSL Certificate feature simplifies the process of keystore updating to add a public certificate, or a chain of public certificates, that are used to authenticate the broker. The update can be performed by setting the following fields: Storage Alias - defines the alias to be used to store the certificates. (Required field.) Certificate - provides a text area where the user can paste the certificate(s) that will be added to the SSL keystore. (Required field.) The Device SSL Certificate feature provides the ability to add a couple of private and certificate(s) into the device's keystore in order to enable the mutual authentication. The update can be performed by setting the following fields: Storage Alias - defines the alias to be used to store the certificates. (Required field.) Private key - provides a text area where the user can paste the private key to be added. (Required field.) Certificate - provides a text area where the user can paste a certificate or a chain of certificates. (Required field.) Server SSL Certificate The device requires a public key in its trust store in order to authenticate the broker and be able to setup an SSL connection. ESF is distributed with a pre-initialized SSL keystore that contains only some of the major Certification Authorities (CA) public keys. If the broker uses a certificate signed by a different CA, or uses an auto-signed certificate, the system administrator must setup ESF with the correct certificates used to trust the remote cloud broker. The inclusion of public certificates is accomplished with the Server SSL Certificate feature. To do so, the SSL Certificates form must be completed by providing a certificate or a certificates chain to be trusted and defining the alias used to register this new data in the device's trust store. With this feature, when the device tries to instantiate an SSL connection with the broker, it receives the broker's public key chain. The SSL connection is secured only if the received chain is trusted. This connection can only happen if one of the certificates that compose the broker chain are available in the device's trust store. When instantiating the device's trust store, the user decides whether to add a single certificate (leaf or CA certificate) or the full chain. In the latter case, the chain should be provided by specifying the leaf certificate, followed by the CA certificate that is signing it, and so on, until the root CA is reached. An example of this scenario is depicted in the following image: Device SSL Certificate & Mutual Authentication Mutual authentication is a technique that allows authentication of the device that is connecting to the broker. The form available in Device SSL Certificate may be used to specify the keys needed to enable mutual authentication. This authentication may be accomplished by specifying a couple of certificates (private and public keys) to be used by the client device to authenticate itself to the broker. This authentication is possible because the broker has the root CA certificate that has been used to sign the couple held by the device. In this way, the authenticity of the couple of certificates held by the device may be verified, and therefore, enable the two communicating parts (the broker and the device) to trust each other. To enable mutual authentication, the user must complete the form with a well-formed key pair (public and private), and with an alias value that corresponds with the account name used to connect to the broker. Key Pair Generation The keys may be generated using specific software, such as OpenSSL or Keytool . This section describes how to use OpenSSL to generate a couple of private and public keys. The private key may be created using the following command: openssl genrsa -out certsDirectory/certs/certificate.key 1024 This command creates a new, 1024-bit private key in the specified path. This key is used to generate a Certificate Signing Request (CSR) file, which is used by a CA to authenticate the certificate's creator. A CSR file is created with OpenSSL using the following command: openssl req -new -key certsDirectory/certs/certificate.key -out certsDirectory/crl/certificate.csr If the user is creating their own certificate chain, the CSR file may be signed using a personal CA. This process may be accomplished using OpenSSL with the following command: openssl ca -config certsDirectory/openssl.cnf -days 3650 -keyfile certsDirectory/ca/ca.key -cert certsDirectory/ca/ca.pem -out certsDirectory/certs/certificate.pem -infiles certsDirectory/crl/certificate.csr The parameters are defined as follows: -config - specifies the OpenSSL configuration file that must be used to sign the certificate. -days - specifies how long the certificate is valid. -keyfile and -cert - allow the specification of the CA that will sign the CSR file. -out - identifies the location and the name of the signed certificate that will be created. -infiles - identifies the location of the CSR file that has to be signed. {% include note.html message='The private key may not be placed into the Kura Gateway Administration Console without a format conversion.' %} OpenSSL offers the following command to convert the input private key to a non-encrypted PKCS#8 format that may be processed by the Kura code: openssl pkcs8 -topk8 -inform PEM -outform PEM -in inPrivateKey.key -out outKey.pem -nocrypt","title":"SSL Configuration"},{"location":"config/ssl-configuration/#ssl-configuration","text":"The Ssl Service manages the configuration of the SSL connections. It provides APIs to manage the trust certificates, private keys, and public certificates. It also enforces best practices that are not enabled by default in the Java VM, such as, enabling hostname verification, disabling the legacy SSL-2.0-compatible Client Hello, and disabling the Nagle algorithm. To use this service, select the SSL Configuration option located in Settings as shown in the screen capture below. The service provides the following configuration parameters: Default protocol - defines the allowed SSL protocol. Hostname verification - indicates whether hostname verification is enabled or disabled. Keystore path - specifies the location of the Key Store files. Keystore password - specifies the keystore access password. (Required field.) Cipher suites - defines the allowed cipher suites. At first boot, ESF verifies the accessibility of the default keystore provided with the distribution. If the keystore results accessible, ESF creates a new password that used to access and manage the keystore. The SSL keystore password can be freely changed with a new password, by specifying its value in the Keystore Password field. At every boot, ESF verifies the coherence of the keystore in order to prevent a possible keystore tampering.","title":"SSL Configuration"},{"location":"config/ssl-configuration/#ssl-certificates-management","text":"Two administrative features are available under Settings , as shown in the screen capture below, to manage the SSL certificates: Server SSL Certificate and Device SSL Certificate . The Server SSL Certificate feature simplifies the process of keystore updating to add a public certificate, or a chain of public certificates, that are used to authenticate the broker. The update can be performed by setting the following fields: Storage Alias - defines the alias to be used to store the certificates. (Required field.) Certificate - provides a text area where the user can paste the certificate(s) that will be added to the SSL keystore. (Required field.) The Device SSL Certificate feature provides the ability to add a couple of private and certificate(s) into the device's keystore in order to enable the mutual authentication. The update can be performed by setting the following fields: Storage Alias - defines the alias to be used to store the certificates. (Required field.) Private key - provides a text area where the user can paste the private key to be added. (Required field.) Certificate - provides a text area where the user can paste a certificate or a chain of certificates. (Required field.)","title":"SSL Certificates Management"},{"location":"config/ssl-configuration/#server-ssl-certificate","text":"The device requires a public key in its trust store in order to authenticate the broker and be able to setup an SSL connection. ESF is distributed with a pre-initialized SSL keystore that contains only some of the major Certification Authorities (CA) public keys. If the broker uses a certificate signed by a different CA, or uses an auto-signed certificate, the system administrator must setup ESF with the correct certificates used to trust the remote cloud broker. The inclusion of public certificates is accomplished with the Server SSL Certificate feature. To do so, the SSL Certificates form must be completed by providing a certificate or a certificates chain to be trusted and defining the alias used to register this new data in the device's trust store. With this feature, when the device tries to instantiate an SSL connection with the broker, it receives the broker's public key chain. The SSL connection is secured only if the received chain is trusted. This connection can only happen if one of the certificates that compose the broker chain are available in the device's trust store. When instantiating the device's trust store, the user decides whether to add a single certificate (leaf or CA certificate) or the full chain. In the latter case, the chain should be provided by specifying the leaf certificate, followed by the CA certificate that is signing it, and so on, until the root CA is reached. An example of this scenario is depicted in the following image:","title":"Server SSL Certificate"},{"location":"config/ssl-configuration/#device-ssl-certificate-mutual-authentication","text":"Mutual authentication is a technique that allows authentication of the device that is connecting to the broker. The form available in Device SSL Certificate may be used to specify the keys needed to enable mutual authentication. This authentication may be accomplished by specifying a couple of certificates (private and public keys) to be used by the client device to authenticate itself to the broker. This authentication is possible because the broker has the root CA certificate that has been used to sign the couple held by the device. In this way, the authenticity of the couple of certificates held by the device may be verified, and therefore, enable the two communicating parts (the broker and the device) to trust each other. To enable mutual authentication, the user must complete the form with a well-formed key pair (public and private), and with an alias value that corresponds with the account name used to connect to the broker.","title":"Device SSL Certificate &amp; Mutual Authentication"},{"location":"config/ssl-configuration/#key-pair-generation","text":"The keys may be generated using specific software, such as OpenSSL or Keytool . This section describes how to use OpenSSL to generate a couple of private and public keys. The private key may be created using the following command: openssl genrsa -out certsDirectory/certs/certificate.key 1024 This command creates a new, 1024-bit private key in the specified path. This key is used to generate a Certificate Signing Request (CSR) file, which is used by a CA to authenticate the certificate's creator. A CSR file is created with OpenSSL using the following command: openssl req -new -key certsDirectory/certs/certificate.key -out certsDirectory/crl/certificate.csr If the user is creating their own certificate chain, the CSR file may be signed using a personal CA. This process may be accomplished using OpenSSL with the following command: openssl ca -config certsDirectory/openssl.cnf -days 3650 -keyfile certsDirectory/ca/ca.key -cert certsDirectory/ca/ca.pem -out certsDirectory/certs/certificate.pem -infiles certsDirectory/crl/certificate.csr The parameters are defined as follows: -config - specifies the OpenSSL configuration file that must be used to sign the certificate. -days - specifies how long the certificate is valid. -keyfile and -cert - allow the specification of the CA that will sign the CSR file. -out - identifies the location and the name of the signed certificate that will be created. -infiles - identifies the location of the CSR file that has to be signed. {% include note.html message='The private key may not be placed into the Kura Gateway Administration Console without a format conversion.' %} OpenSSL offers the following command to convert the input private key to a non-encrypted PKCS#8 format that may be processed by the Kura code: openssl pkcs8 -topk8 -inform PEM -outform PEM -in inPrivateKey.key -out outKey.pem -nocrypt","title":"Key Pair Generation"},{"location":"config/threat-manager/","text":"Network Threat Manager Kura provides a set of features to detect and prevent network attacks. The Security section in the Gateway Administration Console shows the Network Threat Manager tab where is it possible to activate and configure these functions. The Network Threat Manager tab is not available for the No Network version of Kura. The following functions are supported: Flooding protection Flooding protection The flooding protection function is used to prevent DDos (Distributed Denial-of-Service) attacks using a set of firewall rules. The rules affect the mangle firewall table. The following rules are added to the mangle table and they are implemented to block invalid or malicious network packets: iptables -A prerouting-kura -m conntrack --ctstate INVALID -j DROP iptables -A prerouting-kura -p tcp ! --syn -m conntrack --ctstate NEW -j DROP iptables -A prerouting-kura -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags SYN,RST SYN,RST -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,RST FIN,RST -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,ACK FIN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,URG URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,FIN FIN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,PSH PSH -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL ALL -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL NONE -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP iptables -A prerouting-kura -p icmp -j DROP iptables -A prerouting-kura -f -j DROP The following parameters are available: flooding.protection.enabled : enables the application of the firewall rules for flooding protection.","title":"Network Threat Manager"},{"location":"config/threat-manager/#network-threat-manager","text":"Kura provides a set of features to detect and prevent network attacks. The Security section in the Gateway Administration Console shows the Network Threat Manager tab where is it possible to activate and configure these functions. The Network Threat Manager tab is not available for the No Network version of Kura. The following functions are supported: Flooding protection","title":"Network Threat Manager"},{"location":"config/threat-manager/#flooding-protection","text":"The flooding protection function is used to prevent DDos (Distributed Denial-of-Service) attacks using a set of firewall rules. The rules affect the mangle firewall table. The following rules are added to the mangle table and they are implemented to block invalid or malicious network packets: iptables -A prerouting-kura -m conntrack --ctstate INVALID -j DROP iptables -A prerouting-kura -p tcp ! --syn -m conntrack --ctstate NEW -j DROP iptables -A prerouting-kura -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags SYN,RST SYN,RST -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,RST FIN,RST -j DROP iptables -A prerouting-kura -p tcp --tcp-flags FIN,ACK FIN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,URG URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,FIN FIN -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ACK,PSH PSH -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL ALL -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL NONE -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP iptables -A prerouting-kura -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP iptables -A prerouting-kura -p icmp -j DROP iptables -A prerouting-kura -f -j DROP The following parameters are available: flooding.protection.enabled : enables the application of the firewall rules for flooding protection.","title":"Flooding protection"},{"location":"config/wi-fi-configuration/","text":"Wi-Fi Configuration From a configuration standpoint, the Wi-Fi interface (e.g., wlan0) may be viewed as an extension of Ethernet. In addition to the TCP/IP and DHCP & NAT configuration tabs, it has the Wireless tab that allows for the configuration of wireless settings. These configuration options are described below. Wireless Configuration The Wireless tab contains the following configuration parameters: Wireless Mode - defines the mode of operation. Access Point - creates a wireless access point. Station Mode - connects to a wireless access point. Network Name - specifies the Service Set Identifier (SSID). In Access Point mode, this is the SSID that identifies this wireless network. In Station mode, this is the SSID of a wireless network to connect to. Radio Mode - defines 802.11 mode. 802.11 ac/n/a (either in 2.4Ghz or 5Ghz depending on the choosen channel) 802.11n/g/b (2.4Ghz only) 802.11g/b (2.4Ghz only) 802.11b (2.4Ghz only) 802.11a (either in 2.4Ghz or 5Ghz depending on the choosen channel) Wireless Security - sets the security protocol for the wireless network. None - No Wi-Fi security WEP - Wired Equivalent Privacy WPA - Wi-Fi Protected Access WPA2 - Wi-Fi Protected Access II Wireless Password - sets the password for the wireless network. WEP - 64-bit or 128-bit encryption key WPA/WPA2 - pre-shared key Verify Password - sets the password verification field. In Access Point mode, allows the wireless password to be retyped for verification. In Station mode, this field is disabled. Pairwise Ciphers - lists accepted pairwise (unicast) ciphers for WPA/WPA2. In Access Point mode, this option is disabled. In Station mode, CCMP (AES-based encryption mode with strong security) TKIP (Temporal Key Integrity Protocol) CCMP and TKIP Group Ciphers - lists accepted group (broadcast/multicast) ciphers for WPA/WPA2. In Access Point mode, this option is disabled. In Station mode, CCMP (AES-based encryption mode with strong security) TKIP (Temporal Key Integrity Protocol) CCMP and TKIP Bgscan Module - requests background scans for the purpose of roaming within an ESS (i.e., within a single network block with all the APs using the same SSID). None - background scan is disabled Simple - periodic background scans based on the signal strength Learn - learn channels used by the network and try to avoid bgscans on other channels Bgscan Signal Strength Threshold - defines a threshold (in dBm) that determines which one of the following two parameters (i.e., Short Interval or Long Interval ) will be effective. Bgscan Short Interval - defines the interval between background scans (in seconds) if the actual signal level of the currently connected access point is worse than signal_strength. Bgscan Long Interval - defines the interval between background scans (in seconds) if the actual signal level of the currently connected access point is better than signal_strength. Ping Access Point & renew DHCP lease if not reachable - enables pinging the access point after the connection is established. In Access Point mode, this option is disabled. In Station mode, if set to true , the unit will ping the access point and attempt to renew the DHCP lease if the access point is not reachable. Ignore Broadcast SSID - operates as follows if set to true : In Access Point mode, sends an empty SSID in beacons and ignores probe request frames that do not specify full SSID. In Station mode, does not scan for the SSID before attempting to associate. Channels list - allows the selection of desired channel frequencies. The availability of the desired frequency is subject to the Regdom set on the device. For a list of limitations in different countries you can consult the following page: List of WLAN channels . Channels marked as No Irradiation and Radar Detection can be used only if DFS (Dynamic Frequency Selection) is supported by the Wi-Fi chip. In Access Point mode, only one channel may be selected. In Station mode, the list of available channels depends on the selected Radio Mode. The selected radio mode also affects the ability to select a network in the scan window (if the channel associated with the network is not enabled in the regulatory domain an error message will be shown). Wi-Fi Station Mode Configuration In addition to the options described above, the Wireless configuration display provides two buttons that help to configure Wi-Fi in the Station mode. These buttons are described below. Access Point Scan - clicking this button triggers access point scan operations. Upon a successful scan, a table containing access points within range is presented. This table contains the following information: SSID MAC Address Signal Strength (in dBm) Channel Frequency Security If you select one of these access points, respective wireless controls (i.e., Network Name , Wireless Security , and Channel ) are filled with information obtained during the scan operation. Password Verification - clicking this button triggers password verification before a full connection is established. Wi-Fi Linux Configuration This section describes the changes applied by Kura at the Linux networking configuration. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state. When the Wi-Fi configuration for the Access Point mode is submitted, Kura generates the /etc/hostapd.conf file and launches the hostapd program as shown below. hostapd:B /etc/hostapd.conf # /etc/hostapd/hostapd.conf interface=wlan0 driver=nl80211 # SSID to use. This will be the \"name\" of the access point ssid=kura_gateway_00:E0:C7:09:35:D8 # basic operational settings hw_mode=g wme_enabled=0 ieee80211n=0 channel=1 # Logging and debugging settings: more of this in original config file logger_syslog=-1 logger_syslog_level=2 logger_stdout=-1 logger_stdout_level=2 dump_file=/tmp/hostapd.dump # WPA settings. We'll use stronger WPA2 # bit0 = WPA # bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled) wpa=2 # Preshared key between 8-63 ASCII characters. # If you define the key in here, make sure that the file is not readable # by anyone but root. Alternatively you can use a separate file for the # key; see original hostapd.conf for more information. wpa_passphrase=testKEYS # Key management algorithm. In this case, a simple pre-shared key (PSK) wpa_key_mgmt=WPA-PSK # The cipher suite to use. We want to use stronger CCMP cipher. wpa_pairwise=CCMP # Change the broadcasted/multicasted keys after this many seconds. wpa_group_rekey=600 # Change the master key after this many seconds. The master key is used as a basis # (source) for the encryption keys. wpa_gmk_rekey=86400 # Send empty SSID in beacons and ignore probe request frames that do not # specify full SSID, i.e., require stations to know SSID. # default: disabled (0) # 1 = send empty (length=0) SSID in beacon and ignore probe request for # broadcast SSID # 2 = clear SSID (ASCII 0), but keep the original length (this may be required # with some clients that do not support empty SSID) and ignore probe # requests for broadcast SSID ignore_broadcast_ssid=0 When the Wi-Fi configuration for the Access Point mode is submitted, Kura generates the /etc/wpa_supplicant-wlan0.conf file and launches the wpa_supplicant program as shown below. wpa_supplicant -B -D nl80211 -i wlan0 -c /etc/wpa_supplicant-wlan0.conf # /etc/wpa_supplicant-wlan0.conf # allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group ctrl_interface=/var/run/wpa_supplicant ctrl_interface_group=wheel # home network; allow all valid ciphers network={ mode=0 ssid=\"Eurotech-INC\" scan_ssid=1 key_mgmt=WPA-PSK psk=\"WG4t3101\" proto=RSN pairwise=CCMP TKIP group=CCMP TKIP scan_freq=2412 bgscan=\"\" }","title":"Wi-Fi Configuration"},{"location":"config/wi-fi-configuration/#wi-fi-configuration","text":"From a configuration standpoint, the Wi-Fi interface (e.g., wlan0) may be viewed as an extension of Ethernet. In addition to the TCP/IP and DHCP & NAT configuration tabs, it has the Wireless tab that allows for the configuration of wireless settings. These configuration options are described below.","title":"Wi-Fi Configuration"},{"location":"config/wi-fi-configuration/#wireless-configuration","text":"The Wireless tab contains the following configuration parameters: Wireless Mode - defines the mode of operation. Access Point - creates a wireless access point. Station Mode - connects to a wireless access point. Network Name - specifies the Service Set Identifier (SSID). In Access Point mode, this is the SSID that identifies this wireless network. In Station mode, this is the SSID of a wireless network to connect to. Radio Mode - defines 802.11 mode. 802.11 ac/n/a (either in 2.4Ghz or 5Ghz depending on the choosen channel) 802.11n/g/b (2.4Ghz only) 802.11g/b (2.4Ghz only) 802.11b (2.4Ghz only) 802.11a (either in 2.4Ghz or 5Ghz depending on the choosen channel) Wireless Security - sets the security protocol for the wireless network. None - No Wi-Fi security WEP - Wired Equivalent Privacy WPA - Wi-Fi Protected Access WPA2 - Wi-Fi Protected Access II Wireless Password - sets the password for the wireless network. WEP - 64-bit or 128-bit encryption key WPA/WPA2 - pre-shared key Verify Password - sets the password verification field. In Access Point mode, allows the wireless password to be retyped for verification. In Station mode, this field is disabled. Pairwise Ciphers - lists accepted pairwise (unicast) ciphers for WPA/WPA2. In Access Point mode, this option is disabled. In Station mode, CCMP (AES-based encryption mode with strong security) TKIP (Temporal Key Integrity Protocol) CCMP and TKIP Group Ciphers - lists accepted group (broadcast/multicast) ciphers for WPA/WPA2. In Access Point mode, this option is disabled. In Station mode, CCMP (AES-based encryption mode with strong security) TKIP (Temporal Key Integrity Protocol) CCMP and TKIP Bgscan Module - requests background scans for the purpose of roaming within an ESS (i.e., within a single network block with all the APs using the same SSID). None - background scan is disabled Simple - periodic background scans based on the signal strength Learn - learn channels used by the network and try to avoid bgscans on other channels Bgscan Signal Strength Threshold - defines a threshold (in dBm) that determines which one of the following two parameters (i.e., Short Interval or Long Interval ) will be effective. Bgscan Short Interval - defines the interval between background scans (in seconds) if the actual signal level of the currently connected access point is worse than signal_strength. Bgscan Long Interval - defines the interval between background scans (in seconds) if the actual signal level of the currently connected access point is better than signal_strength. Ping Access Point & renew DHCP lease if not reachable - enables pinging the access point after the connection is established. In Access Point mode, this option is disabled. In Station mode, if set to true , the unit will ping the access point and attempt to renew the DHCP lease if the access point is not reachable. Ignore Broadcast SSID - operates as follows if set to true : In Access Point mode, sends an empty SSID in beacons and ignores probe request frames that do not specify full SSID. In Station mode, does not scan for the SSID before attempting to associate. Channels list - allows the selection of desired channel frequencies. The availability of the desired frequency is subject to the Regdom set on the device. For a list of limitations in different countries you can consult the following page: List of WLAN channels . Channels marked as No Irradiation and Radar Detection can be used only if DFS (Dynamic Frequency Selection) is supported by the Wi-Fi chip. In Access Point mode, only one channel may be selected. In Station mode, the list of available channels depends on the selected Radio Mode. The selected radio mode also affects the ability to select a network in the scan window (if the channel associated with the network is not enabled in the regulatory domain an error message will be shown).","title":"Wireless Configuration"},{"location":"config/wi-fi-configuration/#wi-fi-station-mode-configuration","text":"In addition to the options described above, the Wireless configuration display provides two buttons that help to configure Wi-Fi in the Station mode. These buttons are described below. Access Point Scan - clicking this button triggers access point scan operations. Upon a successful scan, a table containing access points within range is presented. This table contains the following information: SSID MAC Address Signal Strength (in dBm) Channel Frequency Security If you select one of these access points, respective wireless controls (i.e., Network Name , Wireless Security , and Channel ) are filled with information obtained during the scan operation. Password Verification - clicking this button triggers password verification before a full connection is established.","title":"Wi-Fi Station Mode Configuration"},{"location":"config/wi-fi-configuration/#wi-fi-linux-configuration","text":"This section describes the changes applied by Kura at the Linux networking configuration. Please read the following note before proceeding with manual changes in the Linux networking configuration. Manual editing of the Linux networking configuration file is NOT recommended when the gateway configuration is being managed through Kura. While Linux may correctly accept manual changes, Kura may not be able to interpret the new configuration resulting in an inconsistent state. When the Wi-Fi configuration for the Access Point mode is submitted, Kura generates the /etc/hostapd.conf file and launches the hostapd program as shown below. hostapd:B /etc/hostapd.conf # /etc/hostapd/hostapd.conf interface=wlan0 driver=nl80211 # SSID to use. This will be the \"name\" of the access point ssid=kura_gateway_00:E0:C7:09:35:D8 # basic operational settings hw_mode=g wme_enabled=0 ieee80211n=0 channel=1 # Logging and debugging settings: more of this in original config file logger_syslog=-1 logger_syslog_level=2 logger_stdout=-1 logger_stdout_level=2 dump_file=/tmp/hostapd.dump # WPA settings. We'll use stronger WPA2 # bit0 = WPA # bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled) wpa=2 # Preshared key between 8-63 ASCII characters. # If you define the key in here, make sure that the file is not readable # by anyone but root. Alternatively you can use a separate file for the # key; see original hostapd.conf for more information. wpa_passphrase=testKEYS # Key management algorithm. In this case, a simple pre-shared key (PSK) wpa_key_mgmt=WPA-PSK # The cipher suite to use. We want to use stronger CCMP cipher. wpa_pairwise=CCMP # Change the broadcasted/multicasted keys after this many seconds. wpa_group_rekey=600 # Change the master key after this many seconds. The master key is used as a basis # (source) for the encryption keys. wpa_gmk_rekey=86400 # Send empty SSID in beacons and ignore probe request frames that do not # specify full SSID, i.e., require stations to know SSID. # default: disabled (0) # 1 = send empty (length=0) SSID in beacon and ignore probe request for # broadcast SSID # 2 = clear SSID (ASCII 0), but keep the original length (this may be required # with some clients that do not support empty SSID) and ignore probe # requests for broadcast SSID ignore_broadcast_ssid=0 When the Wi-Fi configuration for the Access Point mode is submitted, Kura generates the /etc/wpa_supplicant-wlan0.conf file and launches the wpa_supplicant program as shown below. wpa_supplicant -B -D nl80211 -i wlan0 -c /etc/wpa_supplicant-wlan0.conf # /etc/wpa_supplicant-wlan0.conf # allow frontend (e.g., wpa_cli) to be used by all users in 'wheel' group ctrl_interface=/var/run/wpa_supplicant ctrl_interface_group=wheel # home network; allow all valid ciphers network={ mode=0 ssid=\"Eurotech-INC\" scan_ssid=1 key_mgmt=WPA-PSK psk=\"WG4t3101\" proto=RSN pairwise=CCMP TKIP group=CCMP TKIP scan_freq=2412 bgscan=\"\" }","title":"Wi-Fi Linux Configuration"},{"location":"intro/docker-quick-start/","text":"Docker Quick Start Installation Eclipse Kura is also available as a Docker container available in Docker Hub . To download and run, use the following command: docker run -d -p 443:443 -t eclipse/kura This command will start Kura in background and the Kura Web Ui will be available through port 443. Once the image is started you can navigate your browser to https://localhost and log in using the credentials admin : admin . Command Toolbox Following, a set of useful Docker command that can be used to list and manage Docker containers. For more details on Docker commands, please reference the official Docker documentation List Docker Images To list all the installed Docker images run: docker images List Running Docker Containers To list all the available instances (both running and powered off) run: docker ps -a Start/Stop a Docker Container docker stop <container id> docker start <container id> where <container id> is the instance identification number.","title":"Docker Quick Start"},{"location":"intro/docker-quick-start/#docker-quick-start","text":"","title":"Docker Quick Start"},{"location":"intro/docker-quick-start/#installation","text":"Eclipse Kura is also available as a Docker container available in Docker Hub . To download and run, use the following command: docker run -d -p 443:443 -t eclipse/kura This command will start Kura in background and the Kura Web Ui will be available through port 443. Once the image is started you can navigate your browser to https://localhost and log in using the credentials admin : admin .","title":"Installation"},{"location":"intro/docker-quick-start/#command-toolbox","text":"Following, a set of useful Docker command that can be used to list and manage Docker containers. For more details on Docker commands, please reference the official Docker documentation","title":"Command Toolbox"},{"location":"intro/docker-quick-start/#list-docker-images","text":"To list all the installed Docker images run: docker images","title":"List Docker Images"},{"location":"intro/docker-quick-start/#list-running-docker-containers","text":"To list all the available instances (both running and powered off) run: docker ps -a","title":"List Running Docker Containers"},{"location":"intro/docker-quick-start/#startstop-a-docker-container","text":"docker stop <container id> docker start <container id> where <container id> is the instance identification number.","title":"Start/Stop a Docker Container"},{"location":"intro/intel-up-2-quick-start/","text":"Intel Up\u00b2 Quick Start Overview This section provides Eclipse Kura\u2122 quick installation procedures for the Intel Up\u00b2 and the Kura development environment. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the following image: ubuntu-20.04.4-live-server-amd64.iso downloaded from https://releases.ubuntu.com/20.04/ubuntu-20.04.4-live-server-amd64.iso and with the image burned on an USB stick with balenaEtcher . A complete guide on how to install Ubuntu on the Intel Up\u00b2 can be found here . It is important, in order to access the HAT, Bluetooth, Wifi functionality, to follow the relative steps provided in the complete guide. Make sure to assign the right execute permissions to kurad user created by the installer as described here: Add Groups . It is high raccomanded to install the custom Intel kernel provided in the guide. Eclipse Kura\u2122 Installation To install Kura with its dependencies on the Intel Up\u00b2, perform the following steps: Boot the Intel Up\u00b2 with the Ubuntu Image 20.04.3. Make sure your device is connected to internet. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/<version>/kura_<version>_intel-up2-ubuntu-20_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: apt-get install./ kura_<version>_intel-up2-ubuntu-20_installer.deb Set the right Wi-Fi regulatory domain based on your current world region editing the /etc/default/crda and adding the ISO 3166-1 alpha-2 code of your region. Reboot the Intel Up\u00b2 with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Intel Up\u00b2 Quick Start"},{"location":"intro/intel-up-2-quick-start/#intel-up2-quick-start","text":"","title":"Intel Up\u00b2 Quick Start"},{"location":"intro/intel-up-2-quick-start/#overview","text":"This section provides Eclipse Kura\u2122 quick installation procedures for the Intel Up\u00b2 and the Kura development environment. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the following image: ubuntu-20.04.4-live-server-amd64.iso downloaded from https://releases.ubuntu.com/20.04/ubuntu-20.04.4-live-server-amd64.iso and with the image burned on an USB stick with balenaEtcher . A complete guide on how to install Ubuntu on the Intel Up\u00b2 can be found here . It is important, in order to access the HAT, Bluetooth, Wifi functionality, to follow the relative steps provided in the complete guide. Make sure to assign the right execute permissions to kurad user created by the installer as described here: Add Groups . It is high raccomanded to install the custom Intel kernel provided in the guide.","title":"Overview"},{"location":"intro/intel-up-2-quick-start/#eclipse-kura-installation","text":"To install Kura with its dependencies on the Intel Up\u00b2, perform the following steps: Boot the Intel Up\u00b2 with the Ubuntu Image 20.04.3. Make sure your device is connected to internet. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/<version>/kura_<version>_intel-up2-ubuntu-20_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: apt-get install./ kura_<version>_intel-up2-ubuntu-20_installer.deb Set the right Wi-Fi regulatory domain based on your current world region editing the /etc/default/crda and adding the ISO 3166-1 alpha-2 code of your region. Reboot the Intel Up\u00b2 with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Eclipse Kura&trade; Installation"},{"location":"intro/nvidia-jetson-nano-quick-start/","text":"NVIDIA Jetson Nano\u2122 - Quick Start Overview This section provides Eclipse Kura\u2122 quick installation procedures for the NVIDIA Jetson Nano\u2122. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the following image: jetson-nano-jp46-sd-card-image.zip downloaded from https://developer.nvidia.com/jetson-nano-sd-card-image and with the image burned on a SD card with Etcher . The official images can be found on the Jetson Nano Developer Kit Getting Starteg Guide . Further information on the Ubuntu installation for the NVIDIA Jetson Nano\u2122 can be found here . Eclipse Kura\u2122 Installation To install Eclipse Kura with its dependencies on the NVIDIA Jetson Nano\u2122, perform the following steps: Boot the NVIDIA Jetson Nano\u2122 with the latest Jetson Nano Developer Kit SD Card image. Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_nvidia-jetson-nano_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt install ./kura_<version>_nvidia-jetson-nano_installer.deb All the required dependencies will be downloaded and installed. Reboot the NVIDIA Jetson Nano\u2122 with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"NVIDIA Jetson Nano&trade; - Quick Start"},{"location":"intro/nvidia-jetson-nano-quick-start/#nvidia-jetson-nano-quick-start","text":"","title":"NVIDIA Jetson Nano&trade; - Quick Start"},{"location":"intro/nvidia-jetson-nano-quick-start/#overview","text":"This section provides Eclipse Kura\u2122 quick installation procedures for the NVIDIA Jetson Nano\u2122. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the following image: jetson-nano-jp46-sd-card-image.zip downloaded from https://developer.nvidia.com/jetson-nano-sd-card-image and with the image burned on a SD card with Etcher . The official images can be found on the Jetson Nano Developer Kit Getting Starteg Guide . Further information on the Ubuntu installation for the NVIDIA Jetson Nano\u2122 can be found here .","title":"Overview"},{"location":"intro/nvidia-jetson-nano-quick-start/#eclipse-kura-installation","text":"To install Eclipse Kura with its dependencies on the NVIDIA Jetson Nano\u2122, perform the following steps: Boot the NVIDIA Jetson Nano\u2122 with the latest Jetson Nano Developer Kit SD Card image. Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_nvidia-jetson-nano_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt install ./kura_<version>_nvidia-jetson-nano_installer.deb All the required dependencies will be downloaded and installed. Reboot the NVIDIA Jetson Nano\u2122 with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Eclipse Kura&trade; Installation"},{"location":"intro/raspberry-pi-raspbian-quick-start/","text":"Raspberry Pi - Raspbian Quick Start Overview This section provides Eclipse Kura\u2122 quick installation procedures for the Raspberry Pi and the Kura development environment. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page This quickstart has been tested using the following image: 2021-10-30-raspios-bullseye-armhf.zip downloaded from https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2021-11-08/2021-10-30-raspios-bullseye-armhf.zip Enable SSH Access The ssh server is disabled by default on Raspbian images released after November 2016, in order to enable it to follow the instructions available at the following URL: https://www.raspberrypi.org/documentation/remote-access/ssh/ Eclipse Kura\u2122 Installation The last Raspbian Stretch adopts the new Consistent Network Device Naming . To correctly run Eclipse Kura on the Raspberry Pi, it should be disabled adding the net.ifnames=0 parameter at the end of the /boot/cmdline.txt file. To install Eclipse Kura with its dependencies on the Raspberry Pi, perform the following steps: Boot the Raspberry Pi with the latest Raspbian image (starting from release 5.1.0 Kura is tested with Raspbian 11). Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_raspberry-pi_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt-get install ./kura_<version>_raspberry-pi_installer.deb It could happen that wlan interface is \"soft blocked\" by default and needs to be enabled. To see if it is blocked run: rfkill list and unblock it with: sudo rfkill unblock wlan Set the right Wi-Fi regulatory domain based on your current world region following the instructions here . In case of problems, you could try to edit the /etc/default/crda adding the ISO 3166-1 alpha-2 code of your region Reboot the Raspberry Pi with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Raspberry Pi - Raspbian Quick Start"},{"location":"intro/raspberry-pi-raspbian-quick-start/#raspberry-pi-raspbian-quick-start","text":"","title":"Raspberry Pi - Raspbian Quick Start"},{"location":"intro/raspberry-pi-raspbian-quick-start/#overview","text":"This section provides Eclipse Kura\u2122 quick installation procedures for the Raspberry Pi and the Kura development environment. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page This quickstart has been tested using the following image: 2021-10-30-raspios-bullseye-armhf.zip downloaded from https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2021-11-08/2021-10-30-raspios-bullseye-armhf.zip","title":"Overview"},{"location":"intro/raspberry-pi-raspbian-quick-start/#enable-ssh-access","text":"The ssh server is disabled by default on Raspbian images released after November 2016, in order to enable it to follow the instructions available at the following URL: https://www.raspberrypi.org/documentation/remote-access/ssh/","title":"Enable SSH Access"},{"location":"intro/raspberry-pi-raspbian-quick-start/#eclipse-kura-installation","text":"The last Raspbian Stretch adopts the new Consistent Network Device Naming . To correctly run Eclipse Kura on the Raspberry Pi, it should be disabled adding the net.ifnames=0 parameter at the end of the /boot/cmdline.txt file. To install Eclipse Kura with its dependencies on the Raspberry Pi, perform the following steps: Boot the Raspberry Pi with the latest Raspbian image (starting from release 5.1.0 Kura is tested with Raspbian 11). Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_raspberry-pi_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt-get install ./kura_<version>_raspberry-pi_installer.deb It could happen that wlan interface is \"soft blocked\" by default and needs to be enabled. To see if it is blocked run: rfkill list and unblock it with: sudo rfkill unblock wlan Set the right Wi-Fi regulatory domain based on your current world region following the instructions here . In case of problems, you could try to edit the /etc/default/crda adding the ISO 3166-1 alpha-2 code of your region Reboot the Raspberry Pi with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with an untrusted certificate: Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Eclipse Kura&trade; Installation"},{"location":"intro/raspberry-pi-ubuntu-20-quick-start/","text":"Raspberry Pi - Ubuntu 20 Quick Start Overview This section provides Eclipse Kura\u2122 quick installation procedures for the Raspberry Pi. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the Ubuntu 20.04.3 LTS Live Server for arm64 architecture flashed on the sd card through Raspberry Pi Imager . The official images can be also found on the Project Page . Further information on the Ubuntu installation for Raspberry Pi can be found here . Please note that, at the time of this writing, only 64 bit OS image is supported. Enable SSH Access On Ubuntu 20.04.3 the ssh access is enabled only for the standard ubuntu user. If you desire to remote login as root user, edit the file /etc/ssh/sshd_config (using the root permission) adding the line PermitRootLogin yes Eclipse Kura\u2122 Installation To install Eclipse Kura with its dependencies on the Raspberry Pi, perform the following steps: Boot the Raspberry Pi with the latest Ubuntu 20.04.3 LTS Server image. Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_raspberry-pi-ubuntu-20_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt install ./kura_<version>_raspberry-pi-ubuntu-20_installer.deb All the required dependencies will be downloaded and installed. Set the right Wi-Fi regulatory domain based on your current world region editing the /etc/default/crda and adding the ISO 3166-1 alpha-2 code of your region. Reboot the Raspberry Pi with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with a self signed certificate, select Accept the risk and continue : Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Raspberry Pi - Ubuntu 20 Quick Start"},{"location":"intro/raspberry-pi-ubuntu-20-quick-start/#raspberry-pi-ubuntu-20-quick-start","text":"","title":"Raspberry Pi - Ubuntu 20 Quick Start"},{"location":"intro/raspberry-pi-ubuntu-20-quick-start/#overview","text":"This section provides Eclipse Kura\u2122 quick installation procedures for the Raspberry Pi. This quickstart will install the version of Kura with the administrative web UI and network configuration support but not CAN support. For more information on this please visit the Eclipse Kura download page . This quickstart has been tested using the Ubuntu 20.04.3 LTS Live Server for arm64 architecture flashed on the sd card through Raspberry Pi Imager . The official images can be also found on the Project Page . Further information on the Ubuntu installation for Raspberry Pi can be found here . Please note that, at the time of this writing, only 64 bit OS image is supported.","title":"Overview"},{"location":"intro/raspberry-pi-ubuntu-20-quick-start/#enable-ssh-access","text":"On Ubuntu 20.04.3 the ssh access is enabled only for the standard ubuntu user. If you desire to remote login as root user, edit the file /etc/ssh/sshd_config (using the root permission) adding the line PermitRootLogin yes","title":"Enable SSH Access"},{"location":"intro/raspberry-pi-ubuntu-20-quick-start/#eclipse-kura-installation","text":"To install Eclipse Kura with its dependencies on the Raspberry Pi, perform the following steps: Boot the Raspberry Pi with the latest Ubuntu 20.04.3 LTS Server image. Make sure your device is connected to internet. By default, eth0 lan network interface is configured in DHCP mode. Upgrade the system: sudo apt update sudo apt upgrade Download the Kura package with: wget http://download.eclipse.org/kura/releases/&lt;version&gt;/kura_&lt;version&gt;_raspberry-pi-ubuntu-20_installer.deb Note: replace <version> in the URL above with the version number of the latest release (e.g. 5.1.0). Install Kura with: sudo apt install ./kura_<version>_raspberry-pi-ubuntu-20_installer.deb All the required dependencies will be downloaded and installed. Set the right Wi-Fi regulatory domain based on your current world region editing the /etc/default/crda and adding the ISO 3166-1 alpha-2 code of your region. Reboot the Raspberry Pi with: sudo reboot Kura starts on the target platform after reboot. Kura setups a local web ui that is available using a browser via: https://<device-ip> The browser will prompt the user to accept the connection to an endpoint with a self signed certificate, select Accept the risk and continue : Once trusted the source, the user will be redirected to a login page where the default username is: admin and the default password is: admin","title":"Eclipse Kura&trade; Installation"}]}